// Generated by CoffeeScript 1.3.3
(function() {
  var AlertView, App, BasicStrategy, Button, ButtonGrid, CharacterInfoView, CharacterRollView, ChooseCharacterView, CombatView, Combatant, CombatantView, ConfirmView, CreateView, Creature, Device, FlowView, Font, Game, GearView, Gurk, ImageProcessor, InfoView, Item, ItemInfoView, ItemView, LevelUpView, Library, Map, MapView, PartyView, Player, PlayerDialog, PlayerView, Preloader, QuestView, Screen, SelectView, SettingsView, SpellInfoView, SpellView, SplashView, Test, TileView, Util, Validate, View,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Device = (function() {

    function Device() {}

    Device.SAVE_KEY = "_GurkSavedGame";

    Device.SETTINGS_KEY = "_GurkSetting_";

    Device.hasSavedGame = function() {
      return !!getData(Device.SAVE_KEY);
    };

    Device.saveGame = function(game) {
      return putData(Device.SAVE_KEY, game);
    };

    Device.loadGame = function() {
      return getData(Device.SAVE_KEY);
    };

    Device.clearGame = function() {
      return putData(Device.SAVE_KEY, null);
    };

    Device.getSetting = function(name, defaultValue) {
      var key;
      key = Device.SETTINGS_KEY + name;
      if (!!getData(key)) {
        if (getData(key) === "false") {
          return false;
        } else {
          return true;
        }
      } else {
        return defaultValue;
      }
    };

    Device.setSetting = function(name, value) {
      var key;
      key = Device.SETTINGS_KEY + name;
      return putData(key, value);
    };

    return Device;

  }).call(this);

  Util = (function() {

    function Util() {}

    Util.random = function(min, max) {
      var diff;
      diff = max - min + 1;
      return Math.floor(Math.random() * diff) + min;
    };

    Util.randomChance = function(num, den) {
      return Math.random() * den < num;
    };

    Util.randomElement = function(array) {
      var n, x;
      n = array.length;
      x = Util.random(0, n - 1);
      return array[x];
    };

    Util.isEmpty = function(object) {
      var x, y;
      for (x in object) {
        y = object[x];
        return false;
      }
      return true;
    };

    Util.statRoll = function() {
      return Util.random(1, 6) + Util.random(1, 6) + Util.random(1, 6);
    };

    Util.shuffle = function(a) {
      var b, c, d;
      b = a.length;
      while (b) {
        c = Math.floor(Math.random() * b);
        d = a[--b];
        a[b] = a[c];
        a[c] = d;
      }
      return a;
    };

    Util.hasAllProperties = function(obj, properties) {
      var a, _i, _len;
      if (properties instanceof Array) {
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          a = properties[_i];
          if (!obj[a]) {
            return false;
          }
        }
      } else {
        if (!obj[properties]) {
          return false;
        }
      }
      return true;
    };

    Util.hasCommonElements = function(array1, array2) {
      var a, b, _i, _j, _len, _len1;
      array1 = [].concat(array1);
      array2 = [].concat(array2);
      for (_i = 0, _len = array1.length; _i < _len; _i++) {
        a = array1[_i];
        for (_j = 0, _len1 = array2.length; _j < _len1; _j++) {
          b = array2[_j];
          if (a === b) {
            return true;
          }
        }
      }
      return false;
    };

    Util.hasElement = function(array, element) {
      var a, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        if (a === element) {
          return true;
        }
      }
      return false;
    };

    Util.indexOfElement = function(array, element) {
      var a, index, _i, _len;
      index = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        if (a === element) {
          return index;
        }
        index++;
      }
      return -1;
    };

    Util.trunc = function(x) {
      return x | 0;
    };

    Util.create2DArray = function(width, height) {
      var a, b, x, y, _i, _j;
      a = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        b = [];
        a.push(b);
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
          b.push([]);
        }
      }
      return a;
    };

    Util.removeElement = function(array, element) {
      var a, index, _i, _len;
      index = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        if (a === element) {
          array.splice(index, 1);
          return true;
        }
        index++;
      }
      return false;
    };

    Util.copyProperties = function(source, dest) {
      var k, v, _results;
      _results = [];
      for (k in source) {
        v = source[k];
        _results.push(dest[k] = v);
      }
      return _results;
    };

    Util.rgb = function(red, green, blue) {
      return {
        "red": red,
        "green": green,
        "blue": blue
      };
    };

    Util.blendColors = function(color1, color2, p1, p2) {
      var blue, green, red;
      red = Math.round(color1.red * p1 + color2.red * p2);
      green = Math.round(color1.green * p1 + color2.green * p2);
      blue = Math.round(color1.blue * p1 + color2.blue * p2);
      return {
        "red": red,
        "green": green,
        "blue": blue
      };
    };

    Util.capitalize = function(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    };

    Util.arrayToString = function(array) {
      var first, item, text, _i, _len;
      if (!array || array.length === 0) {
        return null;
      } else {
        first = true;
        text = "";
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          item = array[_i];
          if (first) {
            text += item;
            first = false;
          } else {
            text += ", " + item;
          }
        }
        return text;
      }
    };

    return Util;

  })();

  Preloader = (function() {

    function Preloader() {}

    Preloader.images = null;

    Preloader.loadedCount = 0;

    Preloader.addedCount = 0;

    Preloader.images = {};

    Preloader.callback = null;

    Preloader.reset = function() {
      Preloader.addedCount = 0;
      return Preloader.loadedCount = 0;
    };

    Preloader.imageLoaded = function() {
      Preloader.loadedCount++;
      console.log("Preloading loading finished: " + Preloader.loadedCount + "/" + Preloader.addedCount + " done.");
      if (Preloader.loadedCount + 1 === Preloader.addedCount && Preloader.callback) {
        console.log("Preloading calling back.");
        return Preloader.callback();
      }
    };

    Preloader.load = function(src) {
      var item;
      console.log("Loading '" + src + "'");
      if (!Preloader.images[src]) {
        Preloader.addedCount++;
        console.log("Add count now " + Preloader.addedCount);
        item = new Image();
        Preloader.images[src] = item;
        item.onload = Preloader.imageLoaded;
        item.src = src;
        return item;
      } else {
        console.log("Already loaded.");
        return Preloader.images[src];
      }
    };

    Preloader.setCallback = function(callback) {
      console.log("Preloader callback set.");
      Preloader.callback = callback;
      if (Preloader.loadedCount === Preloader.addedCount) {
        return callback();
      }
    };

    Preloader.getImage = function(src) {
      var item;
      item = Preloader.images[src];
      if (!item) {
        item = Preloader.load(src);
      }
      return item;
    };

    return Preloader;

  }).call(this);

  Font = (function() {

    Font.prototype.image = null;

    Font.prototype.fontHeight = 0;

    function Font(glyphMap, imageSrc) {
      this.glyphMap = glyphMap;
      this.wrapText = __bind(this.wrapText, this);

      this.centerText = __bind(this.centerText, this);

      this.getWidth = __bind(this.getWidth, this);

      this.drawText = __bind(this.drawText, this);

      this.drawChar = __bind(this.drawChar, this);

      this.image = Preloader.getImage(imageSrc);
      this.fontHeight = this.glyphMap['A'].height;
    }

    Font.prototype.drawChar = function(ctx, c, x, y) {
      var glyph, xx, yy;
      glyph = this.glyphMap[c];
      xx = x * Screen.SCALE;
      yy = y * Screen.SCALE;
      ctx.drawImage(this.image, Screen.SCALE * glyph.x, Screen.SCALE * glyph.y, Screen.SCALE * glyph.width, Screen.SCALE * glyph.height, xx, yy, Screen.SCALE * glyph.width, Screen.SCALE * glyph.height);
      return glyph.width;
    };

    Font.prototype.drawText = function(ctx, text, color, x, y) {
      var i, n, width, _i, _j;
      n = text.length;
      width = 0;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        width += this.glyphMap[text.charAt(i)].width;
      }
      ctx.fillStyle = color;
      ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, width * Screen.SCALE, this.fontHeight * Screen.SCALE);
      for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
        x += this.drawChar(ctx, text.charAt(i), x, y);
      }
      return text;
    };

    Font.prototype.getWidth = function(text) {
      var i, n, width, _i;
      n = text.length;
      width = 0;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        width += this.glyphMap[text.charAt(i)].width;
      }
      return width;
    };

    Font.prototype.centerText = function(ctx, text, color, x, y, w, h) {
      var offsetX, offsetY, width;
      width = this.getWidth(text);
      offsetX = Math.floor((w - width) / 2);
      offsetY = Math.floor((h - this.fontHeight) / 2);
      return this.drawText(ctx, text, color, x + offsetX, y + offsetY);
    };

    Font.prototype.wrapText = function(ctx, text, color, x, y, width) {
      var breakLine, c, force, i, last, line, n, newLine, start, totalLines, w;
      n = text.length;
      start = 0;
      last = 0;
      i = 0;
      w = 0;
      totalLines = 1;
      while (i < n) {
        breakLine = false;
        force = false;
        newLine = false;
        c = text.charAt(i);
        if (c === ' ') {
          last = i;
        } else if (c === '\n') {
          last = i;
          breakLine = true;
          newLine = true;
        }
        if (!breakLine) {
          w += this.glyphMap[text.charAt(i)].width;
          if (w > width) {
            breakLine = true;
          }
        }
        if (breakLine) {
          if (last === start && !newLine) {
            last = i;
            force = true;
          }
          line = text.substring(start, last);
          this.drawText(ctx, line, color, x, y);
          y += this.fontHeight;
          totalLines++;
          if (force) {
            start = last;
          } else {
            start = last + 1;
          }
          last = start;
          i = start;
          w = 0;
        } else {
          i++;
        }
      }
      if (start < n - 1) {
        line = text.substring(start);
        this.drawText(ctx, line, color, x, y);
      }
      return totalLines * this.fontHeight;
    };

    return Font;

  })();

  Screen = (function() {

    Screen.SCALE = pixelWidth;

    Screen.SIZE = 128;

    Screen.GURK_BLUE = "#004c62";

    Screen.UNIT = 16;

    Screen.HALF_UNIT = Screen.UNIT / 2;

    Screen.WIN_SIZE = 9;

    Screen.CENTER_OFFSET = 0;

    Screen.ICONS_PER_ROW = 7;

    Screen.prototype.icons = null;

    Screen.prototype.screen = null;

    Screen.MICRO_GLYPHS = {
      'A': {
        x: 0,
        y: 0,
        width: 5,
        height: 8
      },
      'B': {
        x: 5,
        y: 0,
        width: 5,
        height: 8
      },
      'C': {
        x: 10,
        y: 0,
        width: 4,
        height: 8
      },
      'D': {
        x: 14,
        y: 0,
        width: 5,
        height: 8
      },
      'E': {
        x: 19,
        y: 0,
        width: 4,
        height: 8
      },
      'F': {
        x: 23,
        y: 0,
        width: 4,
        height: 8
      },
      'G': {
        x: 27,
        y: 0,
        width: 5,
        height: 8
      },
      'H': {
        x: 32,
        y: 0,
        width: 5,
        height: 8
      },
      'I': {
        x: 37,
        y: 0,
        width: 4,
        height: 8
      },
      'J': {
        x: 41,
        y: 0,
        width: 5,
        height: 8
      },
      'K': {
        x: 46,
        y: 0,
        width: 5,
        height: 8
      },
      'L': {
        x: 51,
        y: 0,
        width: 4,
        height: 8
      },
      'M': {
        x: 55,
        y: 0,
        width: 6,
        height: 8
      },
      'N': {
        x: 61,
        y: 0,
        width: 5,
        height: 8
      },
      'O': {
        x: 66,
        y: 0,
        width: 5,
        height: 8
      },
      'P': {
        x: 71,
        y: 0,
        width: 5,
        height: 8
      },
      'Q': {
        x: 76,
        y: 0,
        width: 5,
        height: 8
      },
      'R': {
        x: 81,
        y: 0,
        width: 5,
        height: 8
      },
      'S': {
        x: 86,
        y: 0,
        width: 5,
        height: 8
      },
      'T': {
        x: 91,
        y: 0,
        width: 4,
        height: 8
      },
      'U': {
        x: 95,
        y: 0,
        width: 5,
        height: 8
      },
      'V': {
        x: 100,
        y: 0,
        width: 5,
        height: 8
      },
      'W': {
        x: 105,
        y: 0,
        width: 6,
        height: 8
      },
      'X': {
        x: 111,
        y: 0,
        width: 5,
        height: 8
      },
      'Y': {
        x: 116,
        y: 0,
        width: 5,
        height: 8
      },
      'Z': {
        x: 121,
        y: 0,
        width: 4,
        height: 8
      },
      'a': {
        x: 0,
        y: 8,
        width: 5,
        height: 8
      },
      'b': {
        x: 5,
        y: 8,
        width: 5,
        height: 8
      },
      'c': {
        x: 10,
        y: 8,
        width: 4,
        height: 8
      },
      'd': {
        x: 14,
        y: 8,
        width: 5,
        height: 8
      },
      'e': {
        x: 19,
        y: 8,
        width: 5,
        height: 8
      },
      'f': {
        x: 24,
        y: 8,
        width: 4,
        height: 8
      },
      'g': {
        x: 28,
        y: 8,
        width: 5,
        height: 8
      },
      'h': {
        x: 33,
        y: 8,
        width: 5,
        height: 8
      },
      'i': {
        x: 38,
        y: 8,
        width: 2,
        height: 8
      },
      'j': {
        x: 40,
        y: 8,
        width: 3,
        height: 8
      },
      'k': {
        x: 43,
        y: 8,
        width: 5,
        height: 8
      },
      'l': {
        x: 48,
        y: 8,
        width: 2,
        height: 8
      },
      'm': {
        x: 50,
        y: 8,
        width: 6,
        height: 8
      },
      'n': {
        x: 56,
        y: 8,
        width: 5,
        height: 8
      },
      'o': {
        x: 61,
        y: 8,
        width: 5,
        height: 8
      },
      'p': {
        x: 66,
        y: 8,
        width: 5,
        height: 8
      },
      'q': {
        x: 71,
        y: 8,
        width: 5,
        height: 8
      },
      'r': {
        x: 76,
        y: 8,
        width: 4,
        height: 8
      },
      's': {
        x: 80,
        y: 8,
        width: 5,
        height: 8
      },
      't': {
        x: 85,
        y: 8,
        width: 4,
        height: 8
      },
      'u': {
        x: 89,
        y: 8,
        width: 5,
        height: 8
      },
      'v': {
        x: 94,
        y: 8,
        width: 5,
        height: 8
      },
      'w': {
        x: 99,
        y: 8,
        width: 6,
        height: 8
      },
      'x': {
        x: 105,
        y: 8,
        width: 4,
        height: 8
      },
      'y': {
        x: 109,
        y: 8,
        width: 5,
        height: 8
      },
      'z': {
        x: 114,
        y: 8,
        width: 5,
        height: 8
      },
      '#': {
        x: 119,
        y: 8,
        width: 6,
        height: 8
      },
      '1': {
        x: 0,
        y: 17,
        width: 3,
        height: 8
      },
      '2': {
        x: 3,
        y: 17,
        width: 5,
        height: 8
      },
      '3': {
        x: 8,
        y: 17,
        width: 5,
        height: 8
      },
      '4': {
        x: 13,
        y: 17,
        width: 5,
        height: 8
      },
      '5': {
        x: 18,
        y: 17,
        width: 5,
        height: 8
      },
      '6': {
        x: 23,
        y: 17,
        width: 5,
        height: 8
      },
      '7': {
        x: 28,
        y: 17,
        width: 5,
        height: 8
      },
      '8': {
        x: 33,
        y: 17,
        width: 5,
        height: 8
      },
      '9': {
        x: 38,
        y: 17,
        width: 5,
        height: 8
      },
      '0': {
        x: 43,
        y: 17,
        width: 5,
        height: 8
      },
      ',': {
        x: 48,
        y: 17,
        width: 3,
        height: 8
      },
      '.': {
        x: 51,
        y: 17,
        width: 2,
        height: 8
      },
      '?': {
        x: 53,
        y: 17,
        width: 5,
        height: 8
      },
      '!': {
        x: 58,
        y: 17,
        width: 2,
        height: 8
      },
      "'": {
        x: 60,
        y: 17,
        width: 2,
        height: 8
      },
      '"': {
        x: 65,
        y: 17,
        width: 4,
        height: 8
      },
      '/': {
        x: 69,
        y: 17,
        width: 6,
        height: 8
      },
      '(': {
        x: 81,
        y: 17,
        width: 3,
        height: 8
      },
      ')': {
        x: 84,
        y: 17,
        width: 3,
        height: 8
      },
      '[': {
        x: 87,
        y: 17,
        width: 3,
        height: 8
      },
      ']': {
        x: 90,
        y: 17,
        width: 3,
        height: 8
      },
      ':': {
        x: 103,
        y: 17,
        width: 2,
        height: 8
      },
      '-': {
        x: 105,
        y: 17,
        width: 4,
        height: 8
      },
      '*': {
        x: 109,
        y: 17,
        width: 4,
        height: 8
      },
      '+': {
        x: 114,
        y: 17,
        width: 4,
        height: 8
      },
      ' ': {
        x: 122,
        y: 17,
        width: 4,
        height: 8
      },
      '~': {
        x: 0,
        y: 25,
        width: 10,
        height: 8
      },
      '`': {
        x: 10,
        y: 25,
        width: 6,
        height: 8
      },
      '=': {
        x: 16,
        y: 25,
        width: 4,
        height: 8
      },
      '|': {
        x: 20,
        y: 25,
        width: 4,
        height: 8
      }
    };

    Screen.FONT = null;

    function Screen(ctx) {
      this.ctx = ctx;
      this.fillRect = __bind(this.fillRect, this);

      this.drawPixel = __bind(this.drawPixel, this);

      this.setAlpha = __bind(this.setAlpha, this);

      this.wrapText = __bind(this.wrapText, this);

      this.drawTextCentered = __bind(this.drawTextCentered, this);

      this.drawText = __bind(this.drawText, this);

      this.drawCustomAnim = __bind(this.drawCustomAnim, this);

      this.drawAnim = __bind(this.drawAnim, this);

      this.drawImage = __bind(this.drawImage, this);

      this.drawIcon = __bind(this.drawIcon, this);

      this.drawScreen = __bind(this.drawScreen, this);

      this.clearColor = __bind(this.clearColor, this);

      this.clear = __bind(this.clear, this);

      Screen.FONT = new Font(Screen.MICRO_GLYPHS, "font_micro" + Screen.SCALE + ".png");
      this.icons = [Preloader.getImage("icons0-" + Screen.SCALE + ".png"), Preloader.getImage("icons1-" + Screen.SCALE + ".png")];
      this.screen = Preloader.getImage("screen" + Screen.SCALE + ".png");
      Screen.CENTER_OFFSET = Math.floor(Screen.WIN_SIZE / 2);
    }

    Screen.prototype.clear = function() {
      return this.clearColor("#000");
    };

    Screen.prototype.clearColor = function(color) {
      this.ctx.fillStyle = color;
      return this.ctx.fillRect(0, 0, Screen.WIN_SIZE * Screen.UNIT * Screen.SCALE, Screen.WIN_SIZE * Screen.UNIT * Screen.SCALE);
    };

    Screen.prototype.drawScreen = function() {
      return this.ctx.drawImage(this.screen, 0, 0);
    };

    Screen.prototype.drawIcon = function(icon, x, y) {
      var coords, k;
      coords = Icons[icon];
      k = Screen.UNIT * Screen.SCALE;
      return this.ctx.drawImage(this.icons[coords.block], k * coords.x, k * coords.y, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
    };

    Screen.prototype.drawImage = function(image, x, y) {
      return this.ctx.drawImage(image, x * Screen.SCALE, y * Screen.SCALE);
    };

    Screen.prototype.drawAnim = function(anim, x, y, frame) {
      var coords, i, ix, iy, k, m, _i;
      coords = Icons[anim];
      ix = coords.x;
      iy = coords.y;
      k = Screen.UNIT * Screen.SCALE;
      m = this.icons[coords.block].width / k;
      for (i = _i = 0; 0 <= frame ? _i < frame : _i > frame; i = 0 <= frame ? ++_i : --_i) {
        ix++;
        if (ix === m) {
          ix = 0;
          iy++;
        }
      }
      return this.ctx.drawImage(this.icons[coords.block], k * ix, k * iy, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
    };

    Screen.prototype.drawCustomAnim = function(custom, x, y) {
      var k;
      k = Screen.UNIT * Screen.SCALE;
      return this.ctx.drawImage(custom, (x - 2) * Screen.SCALE, (y - 2) * Screen.SCALE);
    };

    Screen.prototype.drawText = function(text, color, x, y) {
      return Screen.FONT.drawText(this.ctx, text, color, x, y);
    };

    Screen.prototype.drawTextCentered = function(text, color, x, y, width, height) {
      return Screen.FONT.centerText(this.ctx, text, color, x, y, width, height);
    };

    Screen.prototype.wrapText = function(text, color, x, y, width) {
      return Screen.FONT.wrapText(this.ctx, text, color, x, y, width);
    };

    Screen.prototype.setAlpha = function(alpha) {
      return this.ctx.globalAlpha = alpha;
    };

    Screen.prototype.drawPixel = function(color, x, y) {
      this.ctx.fillStyle = color;
      return this.ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, Screen.SCALE, Screen.SCALE);
    };

    Screen.prototype.fillRect = function(color, x, y, width, height) {
      this.ctx.fillStyle = color;
      return this.ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, width * Screen.SCALE, height * Screen.SCALE);
    };

    return Screen;

  })();

  Button = (function() {

    Button.prototype.buttonOn = false;

    Button.prototype.text = null;

    function Button(index, x, y) {
      this.index = index;
      this.x = x;
      this.y = y;
      this.setText = __bind(this.setText, this);

      this.isEnabled = __bind(this.isEnabled, this);

      this.disable = __bind(this.disable, this);

      this.enable = __bind(this.enable, this);

      this.draw = __bind(this.draw, this);

      this.text = "BLAM";
    }

    Button.prototype.draw = function(ctx) {
      var image;
      image = this.buttonOn ? ButtonGrid.onImage : ButtonGrid.offImage;
      ctx.drawImage(image, Screen.SCALE * this.x, Screen.SCALE * this.y);
      if (this.buttonOn) {
        ButtonGrid.FONT.centerText(ctx, this.text, "transparent", this.x + 1, this.y, ButtonGrid.BUTTON_WIDTH, ButtonGrid.BUTTON_HEIGHT);
      }
      ctx.drawImage(ButtonGrid.topImage, Screen.SCALE * this.x, Screen.SCALE * this.y);
      return false;
    };

    Button.prototype.enable = function() {
      return this.buttonOn = true;
    };

    Button.prototype.disable = function() {
      return this.buttonOn = false;
    };

    Button.prototype.isEnabled = function() {
      return this.buttonOn;
    };

    Button.prototype.setText = function(text) {
      return this.text = text;
    };

    return Button;

  })();

  ButtonGrid = (function() {

    ButtonGrid.GURKOID_GLYPHS = {
      'A': {
        x: 1,
        y: 1,
        width: 5,
        height: 9
      },
      'B': {
        x: 6,
        y: 1,
        width: 5,
        height: 9
      },
      'C': {
        x: 11,
        y: 1,
        width: 5,
        height: 9
      },
      'D': {
        x: 16,
        y: 1,
        width: 5,
        height: 9
      },
      'E': {
        x: 21,
        y: 1,
        width: 4,
        height: 9
      },
      'F': {
        x: 25,
        y: 1,
        width: 4,
        height: 9
      },
      'G': {
        x: 29,
        y: 1,
        width: 5,
        height: 9
      },
      'H': {
        x: 34,
        y: 1,
        width: 5,
        height: 9
      },
      'I': {
        x: 39,
        y: 1,
        width: 4,
        height: 9
      },
      'J': {
        x: 43,
        y: 1,
        width: 4,
        height: 9
      },
      'K': {
        x: 47,
        y: 1,
        width: 5,
        height: 9
      },
      'L': {
        x: 52,
        y: 1,
        width: 5,
        height: 9
      },
      'M': {
        x: 57,
        y: 1,
        width: 6,
        height: 9
      },
      'N': {
        x: 63,
        y: 1,
        width: 6,
        height: 9
      },
      'O': {
        x: 69,
        y: 1,
        width: 5,
        height: 9
      },
      'P': {
        x: 74,
        y: 1,
        width: 5,
        height: 9
      },
      'Q': {
        x: 79,
        y: 1,
        width: 5,
        height: 9
      },
      'R': {
        x: 84,
        y: 1,
        width: 5,
        height: 9
      },
      'S': {
        x: 89,
        y: 1,
        width: 5,
        height: 9
      },
      'T': {
        x: 94,
        y: 1,
        width: 6,
        height: 9
      },
      'U': {
        x: 100,
        y: 1,
        width: 5,
        height: 9
      },
      'V': {
        x: 105,
        y: 1,
        width: 5,
        height: 9
      },
      'W': {
        x: 110,
        y: 1,
        width: 6,
        height: 9
      },
      'X': {
        x: 116,
        y: 1,
        width: 6,
        height: 9
      },
      'Y': {
        x: 122,
        y: 1,
        width: 6,
        height: 9
      },
      'Z': {
        x: 128,
        y: 1,
        width: 5,
        height: 9
      },
      '1': {
        x: 133,
        y: 1,
        width: 8,
        height: 9
      },
      '2': {
        x: 141,
        y: 1,
        width: 10,
        height: 9
      },
      '3': {
        x: 151,
        y: 1,
        width: 8,
        height: 9
      },
      '4': {
        x: 159,
        y: 1,
        width: 10,
        height: 9
      },
      '/': {
        x: 169,
        y: 1,
        width: 2,
        height: 9
      },
      '.': {
        x: 171,
        y: 1,
        width: 2,
        height: 9
      },
      ' ': {
        x: 173,
        y: 1,
        width: 4,
        height: 9
      }
    };

    ButtonGrid.BUTTON_WIDTH = 45;

    ButtonGrid.BUTTON_HEIGHT = 23;

    ButtonGrid.FONT = null;

    ButtonGrid.onImage = null;

    ButtonGrid.offImage = null;

    ButtonGrid.topImage = null;

    ButtonGrid.prototype.buttons = null;

    function ButtonGrid(ctx, gurk) {
      var index, x, xx, y, yy, _i, _j;
      this.ctx = ctx;
      this.gurk = gurk;
      this.disableButtonByPosition = __bind(this.disableButtonByPosition, this);

      this.setButtonByPosition = __bind(this.setButtonByPosition, this);

      this.setButton = __bind(this.setButton, this);

      this.enableMovement = __bind(this.enableMovement, this);

      this.clear = __bind(this.clear, this);

      this.forceClick = __bind(this.forceClick, this);

      this.getButtonByKeyNum = __bind(this.getButtonByKeyNum, this);

      this.clicked = __bind(this.clicked, this);

      this.draw = __bind(this.draw, this);

      ButtonGrid.FONT = new Font(ButtonGrid.GURKOID_GLYPHS, "font_gurkoid" + Screen.SCALE + ".png");
      ButtonGrid.onImage = Preloader.getImage("button" + Screen.SCALE + ".png");
      ButtonGrid.offImage = Preloader.getImage("buttonoff" + Screen.SCALE + ".png");
      ButtonGrid.topImage = Preloader.getImage("buttontop" + Screen.SCALE + ".png");
      index = 1;
      yy = GAP_Y;
      this.buttons = new Array(3);
      for (y = _i = 0; _i <= 2; y = ++_i) {
        this.buttons[y] = new Array(3);
        xx = GAP_X;
        for (x = _j = 0; _j <= 2; x = ++_j) {
          this.buttons[y][x] = new Button(index, xx, yy);
          index++;
          xx += ButtonGrid.BUTTON_WIDTH + GAP_X;
        }
        yy += GAP_Y + ButtonGrid.BUTTON_HEIGHT;
      }
      this.enableMovement();
      false;
    }

    ButtonGrid.prototype.draw = function() {
      var f,
        _this = this;
      f = function() {
        var x, y, _i, _results;
        _this.ctx.clearRect(0, 0, Screen.SCALE * GRID_WIDTH, Screen.SCALE * GRID_HEIGHT);
        _results = [];
        for (y = _i = 0; _i <= 2; y = ++_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (x = _j = 0; _j <= 2; x = ++_j) {
              _results1.push(this.buttons[y][x].draw(this.ctx));
            }
            return _results1;
          }).call(_this));
        }
        return _results;
      };
      f();
      if (drawHack) {
        setTimeout(f, 50);
      }
      return false;
    };

    ButtonGrid.prototype.clicked = function(e) {
      var button, x, y;
      x = Math.floor(e.x * 3 / Screen.SCALE / GRID_WIDTH);
      y = Math.floor(e.y * 3 / Screen.SCALE / GRID_HEIGHT);
      button = this.buttons[y][x];
      if (button.buttonOn) {
        return this.gurk.buttonPressed(this.buttons[y][x].text);
      }
    };

    ButtonGrid.prototype.getButtonByKeyNum = function(keyNum) {
      var x, y;
      keyNum--;
      y = Math.floor(keyNum / 3);
      x = keyNum % 3;
      return this.buttons[y][x];
    };

    ButtonGrid.prototype.forceClick = function(keyNum) {
      var button;
      button = this.getButtonByKeyNum(keyNum);
      if (button.buttonOn) {
        return this.gurk.buttonPressed(button.text);
      }
    };

    ButtonGrid.prototype.clear = function() {
      var x, y, _i, _j;
      for (y = _i = 0; _i <= 2; y = ++_i) {
        for (x = _j = 0; _j <= 2; x = ++_j) {
          this.buttons[y][x].disable();
        }
      }
      return this.draw();
    };

    ButtonGrid.prototype.enableMovement = function() {
      this.buttons[1][0].enable();
      this.buttons[1][0].setText("1");
      this.buttons[0][1].enable();
      this.buttons[0][1].setText("2");
      this.buttons[1][2].enable();
      this.buttons[1][2].setText("3");
      this.buttons[2][1].enable();
      this.buttons[2][1].setText("4");
      return this.draw();
    };

    ButtonGrid.prototype.setButton = function(keyNum, text) {
      var button;
      button = this.getButtonByKeyNum(keyNum);
      button.setText(text);
      button.enable();
      return this.draw();
    };

    ButtonGrid.prototype.setButtonByPosition = function(x, y, text) {
      var button;
      button = this.buttons[y][x];
      button.setText(text);
      button.enable();
      return this.draw();
    };

    ButtonGrid.prototype.disableButtonByPosition = function(x, y) {
      var button;
      button = this.buttons[y][x];
      button.disable();
      return this.draw();
    };

    return ButtonGrid;

  })();

  View = (function() {

    View.LEFT = "1";

    View.UP = "2";

    View.RIGHT = "3";

    View.DOWN = "4";

    View.prototype.buttons = null;

    View.prototype.name = "No Name";

    function View(screen, gurk) {
      var x, y, _i, _j;
      this.screen = screen;
      this.gurk = gurk;
      this.getTextWidth = __bind(this.getTextWidth, this);

      this.setButton = __bind(this.setButton, this);

      this.clearAllButtons = __bind(this.clearAllButtons, this);

      this.clearButton = __bind(this.clearButton, this);

      this.enableMovement = __bind(this.enableMovement, this);

      this.setButtons = __bind(this.setButtons, this);

      this.command = __bind(this.command, this);

      this.doLayout = __bind(this.doLayout, this);

      this.doDraw = __bind(this.doDraw, this);

      this.draw = __bind(this.draw, this);

      this.processResult = __bind(this.processResult, this);

      this.buttons = new Array(3);
      for (y = _i = 0; _i <= 2; y = ++_i) {
        this.buttons[y] = new Array(3);
        for (x = _j = 0; _j <= 2; x = ++_j) {
          this.buttons[y][x] = null;
        }
      }
      true;
    }

    View.prototype.processResult = function(result) {};

    View.prototype.draw = function() {
      var f,
        _this = this;
      f = function() {
        _this.screen.clear();
        _this.doDraw();
        return _this.screen.drawScreen();
      };
      f();
      if (drawHack) {
        return setTimeout(f, 50);
      }
    };

    View.prototype.doDraw = function() {};

    View.prototype.doLayout = function() {};

    View.prototype.command = function(text) {};

    View.prototype.setButtons = function(grid) {
      var x, y, _i, _results;
      grid.clear();
      _results = [];
      for (y = _i = 0; _i <= 2; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 2; x = ++_j) {
            if (this.buttons[y][x]) {
              _results1.push(grid.setButtonByPosition(x, y, this.buttons[y][x]));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    View.prototype.enableMovement = function() {
      this.buttons[1][0] = View.LEFT;
      this.buttons[0][1] = View.UP;
      this.buttons[1][2] = View.RIGHT;
      this.buttons[2][1] = View.DOWN;
      if (this.gurk.isCurrentView(this)) {
        return this.setButtons(this.gurk.buttonGrid);
      }
    };

    View.coords = function(keyNum) {
      var x, y;
      keyNum--;
      y = Math.floor(keyNum / 3);
      x = keyNum % 3;
      return [x, y];
    };

    View.prototype.clearButton = function(keyNum) {
      var x, y, _ref;
      _ref = View.coords(keyNum), x = _ref[0], y = _ref[1];
      this.buttons[y][x] = null;
      if (this.gurk.isCurrentView(this)) {
        return this.gurk.buttonGrid.disableButtonByPosition(x, y);
      }
    };

    View.prototype.clearAllButtons = function() {
      var i, _i;
      for (i = _i = 1; _i <= 9; i = ++_i) {
        this.clearButton(i);
      }
      return true;
    };

    View.prototype.setButton = function(keyNum, text) {
      var x, y, _ref;
      _ref = View.coords(keyNum), x = _ref[0], y = _ref[1];
      this.buttons[y][x] = text;
      if (this.gurk.isCurrentView(this)) {
        return this.gurk.buttonGrid.setButtonByPosition(x, y, text);
      }
    };

    View.prototype.getTextWidth = function(text) {
      return Screen.FONT.getWidth(text);
    };

    return View;

  }).call(this);

  InfoView = (function(_super) {

    __extends(InfoView, _super);

    InfoView.prototype.icons = null;

    InfoView.prototype.labels = null;

    InfoView.prototype.doneVerb = null;

    function InfoView(gurk, doneVerb) {
      if (doneVerb == null) {
        doneVerb = "DONE";
      }
      this.command = __bind(this.command, this);

      this.doDraw = __bind(this.doDraw, this);

      this.addLabelCentered = __bind(this.addLabelCentered, this);

      this.addLabel = __bind(this.addLabel, this);

      this.changeIcon = __bind(this.changeIcon, this);

      this.addIcon = __bind(this.addIcon, this);

      this.clear = __bind(this.clear, this);

      InfoView.__super__.constructor.call(this, gurk.getScreen(), gurk);
      this.icons = new Array();
      this.labels = new Array();
      this.doneVerb = doneVerb;
      this.setButton(5, this.doneVerb);
    }

    InfoView.prototype.clear = function() {
      this.icons = new Array();
      return this.labels = new Array();
    };

    InfoView.prototype.addIcon = function(icon, x, y) {
      this.icons.push({
        "icon": icon,
        "x": x,
        "y": y
      });
      return this.icons.length - 1;
    };

    InfoView.prototype.changeIcon = function(index, icon) {
      return this.icons[index].icon = icon;
    };

    InfoView.prototype.addLabel = function(text, color, x, y) {
      this.labels.push({
        "text": text,
        "color": color,
        "x": x,
        "y": y
      });
      return this.labels.length - 1;
    };

    InfoView.prototype.addLabelCentered = function(text, color, x, y, width, height) {
      var h, w, xx, yy;
      w = Screen.FONT.getWidth(text);
      h = Screen.FONT.fontHeight;
      xx = x + Math.floor((width - w) / 2);
      yy = y + Math.floor((height - h) / 2);
      return this.addLabel(text, color, xx, yy);
    };

    InfoView.prototype.doDraw = function() {
      var icon, label, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.screen.clearColor(Screen.GURK_BLUE);
      _ref = this.icons;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        icon = _ref[_i];
        this.screen.drawIcon(icon.icon, icon.x, icon.y);
      }
      _ref1 = this.labels;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        label = _ref1[_j];
        _results.push(this.screen.drawText(label.text, label.color, label.x, label.y));
      }
      return _results;
    };

    InfoView.prototype.command = function(text) {
      switch (text) {
        case this.doneVerb:
          return this.gurk.popView(null);
      }
    };

    return InfoView;

  })(View);

  SelectView = (function(_super) {

    __extends(SelectView, _super);

    SelectView.BASIC_COLOR = "#FFF";

    SelectView.SELECT_COLOR = "#0FF";

    SelectView.prototype.options = null;

    SelectView.prototype.selected = 0;

    SelectView.prototype.selectVerb = null;

    SelectView.prototype.cancelVerb = null;

    function SelectView(gurk, selectVerb, cancelVerb) {
      if (selectVerb == null) {
        selectVerb = "SELECT";
      }
      if (cancelVerb == null) {
        cancelVerb = "CANCEL";
      }
      this.doDraw = __bind(this.doDraw, this);

      this.command = __bind(this.command, this);

      this.makeSelection = __bind(this.makeSelection, this);

      this.moveDown = __bind(this.moveDown, this);

      this.moveUp = __bind(this.moveUp, this);

      this.changeOption = __bind(this.changeOption, this);

      this.addOption = __bind(this.addOption, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.cancelled = __bind(this.cancelled, this);

      this.turnOffSelection = __bind(this.turnOffSelection, this);

      this.setSelectVerb = __bind(this.setSelectVerb, this);

      this.start = __bind(this.start, this);

      this.clear = __bind(this.clear, this);

      SelectView.__super__.constructor.call(this, gurk);
      this.selectVerb = selectVerb;
      this.cancelVerb = cancelVerb;
      this.options = new Array();
      this.setButton(2, View.UP);
      this.setButton(8, View.DOWN);
      this.setButton(5, this.selectVerb);
      if (this.cancelVerb) {
        this.setButton(9, this.cancelVerb);
      } else {
        this.clearButton(9);
      }
    }

    SelectView.prototype.clear = function() {
      SelectView.__super__.clear.call(this);
      return this.options = new Array();
    };

    SelectView.prototype.start = function() {
      if (this.selected >= this.options.length) {
        this.selected = 0;
      }
      if (this.options.length > 0) {
        return this.itemHighlighted(this.selected, this.options[this.selected]);
      }
    };

    SelectView.prototype.setSelectVerb = function(verb) {
      this.selectVerb = verb;
      return this.setButton(5, this.selectVerb);
    };

    SelectView.prototype.turnOffSelection = function() {
      return this.clearButton(5);
    };

    SelectView.prototype.cancelled = function() {
      return this.gurk.popView(null);
    };

    SelectView.prototype.itemSelected = function(index, item) {
      return this.gurk.popView(item);
    };

    SelectView.prototype.itemHighlighted = function(index, item) {};

    SelectView.prototype.addOption = function(text, color, x, y, highlightColor) {
      if (highlightColor == null) {
        highlightColor = SelectView.SELECT_COLOR;
      }
      this.options.push({
        "text": text,
        "color": color,
        "highlightColor": highlightColor,
        "x": x,
        "y": y
      });
      return this.options.length - 1;
    };

    SelectView.prototype.changeOption = function(index, text, color) {
      var option;
      option = this.options[index];
      option.text = text;
      return option.color = color;
    };

    SelectView.prototype.moveUp = function() {
      if (this.options.length > 0) {
        this.selected--;
        if (this.selected < 0) {
          this.selected = this.options.length - 1;
        }
        this.itemHighlighted(this.selected, this.options[this.selected]);
        return this.draw();
      }
    };

    SelectView.prototype.moveDown = function() {
      if (this.options.length > 0) {
        this.selected++;
        if (this.selected >= this.options.length) {
          this.selected = 0;
        }
        this.itemHighlighted(this.selected, this.options[this.selected]);
        return this.draw();
      }
    };

    SelectView.prototype.makeSelection = function() {
      if (this.options.length > 0) {
        return this.itemSelected(this.selected, this.options[this.selected]);
      }
    };

    SelectView.prototype.command = function(text) {
      switch (text) {
        case View.UP:
          return this.moveUp();
        case View.DOWN:
          return this.moveDown();
        case this.selectVerb:
          return this.makeSelection();
        case this.cancelVerb:
          return this.cancelled();
      }
    };

    SelectView.prototype.doDraw = function() {
      var color, i, icon, label, option, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      SelectView.__super__.doDraw.call(this);
      this.screen.clearColor(Screen.GURK_BLUE);
      _ref = this.icons;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        icon = _ref[_i];
        this.screen.drawIcon(icon.icon, icon.x, icon.y);
      }
      _ref1 = this.labels;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        label = _ref1[_j];
        this.screen.drawText(label.text, label.color, label.x, label.y);
      }
      _ref2 = this.options;
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        option = _ref2[i];
        color = i === this.selected ? option.highlightColor : option.color;
        _results.push(this.screen.drawText(option.text, color, option.x, option.y));
      }
      return _results;
    };

    return SelectView;

  })(InfoView);

  AlertView = (function(_super) {

    __extends(AlertView, _super);

    AlertView.ICON_X = 3;

    AlertView.ICON_Y = 3;

    AlertView.TITLE_Y = 7;

    AlertView.prototype.subtitle = null;

    function AlertView(gurk, icon, title, text, result, altIcon) {
      this.icon = icon;
      this.title = title;
      this.text = text;
      this.result = result;
      this.altIcon = altIcon != null ? altIcon : null;
      this.command = __bind(this.command, this);

      this.doDraw = __bind(this.doDraw, this);

      AlertView.__super__.constructor.call(this, gurk.getScreen(), gurk);
      this.setButton(5, "OK");
    }

    AlertView.prototype.doDraw = function() {
      this.screen.clearColor(Screen.GURK_BLUE);
      this.screen.drawIcon(this.icon, AlertView.ICON_X, AlertView.ICON_Y);
      if (this.altIcon) {
        this.screen.drawIcon(this.altIcon, Screen.SIZE - Screen.UNIT - AlertView.ICON_X, AlertView.ICON_Y);
      }
      if (this.subtitle) {
        this.screen.drawTextCentered(this.title, "#FFF", 0, 1, Screen.SIZE, Screen.UNIT);
        this.screen.drawTextCentered(this.subtitle, "#A0A0A0", 0, 9, Screen.SIZE, Screen.UNIT);
      } else {
        this.screen.drawTextCentered(this.title, "#FFF", 0, AlertView.ICON_Y + 1, Screen.SIZE, Screen.UNIT);
      }
      return this.screen.wrapText(this.text, "#FFF", AlertView.ICON_X, AlertView.ICON_Y * 2 + Screen.UNIT, Screen.SIZE - 2 * AlertView.ICON_X);
    };

    AlertView.prototype.command = function(text) {
      switch (text) {
        case "OK":
          return this.gurk.popView(this.result);
      }
    };

    return AlertView;

  })(View);

  FlowView = (function(_super) {

    __extends(FlowView, _super);

    FlowView.ICON_X = 3;

    FlowView.ICON_Y = 3;

    FlowView.TITLE_Y = 7;

    FlowView.prototype.paragraphs = null;

    function FlowView(gurk, icon, title, result, altIcon) {
      if (altIcon == null) {
        altIcon = null;
      }
      this.doDraw = __bind(this.doDraw, this);

      this.addGap = __bind(this.addGap, this);

      this.addParagraph = __bind(this.addParagraph, this);

      FlowView.__super__.constructor.call(this, gurk, icon, title, "", result, altIcon);
      this.paragraphs = new Array();
    }

    FlowView.prototype.addParagraph = function(text, color) {
      return this.paragraphs.push({
        "text": text,
        "color": color
      });
    };

    FlowView.prototype.addGap = function() {
      return this.paragraphs.push({
        "text": null
      });
    };

    FlowView.prototype.doDraw = function() {
      var paragraph, x, y, _i, _len, _ref, _results;
      FlowView.__super__.doDraw.call(this);
      y = AlertView.ICON_Y * 2 + Screen.UNIT;
      x = AlertView.ICON_X;
      _ref = this.paragraphs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        paragraph = _ref[_i];
        if (!paragraph.text) {
          _results.push(y += 4);
        } else {
          _results.push(y += this.screen.wrapText(paragraph.text, paragraph.color, x, y, Screen.SIZE - 2 * x));
        }
      }
      return _results;
    };

    return FlowView;

  })(AlertView);

  ConfirmView = (function(_super) {

    __extends(ConfirmView, _super);

    function ConfirmView(gurk, icon, title, text, yesResult, noResult, altIcon) {
      this.yesResult = yesResult;
      this.noResult = noResult;
      if (altIcon == null) {
        altIcon = null;
      }
      this.command = __bind(this.command, this);

      ConfirmView.__super__.constructor.call(this, gurk, icon, title, text, noResult, altIcon);
      this.clearButton(5);
      this.setButton(1, "YES");
      this.setButton(3, "NO");
    }

    ConfirmView.prototype.command = function(text) {
      switch (text) {
        case "YES":
          return this.gurk.popView(this.yesResult);
        case "NO":
          return this.gurk.popView(this.noResult);
      }
    };

    return ConfirmView;

  })(AlertView);

  TileView = (function(_super) {

    __extends(TileView, _super);

    TileView.prototype.width = 0;

    TileView.prototype.height = 0;

    TileView.prototype.posX = 0;

    TileView.prototype.posY = 0;

    TileView.prototype.offsetX = 0;

    TileView.prototype.offsetY = 0;

    TileView.prototype.map = null;

    TileView.prototype.animation = null;

    TileView.prototype.interval = null;

    TileView.prototype.banner = null;

    TileView.prototype.centerBanner = false;

    TileView.prototype.topBanner = null;

    TileView.prototype.topBannerLeft = false;

    function TileView(gurk, mapName) {
      this.mapName = mapName;
      this.drawTopBanner = __bind(this.drawTopBanner, this);

      this.clearTopBanner = __bind(this.clearTopBanner, this);

      this.setTopBanner = __bind(this.setTopBanner, this);

      this.drawBanner = __bind(this.drawBanner, this);

      this.clearBanner = __bind(this.clearBanner, this);

      this.setBanner = __bind(this.setBanner, this);

      this.flyFrame = __bind(this.flyFrame, this);

      this.fly = __bind(this.fly, this);

      this.animateFrame = __bind(this.animateFrame, this);

      this.animate = __bind(this.animate, this);

      this.animateBlockFrame = __bind(this.animateBlockFrame, this);

      this.animateBlock = __bind(this.animateBlock, this);

      this.getTerrainIcon = __bind(this.getTerrainIcon, this);

      this.getTerrain = __bind(this.getTerrain, this);

      this.drawCustom = __bind(this.drawCustom, this);

      this.drawTile = __bind(this.drawTile, this);

      this.setMap = __bind(this.setMap, this);

      TileView.__super__.constructor.call(this, gurk.getScreen(), gurk);
      this.setMap(this.mapName, 0, 0);
      this.enableMovement();
      this.centerBanner = false;
    }

    TileView.prototype.setMap = function(mapName, x, y) {
      this.mapName = mapName;
      this.map = Data.maps[this.mapName];
      this.height = this.map.height;
      this.width = this.map.width;
      this.posX = x;
      return this.posY = y;
    };

    TileView.prototype.drawTile = function(icon, x, y) {
      return this.screen.drawIcon(icon, x * Screen.UNIT + this.offsetX, y * Screen.UNIT + this.offsetY);
    };

    TileView.prototype.drawCustom = function(image, x, y) {
      return this.screen.drawImage(image, x * Screen.UNIT + this.offsetX - 2, y * Screen.UNIT + this.offsetY - 2);
    };

    TileView.prototype.getTerrain = function(x, y) {
      var c, index;
      index = y * this.map.width + x;
      c = this.map.map.charAt(index);
      return Data.tiles[c];
    };

    TileView.prototype.getTerrainIcon = function(x, y) {
      return this.getTerrain(x, y).icon;
    };

    TileView.prototype.animateBlock = function(anim, x, y, radius, rate, callback) {
      var fn, step,
        _this = this;
      step = 0;
      fn = function() {
        return _this.animateBlockFrame(anim, x, y, radius, rate, step++, callback);
      };
      fn();
      return this.interval = setInterval(fn, rate);
    };

    TileView.prototype.animateBlockFrame = function(anim, x, y, radius, rate, frame, callback) {
      var frames, xx, yy, _i, _ref, _ref1, _results;
      frames = Icons[anim].frames;
      if (!frames) {
        frames = 1;
      }
      this.draw();
      if (frame === frames) {
        clearInterval(this.interval);
        return callback();
      } else {
        _results = [];
        for (yy = _i = _ref = y - radius, _ref1 = y + radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; yy = _ref <= _ref1 ? ++_i : --_i) {
          if (yy >= 0 && yy < this.height) {
            _results.push((function() {
              var _j, _ref2, _ref3, _results1;
              _results1 = [];
              for (xx = _j = _ref2 = x - radius, _ref3 = x + radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; xx = _ref2 <= _ref3 ? ++_j : --_j) {
                if (xx >= 0 && xx < this.width) {
                  _results1.push(this.screen.drawAnim(anim, xx * Screen.UNIT + this.offsetX, yy * Screen.UNIT + this.offsetY, frame));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    TileView.prototype.animate = function(anim, x, y, rate, callback) {
      var fn, step,
        _this = this;
      step = 0;
      fn = function() {
        return _this.animateFrame(anim, x * Screen.UNIT + _this.offsetX, y * Screen.UNIT + _this.offsetY, rate, step++, callback);
      };
      fn();
      return this.interval = setInterval(fn, rate);
    };

    TileView.prototype.animateFrame = function(anim, x, y, rate, frame, callback) {
      var frames;
      frames = Icons[anim].frames;
      if (!frames) {
        frames = 1;
      }
      this.draw();
      if (frame === frames) {
        clearInterval(this.interval);
        return callback();
      } else {
        return this.screen.drawAnim(anim, x, y, frame);
      }
    };

    TileView.prototype.fly = function(anim, x1, x2, y1, y2, rate, callback, custom) {
      var fn, n, step,
        _this = this;
      if (custom == null) {
        custom = null;
      }
      n = Math.floor(Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) * rate / 50) + 1;
      step = 0;
      fn = function() {
        return _this.flyFrame(anim, x1 * Screen.UNIT + _this.offsetX, x2 * Screen.UNIT + _this.offsetX, y1 * Screen.UNIT + _this.offsetY, y2 * Screen.UNIT + _this.offsetY, rate, step++, n, callback, custom);
      };
      fn();
      return this.interval = setInterval(fn, rate);
    };

    TileView.prototype.flyFrame = function(anim, x1, x2, y1, y2, rate, step, n, callback, custom) {
      var frame, frames, x, y;
      x = Math.floor(x1 + (x2 - x1) * step / n);
      y = Math.floor(y1 + (y2 - y1) * step / n);
      frames = Icons[anim].frames;
      if (!frames) {
        frames = 1;
      }
      frame = step % frames;
      this.draw();
      if (custom) {
        this.screen.drawCustomAnim(custom, x, y);
      } else {
        this.screen.drawAnim(anim, x, y, frame);
      }
      if (step > n) {
        clearInterval(this.interval);
        this.draw();
        return callback();
      }
    };

    TileView.prototype.setBanner = function(text) {
      this.banner = text;
      return this.draw();
    };

    TileView.prototype.clearBanner = function() {
      this.banner = null;
      return this.draw();
    };

    TileView.prototype.drawBanner = function() {
      var i, x, y, _i;
      if (this.banner) {
        x = -Screen.HALF_UNIT;
        y = 7 * Screen.UNIT;
        this.screen.drawIcon(Data.icons.bannerLeft, x, y);
        for (i = _i = 0; _i < 7; i = ++_i) {
          x += Screen.UNIT;
          this.screen.drawIcon(Data.icons.banner, x, y);
        }
        x += Screen.UNIT;
        this.screen.drawIcon(Data.icons.bannerRight, x, y);
        if (this.centerBanner) {
          return this.screen.drawTextCentered(this.banner, "#FFF", 0, y + 5, 128, 8);
        } else {
          return this.screen.drawText(this.banner, "#FFF", 4, y + 5);
        }
      }
    };

    TileView.prototype.setTopBanner = function(numMoves, numAttacks, half) {
      if (half == null) {
        half = false;
      }
      return this.topBanner = {
        "numMoves": numMoves,
        "numAttacks": numAttacks,
        "half": half
      };
    };

    TileView.prototype.clearTopBanner = function() {
      return this.topBanner = null;
    };

    TileView.prototype.drawTopBanner = function() {
      var attacks, i, leftX, x, y, _i;
      if (this.topBanner) {
        if (this.topBannerLeft) {
          leftX = -Screen.HALF_UNIT;
        } else {
          leftX = 5 * Screen.UNIT - Screen.HALF_UNIT;
        }
        y = 0;
        x = leftX;
        this.screen.drawIcon(Data.icons.bannerLeft, x, y);
        for (i = _i = 0; _i < 2; i = ++_i) {
          x += Screen.UNIT;
          this.screen.drawIcon(Data.icons.banner, x, y);
        }
        x += Screen.UNIT;
        this.screen.drawIcon(Data.icons.bannerRight, x, y);
        x = leftX + Screen.HALF_UNIT + 5;
        y = 5;
        this.screen.drawText("~", "#A0A0A0", x, y);
        x += 10;
        this.screen.drawText(":", "#A0A0A0", x, y);
        x += 3;
        this.screen.drawText("" + this.topBanner.numMoves, "#FFF", x, y);
        x = leftX + Screen.HALF_UNIT + 25;
        this.screen.drawText("`", "#A0A0A0", x, y);
        x += 6;
        this.screen.drawText(":", "#A0A0A0", x, y);
        x += 3;
        if (this.topBanner.half) {
          attacks = "" + (this.topBanner.numAttacks - 1) + "|";
        } else {
          attacks = "" + this.topBanner.numAttacks;
        }
        return this.screen.drawText("" + attacks, "#FFF", x, y);
      }
    };

    return TileView;

  })(View);

  ImageProcessor = (function() {

    ImageProcessor.UP = 0;

    ImageProcessor.RIGHT = 90;

    ImageProcessor.DOWN = 180;

    ImageProcessor.LEFT = 270;

    function ImageProcessor(canvas, ctx, icons) {
      this.canvas = canvas;
      this.ctx = ctx;
      this.icons = icons;
      this.rotate = __bind(this.rotate, this);

      this.process = __bind(this.process, this);

      this.halo = __bind(this.halo, this);

      this.shade = __bind(this.shade, this);

      this.glow = __bind(this.glow, this);

      this.paint = __bind(this.paint, this);

      this.clear = __bind(this.clear, this);

      this.drawRotated = __bind(this.drawRotated, this);

      this.drawIcon = __bind(this.drawIcon, this);

    }

    ImageProcessor.prototype.drawIcon = function(icon) {
      var coords, k, x, y;
      x = 2;
      y = 2;
      coords = Icons[icon];
      k = Screen.UNIT * Screen.SCALE;
      return this.ctx.drawImage(this.icons[coords.block], k * coords.x, k * coords.y, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
    };

    ImageProcessor.prototype.drawRotated = function(icon, degrees) {
      var t;
      this.ctx.save();
      t = (Screen.HALF_UNIT + 2) * Screen.SCALE;
      this.ctx.translate(t, t);
      this.ctx.rotate(degrees * Math.PI / 180);
      this.ctx.translate(-t, -t);
      this.drawIcon(icon);
      return this.ctx.restore();
    };

    ImageProcessor.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, (Screen.UNIT + 4) * Screen.SCALE, (Screen.UNIT + 4) * Screen.SCALE);
    };

    ImageProcessor.prototype.paint = function(colors) {
      var a, arcs, b, c, g, i, img, r, result, size, src, x, xx, y, yy, _i, _j, _ref, _ref1;
      arcs = ImageProcessor.computeArcs(colors, 12);
      size = (Screen.UNIT + 4) * Screen.SCALE;
      img = this.ctx.getImageData(0, 0, size, size).data;
      for (y = _i = 0, _ref = Screen.UNIT; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        yy = (y + 2) * Screen.SCALE;
        for (x = _j = 0, _ref1 = Screen.UNIT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          xx = (x + 2) * Screen.SCALE;
          i = (yy * size + xx) * 4;
          r = img[i];
          g = img[i + 1];
          b = img[i + 2];
          a = img[i + 3];
          if (a > 0 && (r > 0 || g > 0 || b > 0)) {
            c = ImageProcessor.blend(colors, arcs, Screen.HALF_UNIT - y, Screen.HALF_UNIT - x);
            if (c.red > 0) {
              r = Math.min(255, r + c.red);
            } else {
              r = Math.max(0, r + c.red);
            }
            if (c.green > 0) {
              g = Math.min(255, g + c.green);
            } else {
              g = Math.max(0, g + c.green);
            }
            if (c.blue > 0) {
              b = Math.min(255, b + c.blue);
            } else {
              b = Math.max(0, b + c.blue);
            }
            this.ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";
            this.ctx.fillRect(xx, yy, Screen.SCALE, Screen.SCALE);
          }
        }
      }
      src = this.canvas.toDataURL();
      result = new Image();
      result.src = src;
      return result;
    };

    ImageProcessor.blend = function(colors, arcs, x, y) {
      var a1, a2, angle, max, min, p1, p2, xx, yy, _i, _j, _len, _len1, _ref, _ref1;
      if (colors.length === 1) {
        return colors[0];
      }
      max = -2 * Math.PI;
      min = 2 * Math.PI;
      _ref = [y, y + 1];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        yy = _ref[_i];
        _ref1 = [x, x + 1];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          xx = _ref1[_j];
          angle = Math.atan2(yy, xx);
          if (angle > max) {
            max = angle;
          }
          if (angle < min) {
            min = angle;
          }
        }
      }
      if (min < 0) {
        min += 2 * Math.PI;
      }
      if (max < 0) {
        max += 2 * Math.PI;
      }
      a1 = Math.floor(min * arcs / Math.PI / 2);
      a2 = Math.floor(max * arcs / Math.PI / 2);
      if (a1 === a2) {
        return colors[a1 % colors.length];
      } else {
        p1 = a2 - min * arcs / Math.PI / 2;
        p2 = max * arcs / Math.PI / 2 - a2;
        return Util.blendColors(colors[a1 % colors.length], colors[a2 % colors.length], p1 / (p1 + p2), p2 / (p1 + p2));
      }
    };

    ImageProcessor.computeArcs = function(colors, target) {
      var k, n;
      n = colors.length;
      if (n === 1) {
        return 1;
      } else {
        k = Math.round(target / n);
        return k * n;
      }
    };

    ImageProcessor.prototype.glow = function(colors, intensity) {
      var a, arcs, c, cells, i, img, length, result, size, src, x, xx, y, yy, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3;
      arcs = ImageProcessor.computeArcs(colors, 30);
      length = Screen.UNIT + 4;
      cells = Util.create2DArray(length, length);
      size = length * Screen.SCALE;
      img = this.ctx.getImageData(0, 0, size, size).data;
      for (y = _i = 0, _ref = length - 2; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        yy = y * Screen.SCALE;
        for (x = _j = 0; 0 <= length ? _j < length : _j > length; x = 0 <= length ? ++_j : --_j) {
          xx = x * Screen.SCALE;
          i = (yy * size + xx) * 4;
          a = img[i + 3];
          if (a > 0) {
            cells[y][x] = 3;
          } else {
            cells[y][x] = 0;
          }
        }
      }
      for (y = _k = 0, _ref1 = length - 3; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; y = 0 <= _ref1 ? ++_k : --_k) {
        for (x = _l = 0; 0 <= length ? _l < length : _l > length; x = 0 <= length ? ++_l : --_l) {
          if (cells[y][x] === 0) {
            if (x > 0) {
              if (cells[y][x - 1] === 3) {
                cells[y][x] = 2;
              }
            }
            if (x + 1 < length) {
              if (cells[y][x + 1] === 3) {
                cells[y][x] = 2;
              }
            }
            if (y > 0) {
              if (cells[y - 1][x] === 3) {
                cells[y][x] = 2;
              }
            }
            if (y + 1 < length) {
              if (cells[y + 1][x] === 3) {
                cells[y][x] = 2;
              }
            }
          }
        }
      }
      for (y = _m = 0, _ref2 = length - 2; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; y = 0 <= _ref2 ? ++_m : --_m) {
        for (x = _n = 0; 0 <= length ? _n < length : _n > length; x = 0 <= length ? ++_n : --_n) {
          if (cells[y][x] === 0) {
            if (x > 0) {
              if (cells[y][x - 1] === 2) {
                cells[y][x] = 1;
              }
            }
            if (x + 1 < length) {
              if (cells[y][x + 1] === 2) {
                cells[y][x] = 1;
              }
            }
            if (y > 0) {
              if (cells[y - 1][x] === 2) {
                cells[y][x] = 1;
              }
            }
            if (y + 1 < length) {
              if (cells[y + 1][x] === 2) {
                cells[y][x] = 1;
              }
            }
          }
        }
      }
      for (y = _o = 0, _ref3 = length - 2; 0 <= _ref3 ? _o < _ref3 : _o > _ref3; y = 0 <= _ref3 ? ++_o : --_o) {
        yy = y * Screen.SCALE;
        for (x = _p = 0; 0 <= length ? _p < length : _p > length; x = 0 <= length ? ++_p : --_p) {
          if (cells[y][x] > 0 && cells[y][x] < 3) {
            xx = x * Screen.SCALE;
            i = (yy * size + xx) * 4;
            if (cells[y][x] === 1) {
              this.ctx.globalAlpha = intensity / 100 / 3;
            } else {
              this.ctx.globalAlpha = intensity / 100;
            }
            c = ImageProcessor.blend(colors, arcs, length / 2 - y, length / 2 - x);
            this.ctx.fillStyle = "rgba(" + c.red + "," + c.green + "," + c.blue + ",255)";
            this.ctx.fillRect(xx, yy, Screen.SCALE, Screen.SCALE);
          }
        }
      }
      this.ctx.globalAlpha = 1;
      src = this.canvas.toDataURL();
      result = new Image();
      result.src = src;
      return result;
    };

    ImageProcessor.prototype.shade = function(icon, colors) {
      this.clear();
      this.drawIcon(icon);
      return this.paint(colors);
    };

    ImageProcessor.prototype.halo = function(icon, colors, intensity) {
      this.clear();
      this.drawIcon(icon);
      return this.glow(colors, intensity);
    };

    ImageProcessor.prototype.process = function(icon, shadeColors, haloColors) {
      var result;
      this.clear();
      this.drawIcon(icon);
      result = null;
      if (shadeColors && shadeColors.length > 0) {
        result = this.paint(shadeColors);
      }
      if (haloColors && haloColors.length > 0) {
        result = this.glow(haloColors, 80);
      }
      return result;
    };

    ImageProcessor.prototype.rotate = function(icon, direction) {
      var result, src;
      this.clear();
      this.drawRotated(icon, direction);
      src = this.canvas.toDataURL();
      result = new Image();
      result.src = src;
      return result;
    };

    return ImageProcessor;

  })();

  Library = (function() {

    function Library() {}

    Library.getItemTemplateByName = function(name) {
      var item, _i, _len, _ref;
      _ref = Data.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.name === name) {
          return item;
        }
      }
      return null;
    };

    Library.getItemTemplates = function(level, groups) {
      var item, results, _i, _len, _ref;
      results = new Array();
      _ref = Data.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.level === level && (!groups || Util.hasCommonElements(groups, item.groups))) {
          results.push(item);
        }
      }
      return results;
    };

    Library.getCharacterByName = function(name) {
      var character, _i, _len, _ref;
      _ref = Data.characters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        if (character.name === name) {
          return character;
        }
      }
      return null;
    };

    Library.getCreatureByName = function(name) {
      var creature, _i, _len, _ref;
      _ref = Data.creatures;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        creature = _ref[_i];
        if (creature.name === name) {
          return creature;
        }
      }
      return null;
    };

    Library.getCreatures = function(level, groups) {
      var creature, results, _i, _len, _ref;
      results = new Array();
      _ref = Data.creatures;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        creature = _ref[_i];
        if (creature.level === level && (!groups || Util.hasCommonElements(groups, creature.groups))) {
          results.push(creature);
        }
      }
      return results;
    };

    Library.getLevelNear = function(level) {
      var a, i, x;
      x = Util.random(0, 9999);
      a = Data.levelTransformations[level - 1];
      i = 0;
      while (x > a[i]) {
        x -= a[i];
        i++;
      }
      return i + 1;
    };

    Library.getSpellsForCharacterAndLevel = function(character, level) {
      var job, results, spell, type, _i, _len, _ref;
      type = character.type;
      job = character.job;
      results = new Array();
      _ref = Data.spells;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spell = _ref[_i];
        if ((spell.who === type || spell.who === job) && spell.level <= level) {
          results.push(spell);
        }
      }
      return results;
    };

    Library.newSpellsForCharacterAndLevel = function(character, level) {
      var job, spell, type, _i, _len, _ref;
      type = character.type;
      job = character.job;
      _ref = Data.spells;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spell = _ref[_i];
        if ((spell.who === type || spell.who === job) && spell.level === level) {
          return true;
        }
      }
      return false;
    };

    Library.getSpellByName = function(name) {
      var spell, _i, _len, _ref;
      _ref = Data.spells;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spell = _ref[_i];
        if (spell.name === name) {
          return spell;
        }
      }
      return null;
    };

    return Library;

  }).call(this);

  Item = (function() {

    Item.TYPE_WEAPON = "weapon";

    Item.TYPE_SHIELD = "shield";

    Item.TYPE_HAT = "hat";

    Item.TYPE_ARMOR = "armor";

    Item.TYPE_BOOTS = "boots";

    Item.TYPE_AMULET = "amulet";

    Item.TYPE_USE = "use";

    Item.TYPES = [Item.TYPE_WEAPON, Item.TYPE_SHIELD, Item.TYPE_HAT, Item.TYPE_ARMOR, Item.TYPE_BOOTS, Item.TYPE_AMULET, Item.TYPE_USE];

    Item.prototype.name = null;

    function Item(template, id, bonus, charges) {
      this.template = template;
      this.id = id;
      this.bonus = bonus != null ? bonus : 0;
      this.charges = charges != null ? charges : 0;
      this.getSpellName = __bind(this.getSpellName, this);

      this.getShopValue = __bind(this.getShopValue, this);

      this.getValue = __bind(this.getValue, this);

      this.getConstitutionBonus = __bind(this.getConstitutionBonus, this);

      this.getAwarenessBonus = __bind(this.getAwarenessBonus, this);

      this.getAccuracyBonus = __bind(this.getAccuracyBonus, this);

      this.getStrengthBonus = __bind(this.getStrengthBonus, this);

      this.getExtraAttacks = __bind(this.getExtraAttacks, this);

      this.getExtraMoves = __bind(this.getExtraMoves, this);

      this.getResistance = __bind(this.getResistance, this);

      this.getArmorClass = __bind(this.getArmorClass, this);

      this.getToHitBonus = __bind(this.getToHitBonus, this);

      this.getRangeMaxDamage = __bind(this.getRangeMaxDamage, this);

      this.getRangeMinDamage = __bind(this.getRangeMinDamage, this);

      this.getMeleeMaxDamage = __bind(this.getMeleeMaxDamage, this);

      this.getMeleeMinDamage = __bind(this.getMeleeMinDamage, this);

      this.isAreaWeapon = __bind(this.isAreaWeapon, this);

      this.isRangeWeapon = __bind(this.isRangeWeapon, this);

      this.isMeleeWeapon = __bind(this.isMeleeWeapon, this);

      this.canUseOutsideOfCombat = __bind(this.canUseOutsideOfCombat, this);

      this.getSpellRange = __bind(this.getSpellRange, this);

      this.getSpell = __bind(this.getSpell, this);

      this.isFor = __bind(this.isFor, this);

      this.isEquipableBy = __bind(this.isEquipableBy, this);

      this.isUseable = __bind(this.isUseable, this);

      this.getCombatSpell = __bind(this.getCombatSpell, this);

      this.getHitSpell = __bind(this.getHitSpell, this);

      this.isWeapon = __bind(this.isWeapon, this);

      this.getType = __bind(this.getType, this);

      this.getColor = __bind(this.getColor, this);

      this.name = this.template.name;
      if (this.bonus > 0) {
        this.name += " +" + this.bonus;
      } else if (this.bonus < 0) {
        this.name += " -" + (-this.bonus);
      }
    }

    Item.prototype.getColor = function() {
      var _ref;
      return (_ref = this.template.legendary) != null ? _ref : "#FFF";
    };

    Item.prototype.getType = function() {
      return this.template.type;
    };

    Item.prototype.isWeapon = function() {
      return this.template.type === Item.TYPE_WEAPON;
    };

    Item.prototype.getHitSpell = function() {
      if (this.template.hitSpell) {
        return Library.getSpellByName(this.template.hitSpell);
      } else {
        return null;
      }
    };

    Item.prototype.getCombatSpell = function() {
      if (this.template.combatSpell) {
        return Library.getSpellByName(this.template.combatSpell);
      } else {
        return null;
      }
    };

    Item.prototype.isUseable = function() {
      return this.template.type === Item.TYPE_USE;
    };

    Item.prototype.isEquipableBy = function(characterType) {
      return !this.isUseable() && this.isFor(characterType);
    };

    Item.prototype.isFor = function(characterType) {
      return Util.hasElement(this.template.usedBy, characterType);
    };

    Item.prototype.getSpell = function() {
      if (this.template.spell) {
        return Library.getSpellByName(this.template.spell);
      } else if (this.template.combatSpell) {
        return Library.getSpellByName(this.template.combatSpell);
      } else {
        return null;
      }
    };

    Item.prototype.getSpellRange = function(spell) {
      if (spell == null) {
        spell = null;
      }
      if (!spell) {
        spell = this.getSpell();
      }
      if (!spell) {
        spell = this.getHitSpell();
      }
      return {
        "min": spell.minAmount + this.bonus * spell.modifyAmount,
        "max": spell.maxAmount + this.bonus * spell.modifyAmount
      };
    };

    Item.prototype.canUseOutsideOfCombat = function() {
      var spell;
      spell = this.getSpell();
      return this.isUseable() && spell.type === "heal" && (spell.healType === "restore" || spell.healType === "heal" || !spell.healType);
    };

    Item.prototype.isMeleeWeapon = function() {
      return this.isWeapon() && this.template.meleeMinDamage;
    };

    Item.prototype.isRangeWeapon = function() {
      return this.isWeapon() && this.template.rangeMinDamage;
    };

    Item.prototype.isAreaWeapon = function() {
      return this.isWeapon() && this.template.target === "area";
    };

    Item.prototype.getMeleeMinDamage = function() {
      return this.template.meleeMinDamage + this.bonus;
    };

    Item.prototype.getMeleeMaxDamage = function() {
      return this.template.meleeMaxDamage + this.bonus;
    };

    Item.prototype.getRangeMinDamage = function() {
      return this.template.rangeMinDamage + this.bonus;
    };

    Item.prototype.getRangeMaxDamage = function() {
      return this.template.rangeMaxDamage + this.bonus;
    };

    Item.prototype.getToHitBonus = function() {
      if (this.isWeapon()) {
        if (this.template.toHitBonus) {
          return this.template.toHitBonus + this.bonus;
        } else {
          return this.bonus;
        }
      } else {
        return 0;
      }
    };

    Item.prototype.getArmorClass = function() {
      if (this.template.armorClass) {
        return this.template.armorClass + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getResistance = function() {
      if (this.template.resistance) {
        return this.template.resistance + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getExtraMoves = function() {
      var _ref;
      return (_ref = this.template.extraMoves) != null ? _ref : 0;
    };

    Item.prototype.getExtraAttacks = function() {
      var _ref;
      return (_ref = this.template.extraAttacks) != null ? _ref : 0;
    };

    Item.prototype.getStrengthBonus = function() {
      if (this.template.strengthBonus) {
        return this.template.strengthBonus + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getAccuracyBonus = function() {
      if (this.template.accuracyBonus) {
        return this.template.accuracyBonus + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getAwarenessBonus = function() {
      if (this.template.awarenessBonus) {
        return this.template.awarenessBonus + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getConstitutionBonus = function() {
      if (this.template.constitutionBonus) {
        return this.template.constitutionBonus + this.bonus;
      } else {
        return 0;
      }
    };

    Item.prototype.getValue = function() {
      var i, value, _i, _j, _ref, _ref1;
      value = this.template.baseValue;
      if (this.isUseable()) {
        value *= this.charges;
        value = Math.round(value + (value * this.bonus / 2));
      } else {
        if (this.bonus > 0) {
          for (i = _i = 0, _ref = this.bonus; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            value = value * 1.8;
          }
        } else if (this.bonus < 0) {
          for (i = _j = _ref1 = this.bonus; _ref1 <= 0 ? _j < 0 : _j > 0; i = _ref1 <= 0 ? ++_j : --_j) {
            value = value / 1.5;
          }
          value = Math.max(1, value);
        }
      }
      return Math.round(value);
    };

    Item.prototype.getShopValue = function(modPerCent) {
      var value;
      value = Math.floor(this.getValue() * modPerCent / 100);
      if (value < 1) {
        value = 1;
      }
      return value;
    };

    Item.prototype.getSpellName = function() {
      return this.template.spell;
    };

    return Item;

  })();

  Creature = (function() {

    Creature.prototype.hitPoints = 0;

    Creature.prototype.maxHitPoints = 0;

    Creature.prototype.spellPoints = 0;

    Creature.prototype.maxSpellPoints = 0;

    function Creature(template, bonus) {
      this.template = template;
      this.bonus = bonus != null ? bonus : 0;
      this.getSpells = __bind(this.getSpells, this);

      this.getName = __bind(this.getName, this);

      this.getSpellRange = __bind(this.getSpellRange, this);

      this.getRangeDamageBounds = __bind(this.getRangeDamageBounds, this);

      this.getMeleeDamageBounds = __bind(this.getMeleeDamageBounds, this);

      this.getArmorClass = __bind(this.getArmorClass, this);

      this.getPotency = __bind(this.getPotency, this);

      this.getResistance = __bind(this.getResistance, this);

      this.getToHitBonus = __bind(this.getToHitBonus, this);

      this.getHitSpell = __bind(this.getHitSpell, this);

      this.canAttackMelee = __bind(this.canAttackMelee, this);

      this.canAttackArea = __bind(this.canAttackArea, this);

      this.canAttackRange = __bind(this.canAttackRange, this);

      this.maxHitPoints = Util.random(this.template.minHitPoints, this.template.maxHitPoints) + this.bonus;
      if (this.maxHitPoints < 1) {
        this.maxHitPoints = 1;
      }
      this.hitPoints = this.maxHitPoints;
      if (this.template.minSpellPoints) {
        this.maxSpellPoints = Util.random(this.template.minSpellPoints, this.template.maxSpellPoints) + this.bonus;
        this.spellPoints = this.maxSpellPoints;
      }
      this.good = false;
    }

    Creature.prototype.canAttackRange = function() {
      if (this.template.rangeMinDamage) {
        return true;
      } else {
        return false;
      }
    };

    Creature.prototype.canAttackArea = function() {
      if (this.template.target === "area") {
        return true;
      } else {
        return false;
      }
    };

    Creature.prototype.canAttackMelee = function() {
      if (this.template.meleeMinDamage) {
        return true;
      } else {
        return false;
      }
    };

    Creature.prototype.getHitSpell = function() {
      if (this.template.hitSpell) {
        return Library.getSpellByName(this.template.hitSpell);
      } else {
        return null;
      }
    };

    Creature.prototype.getToHitBonus = function() {
      var _ref;
      return ((_ref = this.template.hitModifier) != null ? _ref : 0) + this.bonus;
    };

    Creature.prototype.getResistance = function() {
      var _ref;
      return ((_ref = this.template.resistance) != null ? _ref : 0) + this.bonus;
    };

    Creature.prototype.getPotency = function() {
      var _ref;
      return ((_ref = this.template.potency) != null ? _ref : 0) + Math.floor(this.template.level / 2) + this.bonus;
    };

    Creature.prototype.getArmorClass = function() {
      var _ref;
      return ((_ref = this.template.armorClass) != null ? _ref : 0) + this.bonus;
    };

    Creature.prototype.getMeleeDamageBounds = function() {
      var max, min;
      min = Math.max(this.template.meleeMinDamage + this.bonus, 1);
      max = Math.max(this.template.meleeMaxDamage + this.bonus, 1);
      return {
        "min": min,
        "max": max
      };
    };

    Creature.prototype.getRangeDamageBounds = function() {
      var max, min;
      min = Math.max(this.template.rangeMinDamage + this.bonus, 1);
      max = Math.max(this.template.rangeMaxDamage + this.bonus, 1);
      return {
        "min": min,
        "max": max
      };
    };

    Creature.prototype.getSpellRange = function(spell) {
      var max, min;
      min = spell.minAmount + this.bonus;
      max = spell.maxAmount + this.bonus;
      if (min < 1) {
        min = 1;
      }
      if (max < 1) {
        max = 1;
      }
      return {
        "min": min,
        "max": max
      };
    };

    Creature.prototype.getName = function() {
      return this.template.name;
    };

    Creature.prototype.getSpells = function() {
      var list, results, spell, _i, _len;
      list = this.template.spells;
      results = [];
      if (list) {
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          spell = list[_i];
          results.push(Library.getSpellByName(spell.name));
        }
      }
      return results;
    };

    return Creature;

  })();

  Player = (function() {

    Player.TYPE_WARRIOR = "warrior";

    Player.TYPE_ARCHER = "archer";

    Player.TYPE_MAGE = "mage";

    Player.ATTRIBUTES = ["Strength", "Accuracy", "Awareness", "Toughness"];

    Player.MAX_ITEMS = 15;

    Player.prototype.strength = 0;

    Player.prototype.accuracy = 0;

    Player.prototype.awareness = 0;

    Player.prototype.constitution = 0;

    Player.prototype.hitPoints = 0;

    Player.prototype.maxHitPoints = 0;

    Player.prototype.spellPoints = 0;

    Player.prototype.maxSpellPoints = 0;

    Player.prototype.experience = 0;

    Player.prototype.level = 0;

    Player.prototype.items = null;

    Player.prototype.equipment = null;

    Player.prototype.fromData = function(data) {
      var id, item, k, obj, _i, _len, _ref, _ref1, _results;
      Util.copyProperties(data, this);
      this.items = new Array();
      this.equipment = {};
      this.equipment[Item.TYPE_WEAPON] = null;
      this.equipment[Item.TYPE_SHIELD] = null;
      this.equipment[Item.TYPE_HAT] = null;
      this.equipment[Item.TYPE_ARMOR] = null;
      this.equipment[Item.TYPE_BOOTS] = null;
      this.equipment[Item.TYPE_AMULET] = null;
      _ref = data.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        item = new Item(Library.getItemTemplateByName(obj.template), obj.id, obj.bonus, obj.charges);
        this.items.push(item);
      }
      _ref1 = data.equipment;
      _results = [];
      for (k in _ref1) {
        id = _ref1[k];
        if (id) {
          _results.push(this.equipment[k] = this.getItemById(id));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    function Player(character) {
      var attributes, best;
      this.character = character;
      this.getSpells = __bind(this.getSpells, this);

      this.hasSpells = __bind(this.hasSpells, this);

      this.getSpellRange = __bind(this.getSpellRange, this);

      this.getRangeDamageBounds = __bind(this.getRangeDamageBounds, this);

      this.getMeleeDamageBounds = __bind(this.getMeleeDamageBounds, this);

      this.canAttackMelee = __bind(this.canAttackMelee, this);

      this.canAttackArea = __bind(this.canAttackArea, this);

      this.canAttackRange = __bind(this.canAttackRange, this);

      this.getConstitution = __bind(this.getConstitution, this);

      this.getAwareness = __bind(this.getAwareness, this);

      this.getAccuracy = __bind(this.getAccuracy, this);

      this.getStrength = __bind(this.getStrength, this);

      this.getToHitBonus = __bind(this.getToHitBonus, this);

      this.getPotency = __bind(this.getPotency, this);

      this.getResistance = __bind(this.getResistance, this);

      this.getArmorClass = __bind(this.getArmorClass, this);

      this.getExtraAttacks = __bind(this.getExtraAttacks, this);

      this.getExtraMoves = __bind(this.getExtraMoves, this);

      this.heal = __bind(this.heal, this);

      this.healCompletely = __bind(this.healCompletely, this);

      this.isHealed = __bind(this.isHealed, this);

      this.isRestored = __bind(this.isRestored, this);

      this.takeDamage = __bind(this.takeDamage, this);

      this.isAlive = __bind(this.isAlive, this);

      this.computeNextLevelSpellPoints = __bind(this.computeNextLevelSpellPoints, this);

      this.computeNextLevelHitPoints = __bind(this.computeNextLevelHitPoints, this);

      this.getAttributeBonus = __bind(this.getAttributeBonus, this);

      this.getHitSpell = __bind(this.getHitSpell, this);

      this.getWeapon = __bind(this.getWeapon, this);

      this.getEquippedItemByType = __bind(this.getEquippedItemByType, this);

      this.getEquipableItemsByType = __bind(this.getEquipableItemsByType, this);

      this.hasUsableItem = __bind(this.hasUsableItem, this);

      this.canEmploy = __bind(this.canEmploy, this);

      this.hasItem = __bind(this.hasItem, this);

      this.dropItem = __bind(this.dropItem, this);

      this.unequipItemByType = __bind(this.unequipItemByType, this);

      this.unequipItem = __bind(this.unequipItem, this);

      this.isItemEquipped = __bind(this.isItemEquipped, this);

      this.equipItem = __bind(this.equipItem, this);

      this.getItemById = __bind(this.getItemById, this);

      this.addItem = __bind(this.addItem, this);

      this.numberOfItems = __bind(this.numberOfItems, this);

      this.canCarryMoreItems = __bind(this.canCarryMoreItems, this);

      this.getName = __bind(this.getName, this);

      this.level = 1;
      this.experience = 0;
      attributes = [Util.statRoll(), Util.statRoll(), Util.statRoll(), Util.statRoll()];
      attributes.sort(function(a, b) {
        return a - b;
      });
      best = attributes[3];
      attributes.pop();
      Util.shuffle(attributes);
      if (this.character.bestAttribute === "strength") {
        this.strength = best;
        this.accuracy = attributes[0];
        this.awareness = attributes[1];
        this.constitution = attributes[2];
      } else if (this.character.bestAttribute === "accuracy") {
        this.accuracy = best;
        this.strength = attributes[0];
        this.awareness = attributes[1];
        this.constitution = attributes[2];
      } else if (this.character.bestAttribute === "awareness") {
        this.awareness = best;
        this.accuracy = attributes[0];
        this.strength = attributes[1];
        this.constitution = attributes[2];
      } else if (this.character.bestAttribute === "constitution") {
        this.constitution = best;
        this.accuracy = attributes[0];
        this.awareness = attributes[1];
        this.strength = attributes[2];
      }
      if (this.character.strength) {
        this.strength += this.character.strength;
      }
      if (this.character.accuracy) {
        this.accuracy += this.character.accuracy;
      }
      if (this.character.awareness) {
        this.awareness += this.character.awareness;
      }
      if (this.character.constitution) {
        this.constitution += this.character.constitution;
      }
      if (this.strength < 1) {
        this.strength = 1;
      }
      if (this.accuracy < 1) {
        this.accuracy = 1;
      }
      if (this.awareness < 1) {
        this.awareness = 1;
      }
      if (this.constitution < 1) {
        this.constitution = 1;
      }
      this.maxHitPoints = Math.max(4, this.computeNextLevelHitPoints()) + this.character.hitPoints;
      if (Library.getSpellsForCharacterAndLevel(this.character, 1).length > 0) {
        this.maxSpellPoints = Math.max(2, this.computeNextLevelSpellPoints());
      } else {
        this.maxSpellPoints = 0;
      }
      this.healCompletely();
      this.items = new Array();
      this.equipment = {};
      this.equipment[Item.TYPE_WEAPON] = null;
      this.equipment[Item.TYPE_SHIELD] = null;
      this.equipment[Item.TYPE_HAT] = null;
      this.equipment[Item.TYPE_ARMOR] = null;
      this.equipment[Item.TYPE_BOOTS] = null;
      this.equipment[Item.TYPE_AMULET] = null;
    }

    Player.prototype.getName = function() {
      return this.character.name;
    };

    Player.prototype.canCarryMoreItems = function() {
      return this.items.length < Player.MAX_ITEMS;
    };

    Player.prototype.numberOfItems = function() {
      return this.items.length;
    };

    Player.prototype.addItem = function(item) {
      if (this.canCarryMoreItems()) {
        return this.items.push(item);
      }
    };

    Player.prototype.getItemById = function(id) {
      var item, _i, _len, _ref;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.id === id) {
          return item;
        }
      }
      return null;
    };

    Player.prototype.equipItem = function(item) {
      var type;
      type = item.template.type;
      if (type !== Item.TYPE_USE) {
        return this.equipment[type] = item;
      }
    };

    Player.prototype.isItemEquipped = function(item) {
      var type;
      type = item.template.type;
      return this.equipment[type] && this.equipment[type].id === item.id;
    };

    Player.prototype.unequipItem = function(item) {
      var type;
      if (this.isItemEquipped(item)) {
        type = item.template.type;
        this.equipment[type] = null;
        return true;
      } else {
        return false;
      }
    };

    Player.prototype.unequipItemByType = function(type) {
      var item;
      item = this.equipment[type];
      if (item) {
        return this.unequipItem(item);
      }
    };

    Player.prototype.dropItem = function(item) {
      var i, _i, _ref;
      this.unequipItem(item);
      for (i = _i = 0, _ref = this.items.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.items[i].id === item.id) {
          this.items.splice(i, 1);
          return true;
        }
      }
      return false;
    };

    Player.prototype.hasItem = function(name) {
      var item, _i, _len, _ref;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.template.name === name) {
          return true;
        }
      }
      return false;
    };

    Player.prototype.canEmploy = function(item) {
      return item.isFor(this.character.type);
    };

    Player.prototype.hasUsableItem = function(inCombat, melee, summon, combatant) {
      var item, spell, _i, _len, _ref;
      if (melee == null) {
        melee = false;
      }
      if (summon == null) {
        summon = false;
      }
      if (combatant == null) {
        combatant = null;
      }
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.isUseable() && this.canEmploy(item) || combatant && inCombat && item.getCombatSpell() && !combatant.isCombatSpellUsed(item)) {
          spell = item.getSpell();
          if (spell) {
            if (inCombat) {
              if (spell.type === "summon" && summon) {
                return true;
              }
              if (spell.target !== "touch" || melee || spell.type === "heal") {
                return true;
              }
            } else if (spell.type === "heal" && spell.healType !== "remove") {
              return true;
            }
          }
        }
      }
      return false;
    };

    Player.prototype.getEquipableItemsByType = function(type) {
      var item, result, _i, _len, _ref;
      result = new Array();
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.template.type === type && item.isEquipableBy(this.character.type)) {
          result.push(item);
        }
      }
      return result;
    };

    Player.prototype.getEquippedItemByType = function(type) {
      return this.equipment[type];
    };

    Player.prototype.getWeapon = function() {
      return this.getEquippedItemByType(Item.TYPE_WEAPON);
    };

    Player.prototype.getHitSpell = function() {
      var weapon;
      weapon = this.getWeapon();
      if (weapon) {
        return weapon.getHitSpell();
      } else {
        return null;
      }
    };

    Player.prototype.getAttributeBonus = function(value) {
      return Util.trunc((value - 1) / 2.4 - 4);
    };

    Player.prototype.computeNextLevelHitPoints = function() {
      return Util.random(1, 8) + this.getAttributeBonus(this.getConstitution());
    };

    Player.prototype.computeNextLevelSpellPoints = function() {
      return Util.random(1, 5) + this.getAttributeBonus(this.getAwareness());
    };

    Player.prototype.isAlive = function() {
      return this.hitPoints > 0;
    };

    Player.prototype.takeDamage = function(amount) {
      this.hitPoints -= amount;
      if (this.hitPoints < 0) {
        this.hitPoints = 0;
      }
      return this.hitPoints;
    };

    Player.prototype.isRestored = function() {
      return this.spellPoints === this.maxSpellPoints;
    };

    Player.prototype.isHealed = function() {
      return this.hitPoints === this.maxHitPoints;
    };

    Player.prototype.healCompletely = function() {
      this.hitPoints = this.maxHitPoints;
      return this.spellPoints = this.maxSpellPoints;
    };

    Player.prototype.heal = function() {
      if (this.hitPoints > 0) {
        this.hitPoints = Math.min(this.maxHitPoints, this.hitPoints + 1);
        return this.spellPoints = Math.min(this.maxSpellPoints, this.spellPoints + 1);
      }
    };

    Player.prototype.getExtraMoves = function() {
      var item, k, moves, _ref;
      moves = 0;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          moves += item.getExtraMoves();
        }
      }
      return moves;
    };

    Player.prototype.getExtraAttacks = function() {
      var attacks, item, k, _ref;
      attacks = 0;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          attacks += item.getExtraAttacks();
        }
      }
      return attacks;
    };

    Player.prototype.getArmorClass = function() {
      var ac, item, k, _ref;
      ac = this.getAttributeBonus(this.getAwareness());
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          ac += item.getArmorClass();
        }
      }
      return ac;
    };

    Player.prototype.getResistance = function() {
      var item, k, r, _ref;
      r = this.getAttributeBonus(this.getConstitution());
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          r += item.getResistance();
        }
      }
      return r;
    };

    Player.prototype.getPotency = function() {
      return Math.floor(this.level / 2);
    };

    Player.prototype.getToHitBonus = function() {
      var toHit, weapon;
      toHit = this.getAttributeBonus(this.getAccuracy());
      weapon = this.equipment[Item.TYPE_WEAPON];
      if (weapon) {
        toHit += weapon.getToHitBonus();
      }
      return toHit;
    };

    Player.prototype.getStrength = function() {
      var item, k, strength, _ref;
      strength = this.strength;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          strength += item.getStrengthBonus();
        }
      }
      return strength;
    };

    Player.prototype.getAccuracy = function() {
      var accuracy, item, k, _ref;
      accuracy = this.accuracy;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          accuracy += item.getAccuracyBonus();
        }
      }
      return accuracy;
    };

    Player.prototype.getAwareness = function() {
      var awareness, item, k, _ref;
      awareness = this.awareness;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          awareness += item.getAwarenessBonus();
        }
      }
      return awareness;
    };

    Player.prototype.getConstitution = function() {
      var constitution, item, k, _ref;
      constitution = this.constitution;
      _ref = this.equipment;
      for (k in _ref) {
        item = _ref[k];
        if (item) {
          constitution += item.getConstitutionBonus();
        }
      }
      return constitution;
    };

    Player.prototype.canAttackRange = function() {
      var weapon;
      weapon = this.equipment[Item.TYPE_WEAPON];
      return weapon && weapon.isRangeWeapon();
    };

    Player.prototype.canAttackArea = function() {
      var weapon;
      weapon = this.equipment[Item.TYPE_WEAPON];
      return weapon && weapon.isAreaWeapon();
    };

    Player.prototype.canAttackMelee = function() {
      var weapon;
      weapon = this.equipment[Item.TYPE_WEAPON];
      return weapon && weapon.isMeleeWeapon();
    };

    Player.prototype.getMeleeDamageBounds = function() {
      var bonus, max, min, weapon;
      weapon = this.equipment[Item.TYPE_WEAPON];
      if (!weapon) {
        min = 1;
        max = 1;
      } else if (weapon.isMeleeWeapon()) {
        min = weapon.getMeleeMinDamage();
        max = weapon.getMeleeMaxDamage();
      } else {
        min = weapon.getRangeMinDamage();
        max = weapon.getRangeMaxDamage();
      }
      bonus = this.getAttributeBonus(this.getStrength());
      min = Math.max(min + bonus, 1);
      max = Math.max(max + bonus, 1);
      return {
        min: min,
        max: max
      };
    };

    Player.prototype.getRangeDamageBounds = function() {
      var bonus, max, min, weapon;
      weapon = this.equipment[Item.TYPE_WEAPON];
      bonus = this.getAttributeBonus(this.getStrength());
      if (weapon.isRangeWeapon()) {
        min = weapon.getRangeMinDamage() + bonus;
        max = weapon.getRangeMaxDamage() + bonus;
        min = Math.max(min, 1);
        max = Math.max(max, 1);
        return {
          min: min,
          max: max
        };
      } else {
        return {
          min: 0,
          max: 0
        };
      }
    };

    Player.prototype.getSpellRange = function(spell) {
      var bonus, levelDiff, max, min;
      bonus = this.getAttributeBonus(this.getAwareness());
      levelDiff = this.level - spell.level;
      if (levelDiff < 0) {
        levelDiff = 0;
      }
      bonus += Math.round(spell.modifyAmount * levelDiff / 100);
      min = spell.minAmount + bonus;
      max = spell.maxAmount + bonus;
      if (min < 1) {
        min = 1;
      }
      if (max < 1) {
        max = 1;
      }
      return {
        "min": min,
        "max": max
      };
    };

    Player.prototype.hasSpells = function() {
      return this.getSpells().length > 0;
    };

    Player.prototype.getSpells = function() {
      return Library.getSpellsForCharacterAndLevel(this.character, this.level);
    };

    return Player;

  })();

  Game = (function() {

    Game.MAX_ENCOUNTER_CREATURES = 18;

    Game.NUM_SHOP_ITEMS = 15;

    Game.prototype.players = null;

    Game.prototype.bag = null;

    Game.prototype.gold = 0;

    Game.prototype.map = null;

    Game.prototype.x = 0;

    Game.prototype.y = 0;

    Game.prototype.itemId = 0;

    Game.prototype.moveNum = 0;

    Game.prototype.visited = null;

    Game.prototype.features = null;

    Game.prototype.ships = null;

    Game.prototype.markers = null;

    Game.prototype.shops = null;

    Game.prototype.aboard = null;

    function Game() {
      this.createEncounter = __bind(this.createEncounter, this);

      this.checkForRandomEncounter = __bind(this.checkForRandomEncounter, this);

      this.getTerrainInfo = __bind(this.getTerrainInfo, this);

      this.getTile = __bind(this.getTile, this);

      this.getAveragePlayerLevel = __bind(this.getAveragePlayerLevel, this);

      this.giveExperience = __bind(this.giveExperience, this);

      this.getEncounter = __bind(this.getEncounter, this);

      this.regenerateParty = __bind(this.regenerateParty, this);

      this.healParty = __bind(this.healParty, this);

      this.playersNeedHealing = __bind(this.playersNeedHealing, this);

      this.getRandomItem = __bind(this.getRandomItem, this);

      this.getRandomTemplate = __bind(this.getRandomTemplate, this);

      this.createItem = __bind(this.createItem, this);

      this.doesItemExist = __bind(this.doesItemExist, this);

      this.transitionTo = __bind(this.transitionTo, this);

      this.moveTo = __bind(this.moveTo, this);

      this.wasVisited = __bind(this.wasVisited, this);

      this.markVisited = __bind(this.markVisited, this);

      this.getVisitedArray = __bind(this.getVisitedArray, this);

      this.addPlayer = __bind(this.addPlayer, this);

      this.getFeature = __bind(this.getFeature, this);

      this.getFeatures = __bind(this.getFeatures, this);

      this.getCombatMap = __bind(this.getCombatMap, this);

      this.disembark = __bind(this.disembark, this);

      this.moveShip = __bind(this.moveShip, this);

      this.boardShip = __bind(this.boardShip, this);

      this.isChartered = __bind(this.isChartered, this);

      this.getShopItems = __bind(this.getShopItems, this);

      this.populateShopItems = __bind(this.populateShopItems, this);

      this.buildFeatures = __bind(this.buildFeatures, this);

      this.hasAnyMarkers = __bind(this.hasAnyMarkers, this);

      this.hasAllMarkers = __bind(this.hasAllMarkers, this);

      this.hasMarker = __bind(this.hasMarker, this);

      this.setMarkers = __bind(this.setMarkers, this);

      this.getStart = __bind(this.getStart, this);

      this.death = __bind(this.death, this);

      this.createBag = __bind(this.createBag, this);

      this.loadGame = __bind(this.loadGame, this);

      this.saveGame = __bind(this.saveGame, this);
      this.players = new Array();
      this.map = Data.start[0].map;
      this.x = Data.start[0].x;
      this.y = Data.start[0].y;
      this.gold = Data.start[0].gold;
      this.ships = {};
      this.markers = {};
      this.shops = {};
      this.visited = {};
      this.moveNum = 0;
      this.buildFeatures();
    }

    Game.prototype.saveGame = function() {
      var copy, item, k, player, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      copy = JSON.parse(JSON.stringify(this));
      delete copy.features;
      _ref = copy.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        _ref1 = player.items;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          item = _ref1[_j];
          item.template = item.template.name;
        }
        _ref2 = player.equipment;
        for (k in _ref2) {
          item = _ref2[k];
          if (item) {
            player.equipment[k] = item.id;
          }
        }
      }
      if (copy.bag) {
        _ref3 = copy.bag.items;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          item = _ref3[_k];
          item.template = item.template.name;
        }
      }
      return copy;
    };

    Game.prototype.loadGame = function(json) {
      var obj, player, saved, _i, _len, _ref;
      saved = JSON.parse(json);
      this.players = [];
      _ref = saved.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        player = new Player(obj.character);
        player.fromData(obj);
        this.players.push(player);
      }
      this.map = saved.map;
      this.x = saved.x;
      this.y = saved.y;
      this.gold = saved.gold;
      this.ships = saved.ships;
      this.markers = saved.markers;
      this.visited = saved.visited;
      this.moveNum = saved.moveNum;
      this.itemId = saved.itemId;
      if (saved.bag) {
        this.bag = new Player(saved.bag.character);
        this.bag.fromData(saved.bag);
      }
      this.buildFeatures();
      return true;
    };

    Game.prototype.createBag = function() {
      if (!this.bag) {
        return this.bag = new Player(Library.getCharacterByName("Bag of Holding"));
      }
    };

    Game.prototype.death = function() {
      var player, _i, _len, _ref;
      this.ships = {};
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        player.healCompletely();
      }
      this.gold = 0;
      return this.buildFeatures();
    };

    Game.prototype.getStart = function() {
      var best, start, _i, _len, _ref;
      best = Data.start[0];
      _ref = Data.start;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        start = _ref[_i];
        if (start.after && this.hasMarker(start.after)) {
          best = start;
        }
      }
      return best;
    };

    Game.getKey = function(x, y) {
      return "" + x + "_" + y;
    };

    Game.prototype.setMarkers = function(listOrSingle) {
      var a, newMarkers, _i, _len;
      if (listOrSingle === "bagOfHolding" && !this.bag) {
        this.createBag();
      }
      if (listOrSingle === "gameOver") {
        Device.setSetting("won", true);
      }
      newMarkers = false;
      if (listOrSingle) {
        if (listOrSingle instanceof Array) {
          for (_i = 0, _len = listOrSingle.length; _i < _len; _i++) {
            a = listOrSingle[_i];
            if (!this.markers[a]) {
              this.markers[a] = true;
              newMarkers = true;
            }
          }
        } else {
          if (!this.markers[listOrSingle]) {
            this.markers[listOrSingle] = true;
            newMarkers = true;
          }
        }
      }
      if (newMarkers) {
        this.buildFeatures();
      }
      return newMarkers;
    };

    Game.prototype.hasMarker = function(marker) {
      return !!this.markers[marker];
    };

    Game.prototype.hasAllMarkers = function(listOrSingle) {
      var a, _i, _len;
      if (listOrSingle) {
        if (listOrSingle instanceof Array) {
          for (_i = 0, _len = listOrSingle.length; _i < _len; _i++) {
            a = listOrSingle[_i];
            if (!this.markers[a]) {
              return false;
            }
          }
        } else {
          if (!this.markers[listOrSingle]) {
            return false;
          }
        }
      }
      return true;
    };

    Game.prototype.hasAnyMarkers = function(listOrSingle) {
      var a, _i, _len;
      if (listOrSingle) {
        if (listOrSingle instanceof Array) {
          for (_i = 0, _len = listOrSingle.length; _i < _len; _i++) {
            a = listOrSingle[_i];
            if (this.markers[a]) {
              return true;
            }
          }
        } else {
          if (this.markers[listOrSingle]) {
            return true;
          }
        }
      }
      return false;
    };

    Game.prototype.buildFeatures = function() {
      var feature, key, list, object, x, y, _i, _len, _ref, _results;
      list = Data.maps[this.map].features;
      this.features = {};
      this.shops = {};
      if (list) {
        _results = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          feature = list[_i];
          if (this.hasAllMarkers(feature.after) && !this.hasAnyMarkers(feature.until) && !this.hasAnyMarkers(feature.id)) {
            x = feature.x;
            y = feature.y;
            if (feature.type === "ship" && this.ships[feature.id]) {
              _ref = this.ships[feature.id], x = _ref.x, y = _ref.y;
            }
            key = Game.getKey(x, y);
            object = this.features[key];
            if (!object) {
              object = {};
              this.features[key] = object;
            }
            object[feature.type] = feature;
            if (feature.type === "shop") {
              _results.push(this.populateShopItems(key, feature));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Game.prototype.populateShopItems = function(key, shop) {
      var i, item, items, _i, _ref, _results;
      items = [];
      this.shops[key] = items;
      _results = [];
      for (i = _i = 0, _ref = Game.NUM_SHOP_ITEMS; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        item = this.getRandomItem(shop.level, shop.groups);
        if (item) {
          _results.push(items.push(item));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.getShopItems = function(x, y) {
      var key;
      key = Game.getKey(x, y);
      return this.shops[key];
    };

    Game.prototype.isChartered = function(shipID) {
      if (this.ships[shipID]) {
        return true;
      } else {
        return false;
      }
    };

    Game.prototype.boardShip = function(shipID) {
      this.aboard = shipID;
      return this.moveShip(this.x, this.y);
    };

    Game.prototype.moveShip = function(x, y) {
      var feature, key, object, oldKey, oldPos, pos;
      oldPos = this.ships[this.aboard];
      if (oldPos) {
        oldKey = Game.getKey(oldPos.x, oldPos.y);
        object = this.features[oldKey];
        if (object) {
          feature = object["ship"];
          if (object) {
            delete object["ship"];
            if (Util.isEmpty(object)) {
              delete this.features[oldKey];
            }
          }
        }
      } else {
        feature = this.getFeature(x, y, "ship");
      }
      key = Game.getKey(x, y);
      pos = {
        "x": x,
        "y": y
      };
      this.ships[this.aboard] = pos;
      object = this.features[key];
      if (!object) {
        object = {};
      }
      this.features[key] = object;
      return object["ship"] = feature;
    };

    Game.prototype.disembark = function() {
      return this.aboard = null;
    };

    Game.prototype.getCombatMap = function() {
      return this.getTerrainInfo().combatMap;
    };

    Game.prototype.getFeatures = function(x, y) {
      var key;
      key = Game.getKey(x, y);
      return this.features[key];
    };

    Game.prototype.getFeature = function(x, y, type) {
      var key, object;
      key = Game.getKey(x, y);
      object = this.features[key];
      if (!object) {
        return null;
      } else {
        return object[type];
      }
    };

    Game.prototype.addPlayer = function(player) {
      return this.players.push(player);
    };

    Game.prototype.getVisitedArray = function() {
      var array, x, y, _i, _j, _ref, _ref1;
      array = this.visited[this.map];
      if (!array) {
        array = Util.create2DArray(Data.maps[this.map].width, Data.maps[this.map].height);
        for (y = _i = 0, _ref = Data.maps[this.map].height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
          for (x = _j = 0, _ref1 = Data.maps[this.map].width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            array[y][x] = 0;
          }
        }
        this.visited[this.map] = array;
      }
      return array;
    };

    Game.prototype.markVisited = function(x, y) {
      var array;
      array = this.getVisitedArray();
      return array[y][x] = 1;
    };

    Game.prototype.wasVisited = function(x, y) {
      var array;
      array = this.getVisitedArray();
      return array[y][x] === 1;
    };

    Game.prototype.moveTo = function(x, y) {
      this.x = x;
      this.y = y;
      if (this.aboard) {
        return this.moveShip(x, y);
      }
    };

    Game.prototype.transitionTo = function(map, x, y) {
      this.map = map;
      this.buildFeatures();
      this.x = x;
      return this.y = y;
    };

    Game.prototype.doesItemExist = function(name) {
      var item, k, player, shop, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.hasItem(name)) {
          return true;
        }
      }
      if (this.bag && this.bag.hasItem(name)) {
        return true;
      }
      _ref1 = this.shops;
      for (k in _ref1) {
        shop = _ref1[k];
        for (_j = 0, _len1 = shop.length; _j < _len1; _j++) {
          item = shop[_j];
          if (item.template.name === name) {
            return true;
          }
        }
      }
      return false;
    };

    Game.prototype.createItem = function(template, bonus, charges) {
      if (bonus == null) {
        bonus = 0;
      }
      if (charges == null) {
        charges = 0;
      }
      this.itemId++;
      return new Item(template, this.itemId, bonus, charges);
    };

    Game.prototype.getRandomTemplate = function(templates) {
      var rarity, sum, template, value, _i, _j, _len, _len1, _ref, _ref1;
      sum = 0;
      for (_i = 0, _len = templates.length; _i < _len; _i++) {
        template = templates[_i];
        sum += (_ref = template.rarity) != null ? _ref : 1000;
      }
      value = Util.random(0, sum - 1);
      for (_j = 0, _len1 = templates.length; _j < _len1; _j++) {
        template = templates[_j];
        rarity = (_ref1 = template.rarity) != null ? _ref1 : 1000;
        if (rarity > value) {
          return template;
        } else {
          value -= rarity;
        }
      }
      return null;
    };

    Game.prototype.getRandomItem = function(mapLevel, groups) {
      var attempts, bonus, chance, charges, i, level, levelDiffFactor, modChance, realLevel, template, templates, _i;
      level = Library.getLevelNear(mapLevel);
      templates = Library.getItemTemplates(level, groups);
      realLevel = level;
      while (templates === null && realLevel > 1) {
        realLevel--;
        templates = Library.getItemTemplates(realLevel, groups);
      }
      level = realLevel;
      if (templates && templates.length > 0) {
        attempts = 0;
        template = null;
        while (template === null && attempts < 5) {
          attempts++;
          template = this.getRandomTemplate(templates);
          if (template.legendary) {
            if (this.doesItemExist(template.name)) {
              template = null;
            }
          }
        }
        if (template === null) {
          return null;
        } else {
          bonus = 0;
          if (!template.legendary) {
            modChance = 1;
            levelDiffFactor = mapLevel - level + 2;
            if (levelDiffFactor > 0) {
              for (i = _i = 0; 0 <= levelDiffFactor ? _i < levelDiffFactor : _i > levelDiffFactor; i = 0 <= levelDiffFactor ? ++_i : --_i) {
                modChance *= 2;
              }
            }
            if (modChance > 75) {
              modChance = 75;
            }
            chance = Util.random(0, 99);
            while (chance < modChance && bonus < 6) {
              bonus++;
              chance = Util.random(0, 99);
            }
          }
          if (template.chargesMin) {
            charges = Util.random(template.chargesMin, template.chargesMax);
          } else {
            charges = 0;
          }
          return this.createItem(template, bonus, charges);
        }
      } else {
        return null;
      }
    };

    Game.prototype.playersNeedHealing = function() {
      var player, _i, _len, _ref;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.hitPoints < player.maxHitPoints) {
          return true;
        }
      }
      return false;
    };

    Game.prototype.healParty = function() {
      var player, _i, _len, _ref, _results;
      _ref = this.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        _results.push(player.healCompletely());
      }
      return _results;
    };

    Game.prototype.regenerateParty = function() {
      var player, _i, _len, _ref, _results;
      _ref = this.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.isAlive()) {
          if (player.hitPoints < player.maxHitPoints) {
            player.hitPoints++;
          }
          if (player.spellPoints < player.maxSpellPoints) {
            _results.push(player.spellPoints++);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.getCreatureQuantity = function(creatureLevel, mapLevel, limit) {
      var amount, diff;
      if (limit == null) {
        limit = false;
      }
      diff = creatureLevel - mapLevel;
      if (diff < -3) {
        diff = -3;
      } else if (diff > 3) {
        diff = 3;
      }
      switch (diff) {
        case -3:
          amount = Util.random(3, 9);
          break;
        case -2:
          amount = Util.random(2, 5);
          break;
        case -1:
          amount = Util.random(1, 4);
          break;
        case 0:
          amount = Util.random(1, 3);
          break;
        default:
          amount = 1;
      }
      if (limit) {
        amount = Math.round(amount / 2);
        if (amount < 1) {
          amount = 1;
        }
        if (amount > 2) {
          amount = 2;
        }
      }
      return amount;
    };

    Game.prototype.getEncounter = function(feature) {
      var ambushed, bonus, charges, creature, creatures, gold, hpBonus, item, items, template, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      creatures = [];
      _ref = feature.creatures;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        creature = _ref[_i];
        template = Library.getCreatureByName(creature.name);
        bonus = (_ref1 = creature.bonus) != null ? _ref1 : 0;
        hpBonus = (_ref2 = creature.hitPoints) != null ? _ref2 : 0;
        creature = new Creature(template, bonus);
        creature.maxHitPoints += hpBonus;
        creature.hitPoints += hpBonus;
        creatures.push(creature);
      }
      items = [];
      _ref3 = feature.items;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        item = _ref3[_j];
        template = Library.getItemTemplateByName(item.name);
        bonus = (_ref4 = item.bonus) != null ? _ref4 : 0;
        if (template.chargesMin) {
          charges = Util.random(template.chargesMin, template.chargesMax);
        } else {
          charges = 0;
        }
        items.push(this.createItem(template, bonus, charges));
      }
      gold = (_ref5 = feature.gold) != null ? _ref5 : 0;
      if (feature.ambushed) {
        ambushed = true;
      } else {
        ambushed = false;
      }
      return {
        "creatures": creatures,
        "items": items,
        "gold": gold,
        "ambushed": ambushed
      };
    };

    Game.prototype.giveExperience = function(creatures) {
      var attr, attrBonuses, awarenessBonus, constitutionBonus, creature, hitPointBonus, i, newSpells, player, spellPointBonus, totalPlayers, totalXP, upgrades, xp, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1;
      totalXP = 0;
      for (_i = 0, _len = creatures.length; _i < _len; _i++) {
        creature = creatures[_i];
        totalXP += creature.template.experienceValue;
      }
      totalPlayers = 0;
      _ref = this.players;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        player = _ref[_j];
        if (player.isAlive()) {
          totalPlayers++;
        }
      }
      xp = Math.ceil(totalXP / totalPlayers);
      upgrades = [];
      _ref1 = this.players;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        player = _ref1[_k];
        if (player.isAlive()) {
          player.experience += xp;
          if (player.experience >= Data.levels[player.level]) {
            player.level++;
            attrBonuses = [0, 0, 0, 0];
            for (i = _l = 0; _l < 2; i = ++_l) {
              attr = Util.random(0, 3);
              attrBonuses[attr]++;
              switch (attr) {
                case 0:
                  player.strength++;
                  break;
                case 1:
                  player.accuracy++;
                  break;
                case 2:
                  player.awareness++;
                  break;
                case 3:
                  player.constitution++;
              }
            }
            constitutionBonus = player.getAttributeBonus(player.getConstitution());
            awarenessBonus = player.getAttributeBonus(player.getAwareness());
            hitPointBonus = Util.random(2, 8) + constitutionBonus;
            if (hitPointBonus < 1) {
              hitPointBonus = 1;
            }
            if (player.hasSpells()) {
              spellPointBonus = Util.random(1, 5) + awarenessBonus;
              if (spellPointBonus < 1) {
                spellPointBonus = 1;
              }
              if (player.maxSpellPoints === 0) {
                player.spellPoints = 0;
              }
            } else {
              spellPointBonus = 0;
            }
            player.maxHitPoints += hitPointBonus;
            player.hitPoints += hitPointBonus;
            player.maxSpellPoints += spellPointBonus;
            player.spellPoints += spellPointBonus;
            newSpells = Library.newSpellsForCharacterAndLevel(player.character, player.level);
            upgrades.push({
              "player": player,
              "attrBonuses": attrBonuses,
              "hitPointBonus": hitPointBonus,
              "spellPointBonus": spellPointBonus,
              "newSpells": newSpells
            });
          }
        }
      }
      return upgrades;
    };

    Game.prototype.getAveragePlayerLevel = function() {
      var player, total, _i, _len, _ref;
      total = 0;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.isAlive()) {
          total += player.level;
        }
      }
      return total / 3;
    };

    Game.prototype.getTile = function(x, y) {
      var index, override;
      override = this.getFeature(x, y, "override");
      if (override) {
        return override.tile;
      } else {
        index = y * Data.maps[this.map].width + x;
        return Data.maps[this.map].map.charAt(index);
      }
    };

    Game.prototype.getTerrainInfo = function() {
      var map, terrain, tile, _ref;
      tile = this.getTile(this.x, this.y);
      terrain = (_ref = Data.maps[this.map].terrain) != null ? _ref[tile] : void 0;
      if (terrain) {
        return terrain;
      } else {
        map = Data.maps[this.map];
        return {
          level: map.level,
          encounterChance: map.encounterChance,
          combatMap: map.combatMap,
          groups: map.groups
        };
      }
    };

    Game.prototype.checkForRandomEncounter = function() {
      var chance, dungeonLevel, encounterChance, terrain;
      terrain = this.getTerrainInfo();
      encounterChance = terrain.encounterChance;
      if (encounterChance) {
        dungeonLevel = terrain.level;
        chance = encounterChance;
        if (dungeonLevel < 10) {
          chance = chance / Math.max(1, this.getAveragePlayerLevel() - dungeonLevel - 1.5);
        }
        if (Util.randomChance(chance, 1000)) {
          return true;
        }
      }
      return false;
    };

    Game.prototype.createEncounter = function() {
      var ambushed, candidates, creature, creatures, full, gold, groups, i, item, items, j, k, level, mapLevel, max, maxGold, n, other, template, terrain, treasureLevel, unique, _i, _j, _k, _l, _len, _len1, _m, _ref;
      terrain = this.getTerrainInfo();
      mapLevel = terrain.level;
      groups = terrain.groups;
      creatures = [];
      k = Util.random(1, 3);
      full = false;
      for (i = _i = 0; 0 <= k ? _i < k : _i > k; i = 0 <= k ? ++_i : --_i) {
        if (!full) {
          level = Library.getLevelNear(mapLevel);
          candidates = Library.getCreatures(level, groups);
          while (candidates.length === 0 && level > 0) {
            level--;
            candidates = Library.getCreatures(level, groups);
          }
          if (candidates.length > 0) {
            template = Util.randomElement(candidates);
            n = Game.getCreatureQuantity(template.level, mapLevel, template.limit);
            if (template.summons) {
              n = Math.min(n, 2);
            }
            for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
              creatures.push(new Creature(template, 0));
              if (creatures.length === Game.MAX_ENCOUNTER_CREATURES) {
                full = true;
                break;
              }
            }
          }
        }
      }
      items = [];
      gold = 0;
      for (_k = 0, _len = creatures.length; _k < _len; _k++) {
        creature = creatures[_k];
        maxGold = 2;
        for (i = _l = 0, _ref = creature.template.level - 1; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
          if (i > 9) {
            maxGold = maxGold * 1.1;
          } else if (i > 2) {
            maxGold = maxGold * 1.4;
          } else {
            maxGold = maxGold * 1.8;
          }
        }
        max = Math.round(maxGold);
        gold += Util.random(0, max);
        treasureLevel = creature.template.level;
        if (treasureLevel > 10) {
          treasureLevel = 10;
        }
        if (Util.randomChance(Data.treasureChance[treasureLevel - 1], 1000)) {
          item = this.getRandomItem(creature.template.level, groups);
          if (item) {
            if (item.template.legendary) {
              unique = true;
              for (_m = 0, _len1 = items.length; _m < _len1; _m++) {
                other = items[_m];
                if (other.template.name === item.template.name) {
                  unique = false;
                  break;
                }
              }
              if (!unique) {
                item = null;
              }
            }
          }
          if (item) {
            items.push(item);
          }
          if (items.length === 5) {
            break;
          }
        }
      }
      ambushed = Util.randomChance(25, 100);
      return {
        "creatures": creatures,
        "items": items,
        "gold": gold,
        "ambushed": ambushed
      };
    };

    return Game;

  }).call(this);

  Map = (function(_super) {

    __extends(Map, _super);

    function Map(gurk, mapName) {
      this.mapName = mapName;
      this.move = __bind(this.move, this);

      this.doDraw = __bind(this.doDraw, this);

      this.animDone = __bind(this.animDone, this);

      this.command = __bind(this.command, this);

      Map.__super__.constructor.call(this, gurk, this.mapName);
      this.setButton(1, "NEW");
      this.setButton(3, "HIT");
      this.setButton(7, "WOW");
      this.setButton(9, "SHOOT");
      this.setBanner("Sir Rugnar (HP: 8)");
    }

    Map.prototype.command = function(text) {
      var abc, view, y;
      switch (text) {
        case View.LEFT:
          return this.move(-1, 0);
        case View.UP:
          return this.move(0, -1);
        case View.RIGHT:
          return this.move(1, 0);
        case View.DOWN:
          return this.move(0, 1);
        case "NEW":
          return this.gurk.showConfirm(Data.icons.party, "New Game", "Erase your old saved game and make a new one? You won't be able to recover your old game!", {}, {});
        case "HIT":
          return this.animate(Data.icons.animation, 4, 4, 200, this.animDone);
        case "WOW":
          view = new SelectView(this.gurk, "SELECT");
          view.addIcon(Data.icons.party, 3, 3);
          view.addLabel("Blammo!", "#FFF", 22, 12);
          y = 3 + 19;
          view.addIcon("grass.png", 3, y);
          view.addOption("Grass", "#880", 22, y + 9);
          y += 19;
          view.addIcon("tree.png", 3, y);
          view.addOption("Forest", "#080", 22, y + 9);
          y += 19;
          view.addIcon("water.png", 3, y);
          view.addOption("Water", "#44F", 22, y + 9);
          return this.gurk.pushView(view);
        case "SHOOT":
          return abc = 0;
      }
    };

    Map.prototype.animDone = function() {};

    Map.prototype.doDraw = function() {
      var tile, x, xx, y, yy, _i, _j, _ref, _ref1;
      for (y = _i = 0, _ref = Screen.WIN_SIZE; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        yy = y + this.posY - Screen.CENTER_OFFSET;
        if (yy >= 0 && yy < this.height) {
          for (x = _j = 0, _ref1 = Screen.WIN_SIZE; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            xx = x + this.posX - Screen.CENTER_OFFSET;
            if (xx >= 0 && xx < this.width) {
              tile = this.getTerrainIcon(xx, yy);
              this.drawTile(tile, x, y);
            }
          }
        }
      }
      this.drawTile(Data.icons.party, Screen.CENTER_OFFSET, Screen.CENTER_OFFSET);
      return this.drawBanner();
    };

    Map.prototype.move = function(x, y) {
      this.posX += x;
      this.posY += y;
      if (this.posX < 0) {
        this.posX = 0;
      } else if (this.posX >= this.width) {
        this.posX = this.width - 1;
      }
      if (this.posY < 0) {
        this.posY = 0;
      } else if (this.posY >= this.height) {
        this.posY = this.height - 1;
      }
      return this.draw();
    };

    return Map;

  })(TileView);

  ChooseCharacterView = (function(_super) {

    __extends(ChooseCharacterView, _super);

    ChooseCharacterView.prototype.characters = null;

    ChooseCharacterView.prototype.fiddles = 0;

    function ChooseCharacterView(gurk, type, game) {
      this.type = type;
      this.game = game;
      this.processResult = __bind(this.processResult, this);

      this.command = __bind(this.command, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.doLayout = __bind(this.doLayout, this);

      ChooseCharacterView.__super__.constructor.call(this, gurk, "CHOOSE", "DONE");
    }

    ChooseCharacterView.prototype.doLayout = function() {
      var character, def, y, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.characters = [];
      _ref = Data.characters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        if (character.type === this.type) {
          if (!character.after || Device.getSetting(character.after, false)) {
            this.characters.push(character);
          }
        }
      }
      this.clearButton(7);
      this.clearButton(9);
      this.setButton(1, "INFO");
      this.clear();
      y = 3;
      def = "a";
      if (this.type === "archer") {
        def = "an";
      }
      this.addLabelCentered("Choose " + def + " " + (Util.capitalize(this.type)), "#FFF", 0, y, 128, Screen.FONT.fontHeight);
      y += 8;
      this.addLabelCentered("(Press INFO to learn more)", "#A0A0A0", 0, y, 128, Screen.FONT.fontHeight);
      y += 12;
      _ref1 = this.characters;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        character = _ref1[_j];
        this.addIcon(character.icon, 2, y);
        this.addOption(character.name, "#FFF", 20, y);
        y += 8;
        this.addLabel("Level 1 " + character.job, "#A0A0A0", 20, y);
        _results.push(y += 20);
      }
      return _results;
    };

    ChooseCharacterView.prototype.itemSelected = function(index, item) {
      return this.gurk.pushView(new CharacterRollView(this.gurk, this.game, this.characters[this.selected]));
    };

    ChooseCharacterView.prototype.itemHighlighted = function(index, item) {
      if (index === 0) {
        this.fiddles++;
        if (this.fiddles > 10) {
          Device.setSetting("won", true);
          this.doLayout();
          return this.fiddles = 0;
        }
      }
    };

    ChooseCharacterView.prototype.command = function(text) {
      if (text === "INFO") {
        return this.gurk.pushView(new CharacterInfoView(this.gurk, this.characters[this.selected]));
      } else {
        return ChooseCharacterView.__super__.command.call(this, text);
      }
    };

    ChooseCharacterView.prototype.processResult = function(result) {
      if (result === "NEXT") {
        return this.gurk.popView(result);
      }
    };

    return ChooseCharacterView;

  })(SelectView);

  CharacterInfoView = (function(_super) {

    __extends(CharacterInfoView, _super);

    CharacterInfoView.ATTRIBUTES = ["strength", "accuracy", "awareness", "constitution"];

    CharacterInfoView.prototype.blurbY = 0;

    function CharacterInfoView(gurk, character) {
      var y;
      this.character = character;
      this.doDraw = __bind(this.doDraw, this);

      this.doAttributes = __bind(this.doAttributes, this);

      CharacterInfoView.__super__.constructor.call(this, gurk, "BACK");
      this.addIcon(this.character.icon, 3, 3);
      y = 4;
      this.addLabel("" + this.character.name, "#FFF", 20, y);
      y += 8;
      this.addLabel("Level 1 " + this.character.job, "#A0A0A0", 20, y);
      y += 12;
      this.blurbY = this.doAttributes(y) + 4;
    }

    CharacterInfoView.prototype.doAttributes = function(y) {
      var attribute, name, value, _i, _len, _ref;
      _ref = CharacterInfoView.ATTRIBUTES;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attribute = _ref[_i];
        if (this.character[attribute]) {
          value = this.character[attribute];
          if (value > 0) {
            value = "+" + value;
          }
          name = Util.capitalize(attribute);
          if (name === "Constitution") {
            name = "Toughness";
          }
          this.addLabel("" + name + ": " + value, "#FFF", 3, y);
          y += 8;
        }
      }
      return y;
    };

    CharacterInfoView.prototype.doDraw = function() {
      CharacterInfoView.__super__.doDraw.call(this);
      return this.screen.wrapText(this.character.description, "#A0A0A0", 3, this.blurbY, 122);
    };

    return CharacterInfoView;

  })(InfoView);

  CharacterRollView = (function(_super) {

    __extends(CharacterRollView, _super);

    CharacterRollView.prototype.player = null;

    function CharacterRollView(gurk, game, character) {
      this.game = game;
      this.character = character;
      this.command = __bind(this.command, this);

      this.roll = __bind(this.roll, this);

      CharacterRollView.__super__.constructor.call(this, gurk, "KEEP");
      this.setButton(1, "REROLL");
      this.setButton(7, "BACK");
      this.roll();
    }

    CharacterRollView.prototype.roll = function() {
      var accuracyBonus, awarenessBonus, constitutionBonus, levelUp, strengthBonus, y;
      this.player = new Player(this.character);
      this.clear();
      this.addIcon(this.player.character.icon, 3, 3);
      y = 4;
      this.addLabel(this.player.character.name, "#FFF", 20, y);
      y += 8;
      this.addLabel("Level " + this.player.level + " " + this.player.character.job, "#FFF", 20, y);
      y += 8;
      levelUp = Data.levels[this.player.level + 1];
      this.addLabel("XP: " + this.player.experience + "/" + levelUp, "#FFF", 20, y);
      y += 8;
      if (this.player.maxSpellPoints > 0) {
        this.addLabel("HP: " + this.player.hitPoints + "/" + this.player.maxHitPoints + ", SP: " + this.player.spellPoints + "/" + this.player.maxSpellPoints, "#FFF", 20, y);
      } else {
        this.addLabel("Hit Points: " + this.player.hitPoints + "/" + this.player.maxHitPoints, "#FFF", 20, y);
      }
      y += 8;
      this.addLabel("Armor Class: " + (this.player.getArmorClass()), "#FFF", 20, y);
      y += 16;
      this.addLabel("Strength: " + (this.player.getStrength()), "#FFF", 20, y);
      y += 8;
      strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
      if (strengthBonus !== 0) {
        this.addLabel("Damage Bonus: " + strengthBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Accuracy: " + (this.player.getAccuracy()), "#FFF", 20, y);
      y += 8;
      accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
      if (accuracyBonus !== 0) {
        this.addLabel("To-Hit Bonus: " + accuracyBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Awareness: " + (this.player.getAwareness()), "#FFF", 20, y);
      y += 8;
      awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
      if (awarenessBonus !== 0) {
        this.addLabel("Armor Class Bonus: " + awarenessBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Toughness: " + (this.player.getConstitution()), "#FFF", 20, y);
      y += 8;
      constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
      if (constitutionBonus !== 0) {
        return this.addLabel("HP Bonus/Level: " + constitutionBonus, "#A0A0A0", 28, y);
      }
    };

    CharacterRollView.prototype.command = function(text) {
      switch (text) {
        case "KEEP":
          this.game.addPlayer(this.player);
          return this.gurk.popView("NEXT");
        case "BACK":
          return this.gurk.popView("BACK");
        case "REROLL":
          this.roll();
          return this.draw();
      }
    };

    return CharacterRollView;

  })(InfoView);

  CreateView = (function(_super) {

    __extends(CreateView, _super);

    CreateView.prototype.index = 0;

    CreateView.prototype.charIndex = 0;

    CreateView.prototype.types = null;

    CreateView.prototype.characters = null;

    CreateView.prototype.player = null;

    CreateView.prototype.game = null;

    function CreateView(gurk) {
      this.command = __bind(this.command, this);

      this.roll = __bind(this.roll, this);

      this.getCharacters = __bind(this.getCharacters, this);
      CreateView.__super__.constructor.call(this, gurk, "KEEP");
      this.types = ["warrior", "archer", "mage"];
      this.index = 0;
      this.setButton(1, "REROLL");
      this.game = new Game();
      this.getCharacters();
      this.roll();
    }

    CreateView.prototype.getCharacters = function() {
      var character, type, _i, _len, _ref;
      this.characters = [];
      type = this.types[this.index];
      _ref = Data.characters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        if (character.type === type) {
          this.characters.push(character);
        }
      }
      return this.charIndex = 0;
    };

    CreateView.prototype.roll = function() {
      var accuracyBonus, awarenessBonus, character, constitutionBonus, levelUp, strengthBonus, y;
      character = this.characters[this.charIndex];
      this.player = new Player(character);
      this.clear();
      this.addIcon(this.player.character.icon, 3, 3);
      y = 4;
      this.addLabel(this.player.character.name, "#FFF", 20, y);
      y += 8;
      this.addLabel("Level " + this.player.level + " " + this.player.character.job, "#FFF", 20, y);
      y += 8;
      levelUp = Data.levels[this.player.level + 1];
      this.addLabel("XP: " + this.player.experience + "/" + levelUp, "#FFF", 20, y);
      y += 8;
      if (this.player.maxSpellPoints > 0) {
        this.addLabel("HP: " + this.player.hitPoints + "/" + this.player.maxHitPoints + ", SP: " + this.player.spellPoints + "/" + this.player.maxSpellPoints, "#FFF", 20, y);
      } else {
        this.addLabel("Hit Points: " + this.player.hitPoints + "/" + this.player.maxHitPoints, "#FFF", 20, y);
      }
      y += 8;
      this.addLabel("Armor Class: " + (this.player.getArmorClass()), "#FFF", 20, y);
      y += 16;
      this.addLabel("Strength: " + (this.player.getStrength()), "#FFF", 20, y);
      y += 8;
      strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
      if (strengthBonus !== 0) {
        this.addLabel("Damage Bonus: " + strengthBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Accuracy: " + (this.player.getAccuracy()), "#FFF", 20, y);
      y += 8;
      accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
      if (accuracyBonus !== 0) {
        this.addLabel("To-Hit Bonus: " + accuracyBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Awareness: " + (this.player.getAwareness()), "#FFF", 20, y);
      y += 8;
      awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
      if (awarenessBonus !== 0) {
        this.addLabel("Armor Class Bonus: " + awarenessBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Toughness: " + (this.player.getConstitution()), "#FFF", 20, y);
      y += 8;
      constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
      if (constitutionBonus !== 0) {
        return this.addLabel("HP Bonus/Level: " + constitutionBonus, "#A0A0A0", 28, y);
      }
    };

    CreateView.prototype.command = function(text) {
      switch (text) {
        case "KEEP":
          this.game.addPlayer(this.player);
          this.index++;
          if (this.index === this.types.length) {
            return this.gurk.startNewGame(this.game);
          } else {
            this.getCharacters();
            this.roll();
            return this.draw();
          }
          break;
        case "REROLL":
          this.charIndex++;
          if (this.charIndex === this.characters.length) {
            this.charIndex = 0;
          }
          this.roll();
          return this.draw();
      }
    };

    return CreateView;

  })(InfoView);

  SplashView = (function(_super) {

    __extends(SplashView, _super);

    SplashView.TYPES = ["warrior", "archer", "mage"];

    SplashView.prototype.index = 0;

    SplashView.prototype.game = null;

    function SplashView(gurk) {
      this.processResult = __bind(this.processResult, this);

      this.command = __bind(this.command, this);

      this.showIntro = __bind(this.showIntro, this);

      this.doDraw = __bind(this.doDraw, this);

      this.doLayout = __bind(this.doLayout, this);
      SplashView.__super__.constructor.call(this, gurk, "splashScreen");
      this.name = "Splash";
      this.offsetX = -Screen.HALF_UNIT;
      this.offsetY = -Screen.HALF_UNIT;
      this.index = 0;
    }

    SplashView.prototype.doLayout = function() {
      this.setButton(1, "NEW");
      if (Device.hasSavedGame()) {
        this.setButton(3, "LOAD");
      } else {
        this.clearButton(3);
      }
      this.setButton(7, "OPTIONS");
      return this.setButton(9, "CHECK");
    };

    SplashView.prototype.doDraw = function() {
      var feature, tile, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
      console.log("Splash View drawing.");
      for (y = _i = 0, _ref = this.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          tile = this.getTerrainIcon(x, y);
          this.drawTile(tile, x, y);
        }
      }
      _ref2 = this.map.features;
      _results = [];
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        feature = _ref2[_k];
        _results.push(this.drawTile(feature.icon, feature.x, feature.y));
      }
      return _results;
    };

    SplashView.prototype.showIntro = function() {
      return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Welcome", "Welcome to realm of Gurk!\n\nRoll the stats for your Warrior, Archer and Mage, then lead them on to thrilling adventure!", "CREATE"));
    };

    SplashView.prototype.command = function(text) {
      var flow;
      switch (text) {
        case "NEW":
          if (Device.hasSavedGame()) {
            return this.gurk.pushView(new ConfirmView(this.gurk, Data.icons.party, "Warning!", "Creating a new game will delete your existing game. Are you sure you want to do this?", "NEW", "CANCEL"));
          } else {
            return this.showIntro();
          }
          break;
        case "LOAD":
          return this.gurk.startSavedGame();
        case "TEST":
          return this.gurk.startTestGame();
        case "OPTIONS":
          return this.gurk.showSettings();
        case "CHECK":
          return Validate.run();
        case "FLOW":
          flow = new FlowView(this.gurk, Data.icons.death, "Flow View", null);
          flow.addParagraph("Berserk", "#FFF");
          flow.addParagraph("While berserk, combatant will get an extra attack (or spell cast) each turn.", "#A0A0A0");
          flow.addGap();
          flow.addParagraph("Blinded", "#FFF");
          flow.addParagraph("When blinded, combatant's chance to hit when attack will be reduced considerably.", "#A0A0A0");
          flow.addGap();
          flow.addParagraph("Rooted", "#FFF");
          flow.addParagraph("A rooted combatant cannot move, although it may still attack and cast spells.", "#A0A0A0");
          return this.gurk.pushView(flow);
      }
    };

    SplashView.prototype.processResult = function(result) {
      switch (result) {
        case "NEW":
          return this.showIntro();
        case "CREATE":
          this.game = new Game();
          return this.gurk.pushView(new ChooseCharacterView(this.gurk, SplashView.TYPES[this.index], this.game));
        case "NEXT":
          this.index++;
          if (this.index === SplashView.TYPES.length) {
            return this.gurk.startNewGame(this.game);
          } else {
            return this.gurk.pushView(new ChooseCharacterView(this.gurk, SplashView.TYPES[this.index], this.game));
          }
      }
    };

    return SplashView;

  })(TileView);

  MapView = (function(_super) {

    __extends(MapView, _super);

    MapView.MAP_ICONS = {
      "shop": [['#764F00', '#FFFF48', '#764F00'], ['#764F00', '#000000', '#764F00'], ['#764F00', '#000000', '#764F00']],
      "ship": [[null, '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', null], ['#AF7300', '#AF7300', '#AF7300']],
      "temple": [['#FFFFFF', '#FF0000', '#FFFFFF'], ['#FF0000', '#FF0000', '#FF0000'], ['#FFFFFF', '#FF0000', '#FFFFFF']]
    };

    MapView.TRANSITION_ICONS = {
      "outdoor": [['#3CF000', '#3CF000', '#3CF000'], ['#32C800', '#32C800', '#32C800'], [null, '#AF7300', null]],
      "dungeon": [[null, '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#000000', '#FFFFFF']],
      "up": [[null, null, '#FFFFFF'], [null, '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#FFFFFF', '#FFFFFF']],
      "down": [['#FFFFFF', null, null], ['#FFFFFF', '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', '#FFFFFF']],
      "town": [['#FFFFFF', null, '#FFFFFF'], ['#FFFFFF', '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#AF7300', '#FFFFFF']]
    };

    MapView.FEATURE_TYPES = ["block", "barrier", "encounter", "goal", "alert", "dispatch", "transition", "shop", "temple", "ship", "sign", "override"];

    MapView.prototype.game = null;

    MapView.prototype.shadows = null;

    MapView.prototype.test = null;

    MapView.prototype.mapMode = false;

    MapView.prototype.encounter = null;

    MapView.prototype.upgrades = null;

    MapView.prototype.shadowOverlay = null;

    function MapView(gurk) {
      this.processResult = __bind(this.processResult, this);

      this.processFeature = __bind(this.processFeature, this);

      this.addButtonForFeature = __bind(this.addButtonForFeature, this);

      this.setMap = __bind(this.setMap, this);

      this.move = __bind(this.move, this);

      this.getTopFeature = __bind(this.getTopFeature, this);

      this.doDraw = __bind(this.doDraw, this);

      this.getTerrain = __bind(this.getTerrain, this);

      this.trackVisited = __bind(this.trackVisited, this);

      this.computeShadows = __bind(this.computeShadows, this);

      this.checkVisibility = __bind(this.checkVisibility, this);

      this.command = __bind(this.command, this);

      this.toggleMap = __bind(this.toggleMap, this);

      var x, y, _i, _j;
      MapView.__super__.constructor.call(this, gurk, gurk.game.map);
      this.name = "MapView";
      this.offsetX = -Screen.HALF_UNIT;
      this.offsetY = -Screen.HALF_UNIT;
      this.game = gurk.game;
      this.posX = this.game.x;
      this.posY = this.game.y;
      this.mapMode = false;
      this.shadowOverlay = Preloader.getImage("shadow" + Screen.SCALE + ".png");
      this.setButton(1, "HEROES");
      this.setButton(9, "MAP");
      this.setButton(3, "SAVE");
      this.setButton(7, "QUESTS");
      this.shadows = Util.create2DArray(Screen.WIN_SIZE, Screen.WIN_SIZE);
      for (y = _i = -1; _i <= 1; y = ++_i) {
        for (x = _j = -1; _j <= 1; x = ++_j) {
          this.shadows[y + Screen.CENTER_OFFSET][x + Screen.CENTER_OFFSET] = false;
        }
      }
      this.centerBanner = true;
      this.move(0, 0);
    }

    MapView.prototype.toggleMap = function() {
      this.mapMode = !this.mapMode;
      if (this.mapMode) {
        this.setButton(9, "NO MAP");
      } else {
        this.setButton(9, "MAP");
      }
      return this.draw();
    };

    MapView.prototype.command = function(text) {
      var save;
      switch (text) {
        case View.LEFT:
          return this.move(-1, 0);
        case View.UP:
          return this.move(0, -1);
        case View.RIGHT:
          return this.move(1, 0);
        case View.DOWN:
          return this.move(0, 1);
        case "MAP":
        case "NO MAP":
          return this.toggleMap();
        case "HEROES":
          return this.gurk.pushView(new PartyView(this.gurk));
        case "QUESTS":
          return this.gurk.pushView(new QuestView(this.gurk));
        case "SAVE":
          save = JSON.stringify(this.game.saveGame());
          Device.saveGame(save);
          return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Game Saved", "Your game has been saved!", null));
        default:
          return this.processFeature(text);
      }
    };

    MapView.prototype.checkVisibility = function(x, y) {
      var dx, dy, nx, ny, t1, t2, t3, xx, yy;
      dx = x - Screen.CENTER_OFFSET;
      dy = y - Screen.CENTER_OFFSET;
      yy = dy + this.posY;
      xx = dx + this.posX;
      if (yy >= 0 && yy < this.height && xx >= 0 && xx < this.width) {
        nx = dx > 0 ? -1 : 1;
        ny = dy > 0 ? -1 : 1;
        if (dx === 0) {
          return this.shadows[y][x] = this.shadows[ny + y][x] || this.getTerrain(xx, ny + yy).opaque;
        } else if (dy === 0) {
          return this.shadows[y][x] = this.shadows[y][nx + x] || this.getTerrain(nx + xx, yy).opaque;
        } else if (dx === dy || dx === -dy) {
          return this.shadows[y][x] = this.shadows[ny + y][nx + x] || this.getTerrain(nx + xx, ny + yy).opaque;
        } else {
          t1 = this.shadows[ny + y][x] || this.getTerrain(xx, ny + yy).opaque;
          t2 = this.shadows[y][nx + x] || this.getTerrain(nx + xx, yy).opaque;
          t3 = this.shadows[ny + y][nx + x] || this.getTerrain(nx + xx, ny + yy).opaque;
          return this.shadows[y][x] = t1 && t2 && t3;
        }
      } else {
        return this.shadows[y][x] = true;
      }
    };

    MapView.prototype.computeShadows = function() {
      var C, i, k, x, y, _i, _j;
      C = Screen.CENTER_OFFSET;
      for (k = _i = 2; _i <= 4; k = ++_i) {
        for (i = _j = 0; 0 <= k ? _j <= k : _j >= k; i = 0 <= k ? ++_j : --_j) {
          x = i + C;
          y = k + C;
          this.checkVisibility(x, y);
          x = i + C;
          y = -k + C;
          this.checkVisibility(x, y);
          if (i < k) {
            y = i + C;
            x = k + C;
            this.checkVisibility(x, y);
            y = i + C;
            x = -k + C;
            this.checkVisibility(x, y);
          }
          if (i > 0) {
            x = -i + C;
            y = k + C;
            this.checkVisibility(x, y);
            x = -i + C;
            y = -k + C;
            this.checkVisibility(x, y);
            if (i < k) {
              y = -i + C;
              x = k + C;
              this.checkVisibility(x, y);
              y = -i + C;
              x = -k + C;
              this.checkVisibility(x, y);
            }
          }
        }
      }
      return false;
    };

    MapView.prototype.trackVisited = function() {
      var x, xx, y, yy, _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = Screen.WIN_SIZE; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        yy = y + this.posY - Screen.CENTER_OFFSET;
        if (yy >= 0 && yy < this.height) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (x = _j = 0, _ref1 = Screen.WIN_SIZE; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
              xx = x + this.posX - Screen.CENTER_OFFSET;
              if (xx >= 0 && xx < this.width) {
                if (!this.map.dark || !this.shadows[y][x]) {
                  _results1.push(this.game.markVisited(xx, yy));
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MapView.prototype.getTerrain = function(x, y) {
      return Data.tiles[this.game.getTile(x, y)];
    };

    MapView.prototype.doDraw = function() {
      var color, feature, icon, partyIcon, sx, sy, tile, x, xx, y, yy, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      for (y = _i = 0, _ref = Screen.WIN_SIZE; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        yy = y + this.posY - Screen.CENTER_OFFSET;
        if (yy >= 0 && yy < this.height) {
          for (x = _j = 0, _ref1 = Screen.WIN_SIZE; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            xx = x + this.posX - Screen.CENTER_OFFSET;
            if (xx >= 0 && xx < this.width) {
              if (!this.map.dark || !this.shadows[y][x]) {
                tile = this.getTerrainIcon(xx, yy);
                this.drawTile(tile, x, y);
                if (this.game.getFeatures(xx, yy)) {
                  feature = this.getTopFeature(xx, yy);
                  if (feature && feature.icon) {
                    this.drawTile(feature.icon, x, y);
                  }
                }
              }
            }
          }
        }
      }
      partyIcon = this.game.aboard ? Data.icons.ship : Data.icons.party;
      this.drawTile(partyIcon, Screen.CENTER_OFFSET, Screen.CENTER_OFFSET);
      if (this.map.dark) {
        this.screen.drawImage(this.shadowOverlay, 0, 0);
      }
      if (this.mapMode) {
        sx = 128 - this.width - 5;
        if (sx < 10) {
          sx = (128 - this.width) / 2;
        }
        sy = 5;
        this.screen.setAlpha(0.5);
        this.screen.fillRect("#000", sx - 3, sy - 3, this.width + 6, this.height + 6);
        this.screen.setAlpha(1);
        this.screen.fillRect("#aaa", sx - 1, sy - 1, this.width + 2, this.height + 2);
        for (y = _k = 0, _ref2 = this.height; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
          for (x = _l = 0, _ref3 = this.width; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; x = 0 <= _ref3 ? ++_l : --_l) {
            if (this.game.wasVisited(x, y)) {
              color = this.getTerrain(x, y).color;
            } else {
              color = "#000";
            }
            this.screen.drawPixel(color, x + sx, y + sy);
          }
        }
        for (y = _m = 0, _ref4 = this.height; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; y = 0 <= _ref4 ? ++_m : --_m) {
          for (x = _n = 0, _ref5 = this.width; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; x = 0 <= _ref5 ? ++_n : --_n) {
            if (this.game.wasVisited(x, y)) {
              feature = this.getTopFeature(x, y);
              if (feature) {
                icon = null;
                switch (feature.type) {
                  case "shop":
                  case "ship":
                  case "temple":
                    icon = MapView.MAP_ICONS[feature.type];
                    break;
                  case "transition":
                    icon = MapView.TRANSITION_ICONS[feature.transitionType];
                }
                if (icon) {
                  for (yy = _o = 0; _o < 3; yy = ++_o) {
                    for (xx = _p = 0; _p < 3; xx = ++_p) {
                      color = icon[yy][xx];
                      if (color) {
                        this.screen.drawPixel(color, sx + x + xx - 1, sy + y + yy - 1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        this.screen.drawPixel("#F00", this.posX + sx - 1, this.posY + sy);
        this.screen.drawPixel("#F00", this.posX + sx + 1, this.posY + sy);
        this.screen.drawPixel("#F00", this.posX + sx, this.posY + sy + 1);
        return this.screen.drawPixel("#F00", this.posX + sx, this.posY + sy - 1);
      } else {
        this.drawBanner();
        return this.drawTopBanner();
      }
    };

    MapView.prototype.getTopFeature = function(x, y) {
      var feature, type, _i, _len, _ref;
      _ref = MapView.FEATURE_TYPES;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        feature = this.game.getFeature(x, y, type);
        if (feature) {
          return feature;
        }
      }
    };

    MapView.prototype.move = function(x, y) {
      var barrier, block, feature, gold, haveFeature, realMove, ship, text, title, tx, ty, _ref;
      realMove = !(x === 0 && y === 0);
      tx = this.posX + x;
      ty = this.posY + y;
      if (tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) {
        return false;
      } else {
        block = this.game.getFeature(tx, ty, "block");
        if (block) {
          return false;
        }
        barrier = this.game.getFeature(tx, ty, "barrier");
        if (barrier) {
          if (!!barrier.title) {
            title = barrier.title;
          } else {
            title = "Cannot Pass";
          }
          this.gurk.pushView(new AlertView(this.gurk, barrier.icon, title, barrier.text, null));
          return false;
        }
        if (this.getTerrain(tx, ty).passable || this.getTerrain(tx, ty).shipPassable && (this.game.aboard || this.game.getFeature(tx, ty, "ship"))) {
          this.clearBanner();
          if (realMove && this.game.aboard && this.game.getFeature(tx, ty, "ship")) {
            this.game.disembark();
            if (this.map.music) {
              this.gurk.playMusic(this.map.music);
            }
          }
          this.posX = tx;
          this.posY = ty;
          if (this.game.aboard && !this.getTerrain(tx, ty).shipPassable) {
            this.game.disembark();
            if (this.map.music) {
              this.gurk.playMusic(this.map.music);
            }
          }
          if (realMove) {
            this.gurk.game.moveTo(this.posX, this.posY);
            this.game.moveNum++;
            if (this.game.moveNum % 20 === 0) {
              this.game.regenerateParty();
            }
          }
          if (this.map.dark) {
            this.computeShadows();
          }
          this.trackVisited();
          haveFeature = false;
          if (!this.game.aboard && this.game.getFeature(tx, ty, "ship")) {
            ship = this.game.getFeature(tx, ty, "ship");
            if (this.game.isChartered(ship.id) || !ship.charter || ship.charter === 0) {
              this.clearButton(5);
              this.game.boardShip(this.game.getFeature(tx, ty, "ship").id);
              if (this.map.boatMusic) {
                this.gurk.playMusic(this.map.boatMusic);
              } else {
                this.gurk.playMusic(Data.boatMusic);
              }
            } else {
              this.setButton(5, "CHARTER");
              haveFeature = true;
            }
          }
          if (this.game.getFeatures(this.posX, this.posY)) {
            feature = this.getTopFeature(this.posX, this.posY);
            if (feature) {
              if (feature.type !== "ship") {
                haveFeature = true;
                switch (feature.type) {
                  case "encounter":
                    this.encounter = this.gurk.game.getEncounter(feature);
                    if (this.encounter.creatures.length === 0) {
                      this.game.setMarkers(feature.id);
                      this.game.setMarkers(feature.sets);
                      gold = (_ref = this.encounter.gold) != null ? _ref : 0;
                      text = feature.text;
                      if (gold > 0) {
                        this.game.gold += gold;
                        text = text + ("\n\nYou find " + gold + " gold pieces!");
                      }
                      if (this.encounter.items.length === 0) {
                        this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Treasure", text, null, feature.altIcon));
                      } else {
                        this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Treasure", text, "treasure", feature.altIcon));
                      }
                    } else {
                      this.gurk.playCombatMusic();
                      this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Encounter", feature.text, "combat"));
                    }
                    return null;
                  case "alert":
                    if (realMove) {
                      this.gurk.game.setMarkers(feature.sets);
                      this.gurk.pushView(new AlertView(this.gurk, feature.icon, feature.title, feature.text, "alert", feature.altIcon));
                      return null;
                    }
                    break;
                  case "goal":
                    this.gurk.game.setMarkers(feature.sets);
                    this.gurk.pushView(new AlertView(this.gurk, feature.icon, feature.title, feature.text, "goal", feature.altIcon));
                    return null;
                  case "ship":
                    break;
                  default:
                    this.addButtonForFeature(feature, realMove);
                }
              }
            }
          }
          if (!haveFeature) {
            this.clearButton(5);
            if (realMove) {
              if (this.game.checkForRandomEncounter()) {
                this.encounter = this.game.createEncounter();
                if (this.encounter.creatures.length > 0) {
                  if (this.encounter.ambushed) {
                    text = "Your adventurers have been ambushed!";
                  } else {
                    text = "Your adventurers have been attacked!";
                  }
                  this.gurk.playCombatMusic();
                  this.gurk.pushView(new AlertView(this.gurk, Data.icons.combat, "Encounter", text, "combat"));
                  return null;
                }
              }
            }
          }
          return this.draw();
        }
      }
    };

    MapView.prototype.setMap = function(mapName, x, y) {
      MapView.__super__.setMap.call(this, mapName, x, y);
      if (this.map.music) {
        return this.gurk.playMusic(this.map.music);
      }
    };

    MapView.prototype.addButtonForFeature = function(feature, realMove) {
      var command, name, _ref;
      this.clearButton(5);
      switch (feature.type) {
        case "sign":
          if (feature.text) {
            command = (_ref = feature.action) != null ? _ref : "LOOK";
            return this.setButton(5, command);
          }
          break;
        case "transition":
          if (realMove) {
            name = Data.maps[feature.target].name;
            this.setBanner(name);
          }
          return this.setButton(5, "GO");
        case "shop":
          this.setBanner(feature.name);
          return this.setButton(5, "SHOP");
        case "temple":
          return this.setButton(5, "HEAL");
        case "dispatch":
          return this.setButton(5, feature.action);
      }
    };

    MapView.prototype.processFeature = function(command) {
      var feature, _ref;
      feature = this.getTopFeature(this.posX, this.posY);
      switch (feature.type) {
        case "sign":
          this.gurk.game.setMarkers(feature.sets);
          return this.gurk.pushView(new AlertView(this.gurk, feature.icon, (_ref = feature.title) != null ? _ref : "Sign", feature.text, "sign", feature.altIcon));
        case "transition":
          return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Go", feature.text, "transition", null));
        case "shop":
          return this.gurk.pushView(new ItemView(this.gurk, null, ItemView.ACTION_BUY, feature));
        case "temple":
          if (feature.cost > this.game.gold) {
            return this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Cannot Pay", "The priests of the temple demand a tribute of " + feature.cost + " gold pieces, but you cannot pay it!", null));
          } else {
            return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Tribute", "To heal the adventurers, the priests require a tribute of " + feature.cost + " gold pieces, will you pay it?", "heal", null));
          }
          break;
        case "ship":
          if (feature.charter > this.game.gold) {
            return this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Cannot Pay", "The crew demand " + feature.charter + " gold pieces to charter this vessel, but you cannot pay it!", null));
          } else {
            return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Charter Ship", "Will you pay the crew " + feature.charter + " gold pieces to charter this ship?", "charter", null));
          }
          break;
        case "dispatch":
          return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, feature.title, feature.text, "dispatch", null, feature.altIcon));
      }
    };

    MapView.prototype.processResult = function(result) {
      var action, combatView, feature, gold, icon, image, nextAction, ship, start, temple, text, treasure, upgrade, _i, _len, _ref;
      switch (result) {
        case "goal":
          this.move(0, 0);
          return this.draw();
        case "alert":
        case "sign":
          this.move(0, 0);
          return this.draw();
        case "transition":
          feature = this.getTopFeature(this.posX, this.posY);
          this.game.transitionTo(feature.target, feature.targetX, feature.targetY);
          this.setMap(feature.target, feature.targetX, feature.targetY);
          this.move(0, 0);
          if (this.mapMode) {
            this.toggleMap();
          }
          return this.draw();
        case "victory":
          if (this.game.aboard) {
            if (this.map.boatMusic) {
              this.gurk.playMusic(this.map.boatMusic);
            } else {
              this.gurk.playMusic(Data.boatMusic);
            }
          } else if (this.map.music) {
            this.gurk.playMusic(this.map.music);
          }
          feature = this.game.getFeature(this.posX, this.posY, "encounter");
          if (feature) {
            this.gurk.game.setMarkers(feature.id);
            this.gurk.game.setMarkers(feature.sets);
          }
          this.move(0, 0);
          treasure = this.encounter.items;
          gold = this.encounter.gold;
          this.game.gold += gold;
          action = null;
          if (treasure.length > 0) {
            action = "treasure";
            icon = Data.icons.treasure;
            if (gold > 0) {
              text = "You find " + gold + " gold pieces and treasure amongst your defeated foes!";
            } else {
              text = "You find treasure amongst your defeated your foes!";
            }
          } else {
            if (gold > 0) {
              icon = Data.icons.gold;
              text = "You find " + gold + " gold pieces amongst your defeated foes!";
            } else {
              icon = Data.icons.party;
              text = "You have defeated your foes!";
            }
          }
          this.upgrades = this.game.giveExperience(this.encounter.creatures);
          if (this.upgrades.length > 0) {
            text += "\n";
            _ref = this.upgrades;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              upgrade = _ref[_i];
              text += "\n" + upgrade.player.character.name + " gained a level!";
            }
            action = "levelup";
          }
          return this.gurk.pushView(new AlertView(this.gurk, icon, "Victory", text, action));
        case "levelup":
          if (this.encounter.items.length > 0) {
            nextAction = "treasure";
          } else {
            nextAction = null;
          }
          return this.gurk.pushView(new LevelUpView(this.gurk, this.upgrades, nextAction));
        case "treasure":
          treasure = this.encounter.items;
          return this.gurk.pushView(new ItemView(this.gurk, null, "GIVE", treasure));
        case "combat":
          combatView = new CombatView(this.gurk, this.gurk.game.getCombatMap(), this.gurk.imageProcessor, this.encounter.creatures, this.encounter.ambushed);
          return this.gurk.pushView(combatView);
        case "heal":
          temple = this.getTopFeature(this.posX, this.posY);
          this.game.gold -= temple.cost;
          return this.game.healParty();
        case "charter":
          ship = this.getTopFeature(this.posX, this.posY);
          this.game.gold -= ship.charter;
          this.game.boardShip(ship.id);
          if (this.map.boatMusic) {
            this.gurk.playMusic(this.map.boatMusic);
          } else {
            this.gurk.playMusic(Data.boatMusic);
          }
          return this.clearButton(5);
        case "dispatch":
          feature = this.getTopFeature(this.posX, this.posY);
          return this.gurk.game.setMarkers(feature.sets);
        case "defeat":
          this.game.death();
          start = this.game.getStart();
          this.map = start.map;
          this.x = start.x;
          this.y = start.y;
          this.game.transitionTo(start.map, start.x, start.y);
          this.setMap(start.map, start.x, start.y);
          this.move(0, 0);
          return this.gurk.pushView(new AlertView(this.gurk, Data.icons.death, "Defeat", "You have been defeated! As blackness closes in, a strange feeling comes over the adventurers...", null));
        case "debug1":
          this.game.players[0].takeDamage(3);
          image = this.gurk.imageProcessor.rotate(Data.icons.death, ImageProcessor.LEFT);
          return this.fly(Data.icons.death, 1, 7, 7, 1, 75, this.animDone, image);
      }
    };

    return MapView;

  })(TileView);

  LevelUpView = (function(_super) {

    __extends(LevelUpView, _super);

    function LevelUpView(gurk, upgrades, nextAction) {
      var attrBonus, i, player, text, textX, upgrade, y, _i, _j, _len;
      this.nextAction = nextAction;
      this.command = __bind(this.command, this);

      LevelUpView.__super__.constructor.call(this, gurk, "OK");
      y = AlertView.ICON_Y;
      textX = AlertView.ICON_X * 2 + Screen.UNIT;
      this.addLabelCentered("Levelling Up", "#FFF", 0, y, 128, y + 8);
      y += 12;
      for (_i = 0, _len = upgrades.length; _i < _len; _i++) {
        upgrade = upgrades[_i];
        player = upgrade.player;
        this.addIcon(player.character.icon, AlertView.ICON_X, y);
        this.addLabel("" + player.character.name, "#FFF", textX, y);
        y += 8;
        text = "HP +" + upgrade.hitPointBonus;
        if (upgrade.spellPointBonus > 0) {
          text += ", SP +" + upgrade.spellPointBonus;
        }
        if (upgrade.newSpells) {
          text += " +spells";
        }
        this.addLabel(text, "#A0A0A0", textX, y);
        y += 8;
        text = "";
        for (i = _j = 0; _j < 4; i = ++_j) {
          attrBonus = upgrade.attrBonuses[i];
          if (attrBonus > 0) {
            this.addLabel("" + Player.ATTRIBUTES[i] + " +" + attrBonus, "#A0A0A0", textX, y);
            y += 8;
          }
        }
        y += 4;
      }
    }

    LevelUpView.prototype.command = function(text) {
      return this.gurk.popView(this.nextAction);
    };

    return LevelUpView;

  })(InfoView);

  PartyView = (function(_super) {

    __extends(PartyView, _super);

    PartyView.prototype.game = null;

    function PartyView(gurk) {
      this.command = __bind(this.command, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.doLayout = __bind(this.doLayout, this);
      PartyView.__super__.constructor.call(this, gurk, "VIEW", "EXIT");
      this.game = this.gurk.game;
      this.setButton(1, "OPTIONS");
    }

    PartyView.prototype.doLayout = function() {
      var color, key, map, marker, player, stats, y, _i, _len, _ref, _ref1;
      this.clear();
      _ref = Data.keys;
      for (marker in _ref) {
        key = _ref[marker];
        if (this.gurk.game.hasMarker(marker) && !this.gurk.game.hasMarker(key.until)) {
          this.addIcon(key.icon, 110, 10);
        }
      }
      y = 2;
      this.addLabelCentered("The Adventurers", "#FFF", 0, y, 128, Screen.FONT.fontHeight);
      y += 10;
      map = Data.maps[this.game.map];
      this.addLabel("In: " + map.name, "#FFF", 3, y);
      y += 8;
      this.addLabel("Gold: " + this.game.gold, "#E8C627", 3, y);
      y += 10;
      _ref1 = this.game.players;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        player = _ref1[_i];
        this.addIcon(player.character.icon, 2, y);
        color = player.isAlive() ? "#FFF" : "#999";
        this.addOption(player.character.name, color, 20, y);
        y += 8;
        this.addLabel("Level " + player.level + " " + player.character.job, "#FFF", 20, y);
        stats = "HP: " + player.hitPoints + "/" + player.maxHitPoints;
        if (player.maxSpellPoints > 0) {
          stats = stats + (" SP: " + player.spellPoints + "/" + player.maxSpellPoints);
        }
        y += 8;
        this.addLabel(stats, "#FFF", 20, y);
        y += 10;
      }
      if (this.game.bag) {
        this.addIcon(this.game.bag.character.icon, 2, y);
        this.addOption(this.game.bag.character.name, "#BBB", 20, y);
        y += 8;
        if (this.game.bag.items.length === 0) {
          return this.addLabel("Empty", "#FFF", 20, y);
        } else if (this.game.bag.items.length === 1) {
          return this.addLabel("1 item", "#FFF", 20, y);
        } else {
          return this.addLabel("" + this.game.bag.items.length + " items", "#FFF", 20, y);
        }
      }
    };

    PartyView.prototype.itemSelected = function(index, item) {
      if (index === 3) {
        return this.gurk.pushView(new ItemView(this.gurk, this.gurk.game.bag, ItemView.ACTION_INFO));
      } else {
        return this.gurk.pushView(new PlayerView(this.gurk, this.game.players[index]));
      }
    };

    PartyView.prototype.command = function(text) {
      if (text === "OPTIONS") {
        return this.gurk.showSettings();
      } else {
        return PartyView.__super__.command.call(this, text);
      }
    };

    return PartyView;

  })(SelectView);

  PlayerDialog = (function(_super) {

    __extends(PlayerDialog, _super);

    PlayerDialog.ACTION_HEAL = "HEAL";

    PlayerDialog.ACTION_RESTORE = "RESTORE";

    PlayerDialog.ACTION_GIVE = "GIVE";

    PlayerDialog.ACTION_SELL = "SELL";

    PlayerDialog.prototype.game = null;

    PlayerDialog.prototype.canSelect = null;

    function PlayerDialog(gurk, action, preselect) {
      var active, bag, color, index, message, player, selectIndex, showBag, y, _i, _len, _ref;
      this.action = action;
      this.preselect = preselect != null ? preselect : null;
      this.itemSelected = __bind(this.itemSelected, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      PlayerDialog.__super__.constructor.call(this, gurk, this.action, "CANCEL");
      this.game = this.gurk.game;
      this.canSelect = [];
      y = 3;
      showBag = false;
      switch (this.action) {
        case PlayerDialog.ACTION_HEAL:
          message = "Heal which Adventurer?";
          break;
        case PlayerDialog.ACTION_RESTORE:
          message = "Restore which Adventurer?";
          break;
        case PlayerDialog.ACTION_GIVE:
          message = "Give to which Adventurer?";
          showBag = true;
          break;
        case PlayerDialog.ACTION_SELL:
          message = "Which Adenturer will Sell?";
          showBag = true;
          break;
        default:
          message = "Choose an Adventurer";
      }
      this.addLabelCentered(message, "#FFF", 0, y, 128, Screen.FONT.fontHeight);
      y += 12;
      index = 0;
      selectIndex = -1;
      _ref = this.game.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        this.addIcon(player.character.icon, 2, y);
        active = true;
        if (this.action === PlayerDialog.ACTION_HEAL) {
          if (!player.isAlive() || player.isHealed()) {
            active = false;
          }
        } else if (this.action === PlayerDialog.ACTION_RESTORE) {
          if (!player.isAlive() || player.isRestored()) {
            active = false;
          }
        } else if (this.action === PlayerDialog.ACTION_GIVE) {
          if (!player.canCarryMoreItems()) {
            active = false;
          }
        } else if (this.action === PlayerDialog.ACTION_SELL) {
          if (player.numberOfItems() === 0) {
            active = false;
          }
        }
        this.canSelect.push(active);
        if (active && this.preselect && this.preselect === player) {
          selectIndex = index;
        }
        color = active ? "#FFF" : "#999";
        this.addOption(player.character.name, color, 20, y);
        y += 8;
        switch (this.action) {
          case PlayerDialog.ACTION_HEAL:
            this.addLabel("Hit Points: " + player.hitPoints + "/" + player.maxHitPoints, "#999", 20, y);
            break;
          case PlayerDialog.ACTION_RESTORE:
            this.addLabel("Spell Points: " + player.spellPoints + "/" + player.maxSpellPoints, "#999", 20, y);
            break;
          case PlayerDialog.ACTION_GIVE:
            this.addLabel("Can carry " + (Player.MAX_ITEMS - player.numberOfItems()) + " more items.", "#999", 20, y);
            break;
          case PlayerDialog.ACTION_SELL:
            this.addLabel("Carrying " + (player.numberOfItems()) + " items.", "#999", 20, y);
        }
        y += 20;
        index++;
      }
      if (showBag) {
        bag = this.gurk.game.bag;
        if (bag) {
          this.addIcon(bag.character.icon, 2, y);
          active = true;
          switch (this.action) {
            case PlayerDialog.ACTION_GIVE:
              if (!bag.canCarryMoreItems()) {
                active = false;
              }
              break;
            case PlayerDialog.ACTION_SELL:
              if (bag.numberOfItems() === 0) {
                active = false;
              }
          }
          this.canSelect.push(active);
          color = active ? "#FFF" : "#999";
          this.addOption(bag.character.name, color, 20, y);
          y += 8;
          switch (this.action) {
            case PlayerDialog.ACTION_GIVE:
              this.addLabel("Room for " + (Player.MAX_ITEMS - bag.numberOfItems()) + " more items.", "#999", 20, y);
              break;
            case PlayerDialog.ACTION_SELL:
              this.addLabel("Carrying " + (bag.numberOfItems()) + " items.", "#999", 20, y);
          }
        }
      }
      if (selectIndex >= 0) {
        this.selected = selectIndex;
      }
      this.start();
    }

    PlayerDialog.prototype.itemHighlighted = function(index, item) {
      if (this.canSelect[index]) {
        return this.setSelectVerb(this.action);
      } else {
        return this.turnOffSelection();
      }
    };

    PlayerDialog.prototype.itemSelected = function(index, item) {
      return this.gurk.popView(index);
    };

    return PlayerDialog;

  })(SelectView);

  PlayerView = (function(_super) {

    __extends(PlayerView, _super);

    function PlayerView(gurk, player) {
      this.player = player;
      this.command = __bind(this.command, this);

      this.doLayout = __bind(this.doLayout, this);

      PlayerView.__super__.constructor.call(this, gurk, "X");
      this.setButton(7, "BACK");
      this.setButton(9, "EXIT");
      this.setButton(5, "GEAR");
      this.setButton(1, "ITEMS");
    }

    PlayerView.prototype.doLayout = function() {
      var accuracyBonus, awarenessBonus, constitutionBonus, hasSpells, hasUse, levelUp, strengthBonus, y;
      hasSpells = this.player.hasSpells();
      hasUse = this.player.hasUsableItem(false);
      if (this.player.isAlive()) {
        if (hasSpells && hasUse) {
          this.setButton(3, "CAST/USE");
        } else if (hasSpells) {
          this.setButton(3, "SPELLS");
        } else if (hasUse) {
          this.setButton(3, "USE");
        }
      }
      this.clear();
      this.addIcon(this.player.character.icon, 3, 3);
      y = 4;
      this.addLabel(this.player.character.name, "#FFF", 20, y);
      y += 8;
      this.addLabel("Level " + this.player.level + " " + this.player.character.job, "#FFF", 20, y);
      y += 8;
      levelUp = Data.levels[this.player.level];
      this.addLabel("XP: " + this.player.experience + "/" + levelUp, "#FFF", 20, y);
      y += 8;
      if (this.player.maxSpellPoints > 0) {
        this.addLabel("HP: " + this.player.hitPoints + "/" + this.player.maxHitPoints + ", SP: " + this.player.spellPoints + "/" + this.player.maxSpellPoints, "#FFF", 20, y);
      } else {
        this.addLabel("Hit Points: " + this.player.hitPoints + "/" + this.player.maxHitPoints, "#FFF", 20, y);
      }
      y += 8;
      this.addLabel("Armor Class: " + (this.player.getArmorClass()), "#FFF", 20, y);
      y += 8;
      this.addLabel("Resistance: " + (this.player.getResistance()), "#FFF", 20, y);
      y += 12;
      this.addLabel("Strength: " + (this.player.getStrength()), "#FFF", 20, y);
      y += 8;
      strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
      if (strengthBonus !== 0) {
        this.addLabel("Damage Bonus: " + strengthBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Accuracy: " + (this.player.getAccuracy()), "#FFF", 20, y);
      y += 8;
      accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
      if (accuracyBonus !== 0) {
        this.addLabel("To-Hit Bonus: " + accuracyBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Awareness: " + (this.player.getAwareness()), "#FFF", 20, y);
      y += 8;
      awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
      if (awarenessBonus !== 0) {
        this.addLabel("Armor Class Bonus: " + awarenessBonus, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel("Toughness: " + (this.player.getConstitution()), "#FFF", 20, y);
      y += 8;
      constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
      if (constitutionBonus !== 0) {
        return this.addLabel("Resistance Bonus: " + constitutionBonus, "#A0A0A0", 28, y);
      }
    };

    PlayerView.prototype.command = function(text) {
      switch (text) {
        case "ITEMS":
          return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_INFO));
        case "GEAR":
          return this.gurk.pushView(new GearView(this.gurk, this.player));
        case "SPELLS":
        case "CAST/USE":
          return this.gurk.pushView(new SpellView(this.gurk, this.player));
        case "USE":
          return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_USE, false));
        case "BACK":
          return this.gurk.popView(null);
        case "EXIT":
          return this.gurk.popToTopView(null);
      }
    };

    return PlayerView;

  })(InfoView);

  GearView = (function(_super) {

    __extends(GearView, _super);

    GearView.slotIcons = [Data.icons.noWeapon, Data.icons.noShield, Data.icons.noHat, Data.icons.noArmor, Data.icons.noBoots, Data.icons.noAmulet];

    function GearView(gurk, player) {
      this.player = player;
      this.processResult = __bind(this.processResult, this);

      this.command = __bind(this.command, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.doLayout = __bind(this.doLayout, this);

      GearView.__super__.constructor.call(this, gurk, "EQUIP", "X");
      this.setButton(7, "BACK");
      this.setButton(9, "EXIT");
    }

    GearView.prototype.doLayout = function() {
      var color, icon, index, item, k, label, y, _ref;
      this.clear();
      this.addIcon(this.player.character.icon, 2, 2);
      this.addLabelCentered("" + this.player.character.name + "'s Gear", "#FFF", 0, 4, 128, 16);
      y = 2 + 16 + 2;
      index = 0;
      _ref = this.player.equipment;
      for (k in _ref) {
        item = _ref[k];
        color = "#FFF";
        if (item) {
          icon = item.template.icon;
          label = item.name;
          color = item.getColor();
        } else {
          icon = GearView.slotIcons[index];
          label = "(none)";
        }
        this.addIcon(icon, 2, y);
        this.addOption(label, color, 21, y + 4);
        index++;
        y += 18;
      }
      return this.start();
    };

    GearView.prototype.itemSelected = function(index, item) {
      return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_EQUIP, index));
    };

    GearView.prototype.itemHighlighted = function(index, item) {
      var type;
      type = Item.TYPES[index];
      if (this.player.getEquipableItemsByType(type).length > 0) {
        this.setButton(5, "EQUIP");
      } else {
        this.clearButton(5);
      }
      if (this.player.getEquippedItemByType(type)) {
        return this.setButton(1, "INFO");
      } else {
        return this.clearButton(1);
      }
    };

    GearView.prototype.command = function(text) {
      switch (text) {
        case "BACK":
          return this.gurk.popView(null);
        case "EXIT":
          return this.gurk.popToTopView(null);
        case "INFO":
          return this.gurk.pushView(new ItemInfoView(this.gurk, this.player.getEquippedItemByType(Item.TYPES[this.selected])));
        default:
          return GearView.__super__.command.call(this, text);
      }
    };

    GearView.prototype.processResult = function(item) {
      if (item) {
        if (item === ItemView.NONE) {
          return this.player.unequipItemByType(Item.TYPES[this.selected]);
        } else {
          this.player.equipItem(item);
          this.changeIcon(this.selected + 1, item.template.icon);
          return this.changeOption(this.selected, item.name, "#FFF");
        }
      }
    };

    return GearView;

  })(SelectView);

  QuestView = (function(_super) {

    __extends(QuestView, _super);

    function QuestView(gurk) {
      this.command = __bind(this.command, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.doLayout = __bind(this.doLayout, this);
      QuestView.__super__.constructor.call(this, gurk, "VIEW", "EXIT");
    }

    QuestView.prototype.doLayout = function() {
      var haveQuests, info, quest, y, _ref;
      this.clear();
      this.addLabelCentered("Quests", "#A0A0A0", 0, 1, 128, 8);
      haveQuests = false;
      y = 9;
      _ref = Data.quests;
      for (quest in _ref) {
        info = _ref[quest];
        if (this.gurk.game.hasMarker(info.started)) {
          haveQuests = true;
          if (this.gurk.game.hasMarker(info.done)) {
            this.addLabel("+", "#FFF", 1, y);
          }
          this.addOption(quest, "#FFF", 6, y);
          y += 8;
        }
      }
      if (!haveQuests) {
        return this.addLabel("(No quests yet)", "#FFF", 6, y);
      }
    };

    QuestView.prototype.itemSelected = function(index, label) {
      var done, infoView, questInfo;
      questInfo = Data.quests[label.text];
      done = this.gurk.game.hasMarker(questInfo.done);
      infoView = new AlertView(this.gurk, questInfo.icon, label.text, questInfo.text, null);
      if (done) {
        infoView.subtitle = "(Completed)";
      }
      return this.gurk.pushView(infoView);
    };

    QuestView.prototype.command = function(text) {
      switch (text) {
        case "EXIT":
          return this.gurk.popToTopView(null);
        default:
          return QuestView.__super__.command.call(this, text);
      }
    };

    return QuestView;

  })(SelectView);

  ItemView = (function(_super) {

    __extends(ItemView, _super);

    ItemView.ACTION_EQUIP = "EQUIP";

    ItemView.ACTION_INFO = "INFO";

    ItemView.ACTION_BUY = "BUY";

    ItemView.ACTION_SELL = "SELL";

    ItemView.ACTION_GIVE = "GIVE";

    ItemView.ACTION_USE = "USE";

    ItemView.ACTION_DROP = "DROP";

    ItemView.NONE = "(none)";

    ItemView.itemType = null;

    ItemView.items = null;

    ItemView.shop = null;

    ItemView.buyRate = 0;

    ItemView.sellRate = 0;

    ItemView.selectAction = null;

    ItemView.sellingPlayer = null;

    ItemView.inCombat = false;

    function ItemView(gurk, player, itemAction, param, melee, summon, combatant) {
      this.player = player;
      this.itemAction = itemAction;
      this.param = param != null ? param : null;
      this.melee = melee != null ? melee : null;
      this.summon = summon != null ? summon : null;
      this.combatant = combatant != null ? combatant : null;
      this.processResult = __bind(this.processResult, this);

      this.command = __bind(this.command, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      this.doLayout = __bind(this.doLayout, this);

      ItemView.__super__.constructor.call(this, gurk, this.itemAction, "X");
      if (this.itemAction === ItemView.ACTION_GIVE) {
        this.items = this.param;
      } else if (this.itemAction === ItemView.ACTION_BUY) {
        this.shop = this.param;
        this.items = gurk.game.getShopItems(this.shop.x, this.shop.y);
        this.buyRate = this.shop.buyRate;
        this.sellRate = this.shop.sellRate;
      } else if (this.itemAction === ItemView.ACTION_SELL) {
        this.shop = this.param;
        this.buyRate = this.shop.buyRate;
        this.sellRate = this.shop.sellRate;
        this.items = this.player.items;
      } else if (this.itemAction === ItemView.ACTION_USE) {
        this.inCombat = this.param;
      }
    }

    ItemView.prototype.doLayout = function() {
      var canUse, color, item, name, offset, option, optionWidth, spell, y, _i, _j, _len, _len1, _ref, _ref1;
      this.clear();
      switch (this.itemAction) {
        case ItemView.ACTION_EQUIP:
          this.addLabelCentered("" + (this.player.getName()) + "'s Items", "#A0A0A0", 0, 1, 128, 8);
          this.setButton(1, "INFO");
          this.setButton(7, "BACK");
          if (this.melee) {
            this.clearButton(9);
          } else {
            this.setButton(9, "EXIT");
          }
          this.items = this.player.getEquipableItemsByType(Item.TYPES[this.param]);
          this.items.push(ItemView.NONE);
          break;
        case ItemView.ACTION_INFO:
          this.addLabelCentered("" + (this.player.getName()) + "'s Items", "#A0A0A0", 0, 1, 128, 8);
          this.setButton(9, "EXIT");
          this.setButton(7, "BACK");
          this.setButton(3, "GIVE");
          this.setButton(1, "DROP");
          this.items = this.player.items;
          break;
        case ItemView.ACTION_GIVE:
          this.addLabelCentered("Items", "#A0A0A0", 0, 1, 128, 8);
          this.setButton(1, "INFO");
          this.setButton(9, "EXIT");
          break;
        case ItemView.ACTION_BUY:
          this.addLabelCentered("Gold: " + this.gurk.game.gold, "#E8C627", 0, 1, 128, 8);
          this.setButton(1, "INFO");
          this.setButton(3, "SELL...");
          this.setButton(9, "EXIT");
          break;
        case ItemView.ACTION_SELL:
          this.addLabelCentered("" + (this.player.getName()) + "'s Items", "#A0A0A0", 0, 1, 128, 8);
          this.setButton(1, "INFO");
          this.setButton(7, "BACK");
          this.setButton(9, "EXIT");
          break;
        case ItemView.ACTION_USE:
          this.addLabelCentered("Choose Item to Use", "#A0A0A0", 0, 1, 128, 8);
          this.setButton(1, "INFO");
          this.setButton(7, "BACK");
          if (!this.inCombat) {
            this.setButton(9, "EXIT");
          } else {
            this.clearButton(9);
          }
          this.items = [];
          _ref = this.player.items;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            if (this.player.canEmploy(item) && (item.isUseable() || (this.combatant && this.inCombat && item.getCombatSpell() && this.player.isItemEquipped(item) && !this.combatant.isCombatSpellUsed(item)))) {
              canUse = false;
              if (this.inCombat) {
                spell = item.getSpell();
                if (spell.type === "summon" && this.summon) {
                  canUse = true;
                } else if (spell.target !== "touch" || this.melee || spell.type === "heal") {
                  canUse = true;
                }
              } else if (item.canUseOutsideOfCombat()) {
                canUse = true;
              }
              if (canUse) {
                this.items.push(item);
              }
            }
          }
          if (this.items.length === 0) {
            this.gurk.popView(null);
          }
      }
      this.addIcon(Data.icons.blank, 128 - 17, 1);
      y = 9;
      if (this.items.length > 0) {
        _ref1 = this.items;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          item = _ref1[_j];
          if (item === ItemView.NONE) {
            this.addOption(ItemView.NONE, "#A0A0A0", 6, y);
          } else {
            color = item.getColor();
            if (this.player && this.player.isItemEquipped(item) && !this.inCombat) {
              this.addLabel("+", "#FFF", 1, y);
            }
            name = item.name;
            spell = null;
            if (item.charges > 0) {
              name = name + (" [" + item.charges + "]");
              spell = item.getSpell();
            } else if (item.getCombatSpell() && this.inCombat) {
              name = name + " [+]";
              spell = item.getCombatSpell();
            }
            if (spell && this.inCombat) {
              if (spell.fast) {
                this.addLabel("|", "#A0A0A0", 1, y);
              } else {
                this.addLabel("=", "#A0A0A0", 1, y);
              }
            }
            if (this.itemAction === ItemView.ACTION_BUY) {
              option = "" + name + " (" + (item.getShopValue(this.buyRate)) + ")";
              this.addOption(option, "#FFF", 1, y);
              offset = 1;
            } else if (this.itemAction === ItemView.ACTION_SELL) {
              option = "" + name + " (" + (item.getShopValue(this.sellRate)) + ")";
              this.addOption(option, "#FFF", 6, y);
              offset = 6;
            } else {
              option = name;
              this.addOption(name, "#FFF", 6, y);
              offset = 6;
            }
            if (item.template.legendary) {
              optionWidth = this.getTextWidth(option);
              this.addLabel("=", color, offset + optionWidth + 1, y);
            }
          }
          y += 8;
        }
      } else {
        this.addLabel("(No items)", "#FFF", 6, y);
        this.clearButton(1);
        this.clearButton(3);
        this.clearButton(5);
      }
      return this.start();
    };

    ItemView.prototype.itemHighlighted = function(index, item) {
      if (item.text === ItemView.NONE) {
        return this.changeIcon(0, GearView.slotIcons[this.param]);
      } else {
        this.changeIcon(0, this.items[index].template.icon);
        if (this.itemAction === ItemView.ACTION_BUY) {
          if (this.gurk.game.gold >= this.items[index].getShopValue(this.buyRate)) {
            return this.setButton(5, "BUY");
          } else {
            return this.clearButton(5);
          }
        }
      }
    };

    ItemView.prototype.itemSelected = function(index, label) {
      var item, price;
      if (label === ItemView.NONE) {
        return this.gurk.popView(label);
      } else {
        item = this.items[index];
        if (this.itemAction === ItemView.ACTION_EQUIP) {
          this.gurk.popView(item);
        }
        if (this.itemAction === ItemView.ACTION_SELL) {
          price = item.getShopValue(this.sellRate);
          this.gurk.pushView(new ConfirmView(this.gurk, item.template.icon, "Confirm Sale", "Sell " + item.name + " for " + price + " gold pieces?", "SELL_YES", "SELL_NO"));
        }
        if (this.itemAction === ItemView.ACTION_USE) {
          if (this.inCombat) {
            return this.gurk.popView(item);
          } else {
            if (item.getSpell().healType === "restore") {
              return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_RESTORE, this.player));
            } else {
              return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_HEAL, this.player));
            }
          }
        }
      }
    };

    ItemView.prototype.command = function(text) {
      var item;
      this.selectAction = text;
      switch (text) {
        case "BACK":
          return this.gurk.popView(null);
        case "EXIT":
          return this.gurk.popToTopView(null);
        case "INFO":
          return this.gurk.pushView(new ItemInfoView(this.gurk, this.items[this.selected]));
        case "GIVE":
        case "BUY":
          return this.gurk.pushView(new PlayerDialog(this.gurk, "GIVE"));
        case "SELL...":
          return this.gurk.pushView(new PlayerDialog(this.gurk, "SELL"));
        case "DROP":
          item = this.items[this.selected];
          return this.gurk.pushView(new ConfirmView(this.gurk, item.template.icon, "Confirm Drop", "Drop " + item.name + "? It will be gone forever!", "DROP_YES", "DROP_NO"));
        default:
          return ItemView.__super__.command.call(this, text);
      }
    };

    ItemView.prototype.processResult = function(param) {
      var bounds, healAmount, item, orgHitPoints, orgSpellPoints, restoreAmount, spell, target;
      item = this.items[this.selected];
      if (param === "SELL_YES") {
        this.gurk.game.gold += item.getShopValue(this.sellRate);
        this.player.dropItem(item);
        return this.doLayout();
      } else if (param === "DROP_YES") {
        this.player.dropItem(item);
        return this.doLayout();
      } else if (param === "DROP_NO") {
        return false;
      } else if (param === "SELL_NO") {
        return false;
      } else if (this.selectAction === "SELL...") {
        this.selectAction = "SELL";
        if (param === 3) {
          this.sellingPlayer = this.gurk.game.bag;
        } else {
          this.sellingPlayer = this.gurk.game.players[param];
        }
        return this.gurk.pushView(new ItemView(this.gurk, this.sellingPlayer, "SELL", this.shop));
      } else if (this.selectAction === "USE") {
        target = this.gurk.game.players[param];
        spell = item.getSpell();
        bounds = item.getSpellRange();
        item.charges--;
        if (item.charges === 0) {
          this.player.dropItem(item);
        }
        if (spell.healType === "restore") {
          orgSpellPoints = target.spellPoints;
          target.spellPoints += Util.random(bounds.min, bounds.max);
          if (target.spellPoints > target.maxSpellPoints) {
            target.spellPoints = target.maxSpellPoints;
          }
          restoreAmount = target.spellPoints - orgSpellPoints;
          return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Restored", "" + target.character.name + " was restored for " + restoreAmount + " points.", null));
        } else {
          orgHitPoints = target.hitPoints;
          target.hitPoints += Util.random(bounds.min, bounds.max);
          if (target.hitPoints > target.maxHitPoints) {
            target.hitPoints = target.maxHitPoints;
          }
          healAmount = target.hitPoints - orgHitPoints;
          return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Healed", "" + target.character.name + " was healed for " + healAmount + " points.", null));
        }
      } else {
        if (param === 3) {
          target = this.gurk.game.bag;
        } else {
          target = this.gurk.game.players[param];
        }
        if (target) {
          if (this.player !== target) {
            item = this.items[this.selected];
            if (this.player) {
              this.player.dropItem(item);
            } else {
              this.items.splice(this.selected, 1);
              if (this.itemAction === ItemView.ACTION_BUY) {
                this.gurk.game.gold -= item.getShopValue(this.buyRate);
              }
            }
            target.addItem(item);
            if (this.items.length === 0) {
              return this.gurk.popView(null);
            }
          }
        }
      }
    };

    return ItemView;

  })(SelectView);

  ItemInfoView = (function(_super) {

    __extends(ItemInfoView, _super);

    ItemInfoView.getUsedBy = function(template) {
      var first, text, type, _i, _len, _ref;
      first = true;
      text = "";
      _ref = template.usedBy;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (first) {
          first = false;
        } else {
          text += ", ";
        }
        switch (type) {
          case "warrior":
            text += "Warriors";
            break;
          case "archer":
            text += "Archers";
            break;
          case "mage":
            text += "Mages";
        }
      }
      return text;
    };

    function ItemInfoView(gurk, item) {
      var speed, spell, template, x, y;
      this.item = item;
      this.showSpell = __bind(this.showSpell, this);

      ItemInfoView.__super__.constructor.call(this, gurk, "DONE");
      template = this.item.template;
      this.addIcon(template.icon, 3, 3);
      y = 23;
      x = 3;
      if (template.legendary) {
        this.addLabelCentered(this.item.name, this.item.getColor(), 0, 3, 128, 8);
        this.addLabelCentered("(Legendary Artifact)", "#A0A0A0", 0, 12, 128, 8);
      } else {
        this.addLabelCentered(this.item.name, this.item.getColor(), 0, 4, 128, 16);
      }
      this.addLabel("(" + (ItemInfoView.getUsedBy(template)) + ")", "#FFF", x, y);
      y += 8;
      if (this.item.isMeleeWeapon()) {
        this.addLabel("Melee Damage: " + (Math.max(1, this.item.getMeleeMinDamage())) + " - " + (Math.max(1, this.item.getMeleeMaxDamage())), "#FFF", x, y);
        y += 8;
      }
      if (this.item.isRangeWeapon()) {
        this.addLabel("Range Damage: " + (Math.max(1, this.item.getRangeMinDamage())) + " - " + (Math.max(1, this.item.getRangeMaxDamage())), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getHitSpell()) {
        this.addLabel("Hit Effect", "#A0A0A0", x, y);
        y += 8;
        y = this.showSpell(this.item.getHitSpell(), 8, y, false, false);
      }
      if (this.item.getCombatSpell()) {
        speed = this.item.getCombatSpell().fast ? "|" : "=";
        this.addLabel("Once per Combat " + speed, "#A0A0A0", x, y);
        y += 8;
        y = this.showSpell(this.item.getCombatSpell(), 8, y, true, true);
      }
      if (this.item.getExtraMoves() > 0) {
        this.addLabel("Extra Moves: " + (this.item.getExtraMoves()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getExtraAttacks() > 0) {
        this.addLabel("Extra Attacks: " + (this.item.getExtraAttacks()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getToHitBonus() !== 0) {
        this.addLabel("To-Hit Bonus: " + (this.item.getToHitBonus()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getArmorClass() !== 0) {
        this.addLabel("Armor Class Bonus: " + (this.item.getArmorClass()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getResistance() !== 0) {
        this.addLabel("Resistance Bonus: " + (this.item.getResistance()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getStrengthBonus() !== 0) {
        this.addLabel("Strength Bonus: " + (this.item.getStrengthBonus()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getAccuracyBonus() !== 0) {
        this.addLabel("Accuracy Bonus: " + (this.item.getAccuracyBonus()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getAwarenessBonus() !== 0) {
        this.addLabel("Awareness Bonus: " + (this.item.getAwarenessBonus()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.getConstitutionBonus() !== 0) {
        this.addLabel("Toughness Bonus: " + (this.item.getConstitutionBonus()), "#FFF", x, y);
        y += 8;
      }
      if (this.item.isUseable()) {
        this.addLabel("Charges Left: " + this.item.charges, "#FFF", x, y);
        y += 8;
        spell = this.item.getSpell();
        speed = spell.fast ? "| Fast" : "= Normal";
        this.addLabel("Speed: " + speed, "#FFF", x, y);
        y += 8;
        this.showSpell(spell, x, y, true, true);
      }
    }

    ItemInfoView.prototype.showSpell = function(spell, x, y, showRange, showDrainDamage) {
      var effect, range, target;
      if (showRange == null) {
        showRange = true;
      }
      if (showDrainDamage == null) {
        showDrainDamage = false;
      }
      if (spell.type === "summon") {
        this.addLabel("Summons: " + spell.creature, "#FFF", x, y);
        y += 8;
      } else {
        range = this.item.getSpellRange(spell);
        if (spell.type === "damage") {
          effect = "Damage " + range.min + " - " + range.max;
        } else if (spell.type === "teleport") {
          effect = "Teleport";
        } else if (spell.type === "drain") {
          if (showDrainDamage) {
            effect = "Drains Life " + range.min + " - " + range.max;
          } else {
            effect = "Drains Life";
          }
        } else if (spell.type === "heal") {
          if (spell.healType === "restore") {
            effect = "Restore " + range.min + " - " + range.max;
          } else if (spell.healType === "remove") {
            effect = "Cure Afflictions";
          } else {
            effect = "Heal " + range.min + " - " + range.max;
          }
        } else {
          effect = spell.effect;
          if ("Poisoned" === effect) {
            effect += " (" + spell.value + ")";
          }
        }
        if (showRange) {
          this.addLabel("Effect: " + effect, "#FFF", x, y);
        } else {
          this.addLabel("" + effect, "#FFF", x, y);
        }
        y += 8;
        if (showRange) {
          if (spell.target === "touch") {
            target = "Touch";
          } else if (spell.target === "self") {
            target = "Self";
          } else if (spell.target === "range") {
            target = "Range";
          } else if (spell.target === "area") {
            target = "Area";
          }
          this.addLabel("Target: " + target, "#FFF", x, y);
          y += 8;
        }
      }
      return y;
    };

    return ItemInfoView;

  })(InfoView);

  SpellView = (function(_super) {

    __extends(SpellView, _super);

    SpellView.USE_NAME = "Use...";

    SpellView.prototype.creature = null;

    SpellView.prototype.spells = null;

    SpellView.prototype.castable = null;

    SpellView.prototype.resultMode = null;

    function SpellView(gurk, player, inCombat, melee, hasSummonRoom, combatant) {
      this.player = player;
      this.inCombat = inCombat != null ? inCombat : false;
      this.melee = melee != null ? melee : false;
      this.hasSummonRoom = hasSummonRoom != null ? hasSummonRoom : false;
      this.combatant = combatant != null ? combatant : null;
      this.processResult = __bind(this.processResult, this);

      this.command = __bind(this.command, this);

      this.itemSelected = __bind(this.itemSelected, this);

      this.itemHighlighted = __bind(this.itemHighlighted, this);

      this.doLayout = __bind(this.doLayout, this);

      SpellView.__super__.constructor.call(this, gurk, "CAST", "X");
      if (this.player.template) {
        this.creature = this.player;
      }
      if (!this.inCombat) {
        this.setButton(9, "EXIT");
        this.setButton(7, "BACK");
      } else {
        this.setButton(7, "CANCEL");
        this.clearButton(9);
      }
      this.setButton(1, "INFO");
    }

    SpellView.prototype.doLayout = function() {
      var active, color, index, spell, spellPoints, y, _i, _len, _ref;
      this.clear();
      this.spells = this.player.getSpells();
      this.castable = [];
      if (this.creature) {
        this.addLabelCentered("" + this.creature.template.name + "'s Spells (SP: " + this.player.spellPoints + ")", "#A0A0A0", 0, 1, 128, 8);
      } else {
        this.addLabelCentered("" + this.player.character.name + "'s Spells (SP: " + this.player.spellPoints + ")", "#A0A0A0", 0, 1, 128, 8);
      }
      y = 9;
      spellPoints = this.player.spellPoints;
      index = 0;
      _ref = this.spells;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spell = _ref[_i];
        active = false;
        if (spell.spellPoints <= spellPoints) {
          if ((spell.type === "heal" && (this.inCombat || spell.healType !== "remove")) || ((spell.type === "enhance" || spell.type === "teleport") && this.inCombat)) {
            active = true;
          } else if (this.inCombat) {
            if (spell.type === "summon" && this.hasSummonRoom) {
              active = true;
            } else if (spell.target === "touch" && this.melee) {
              active = true;
            } else if (spell.target === "range" || spell.target === "area") {
              active = true;
            }
          }
        }
        this.castable.push(active);
        color = active ? "#FFF" : "#888";
        if (active && this.inCombat) {
          if (spell.fast) {
            this.addLabel("|", "#A0A0A0", 1, y);
          } else {
            this.addLabel("=", "#A0A0A0", 1, y);
          }
        }
        this.addOption("" + spell.name + " (" + spell.spellPoints + ")", color, 6, y);
        y += 8;
        index++;
      }
      if (!this.creature && this.player.hasUsableItem(this.inCombat, this.melee, this.hasSummonRoom, this.combatant)) {
        this.addOption(SpellView.USE_NAME, "#FFF", 6, y);
      }
      return this.start();
    };

    SpellView.prototype.itemHighlighted = function(index, item) {
      if (item.text === SpellView.USE_NAME) {
        return this.setButton(5, "USE");
      } else if (this.castable[index]) {
        return this.setButton(5, "CAST");
      } else {
        return this.clearButton(5);
      }
    };

    SpellView.prototype.itemSelected = function(index, item) {
      if (this.castable[index]) {
        if (this.inCombat) {
          return this.gurk.popView(this.spells[index]);
        } else {
          if (this.gurk.game.playersNeedHealing()) {
            return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_HEAL));
          } else {
            return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Fully Healed", "There is nobody to target with that spell, all of the adventures are fully healed!", null));
          }
        }
      }
    };

    SpellView.prototype.command = function(text) {
      this.resultMode = "NORMAL";
      switch (text) {
        case "BACK":
        case "CANCEL":
          return this.gurk.popView(null);
        case "EXIT":
          return this.gurk.popToTopView(null);
        case "INFO":
          return this.gurk.pushView(new SpellInfoView(this.gurk, this.player, this.spells[this.selected]));
        case "USE":
          this.resultMode = "USE";
          return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_USE, this.inCombat, this.melee, this.hasSummonRoom, this.combatant));
        default:
          return SpellView.__super__.command.call(this, text);
      }
    };

    SpellView.prototype.processResult = function(result) {
      var bounds, healAmount, orgHitPoints, orgSpellPoints, restoreAmount, spell, target;
      if (this.resultMode === "USE") {
        return this.gurk.popView(result);
      } else {
        target = this.gurk.game.players[result];
        spell = this.spells[this.selected];
        this.player.spellPoints -= spell.spellPoints;
        bounds = this.player.getSpellRange(spell);
        if (spell.healType === "restore") {
          orgSpellPoints = target.spellPoints;
          target.spellPoints += Util.random(bounds.min, bounds.max);
          if (target.spellPoints > target.maxSpellPoints) {
            target.spellPoints = target.maxSpellPoints;
          }
          restoreAmount = target.spellPoints - orgSpellPoints;
          return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Restored", "" + target.character.name + " was restored for " + restoreAmount + " points, now at " + target.spellPoints + "/" + target.maxSpellPoints + ".", null));
        } else {
          orgHitPoints = target.hitPoints;
          target.hitPoints += Util.random(bounds.min, bounds.max);
          if (target.hitPoints > target.maxHitPoints) {
            target.hitPoints = target.maxHitPoints;
          }
          healAmount = target.hitPoints - orgHitPoints;
          return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Healed", "" + target.character.name + " was healed for " + healAmount + " points, now at " + target.hitPoints + "/" + target.maxHitPoints + ".", null));
        }
      }
    };

    return SpellView;

  })(SelectView);

  SpellInfoView = (function(_super) {

    __extends(SpellInfoView, _super);

    function SpellInfoView(gurk, player, spell) {
      var effect, range, speed, target, x, y;
      this.player = player;
      this.spell = spell;
      SpellInfoView.__super__.constructor.call(this, gurk, "DONE");
      range = this.player.getSpellRange(this.spell);
      this.addIcon(Data.icons.spell, 3, 3);
      this.addLabelCentered(this.spell.name, "#FFF", 0, 4, 128, 16);
      y = 23;
      x = 3;
      this.addLabel("Level: " + this.spell.level, "#FFF", x, y);
      y += 8;
      this.addLabel("Casting Cost: " + this.spell.spellPoints + " SP", "#FFF", x, y);
      y += 8;
      speed = this.spell.fast ? "| Fast" : "= Normal";
      this.addLabel("Speed: " + speed, "#FFF", x, y);
      y += 8;
      if (this.spell.type === "summon") {
        this.addLabel("Summons: " + this.spell.creature, "#FFF", x, y);
        y += 8;
      } else {
        if (this.spell.type === "damage") {
          effect = "Damage " + range.min + " - " + range.max;
        } else if (this.spell.type === "drain") {
          effect = "Drains Life " + range.min + " - " + range.max;
        } else if (this.spell.type === "heal") {
          if (this.spell.healType === "restore") {
            effect = "Restore";
          } else if (this.spell.healType === "remove") {
            effect = "Remove Afflictions";
          } else {
            effect = "Heal " + range.min + " - " + range.max;
          }
        } else if (this.spell.type === "teleport") {
          effect = "Teleport";
        } else {
          if (this.spell.effect === "Poisoned") {
            effect = "Poisoned (" + this.spell.value + ")";
          } else {
            effect = this.spell.effect;
          }
        }
        this.addLabel("Effect: " + effect, "#FFF", x, y);
        y += 8;
        if (this.spell.target === "touch") {
          target = "Touch";
        } else if (this.spell.target === "self") {
          target = "Self";
        } else if (this.spell.target === "range") {
          target = "Range";
        } else if (this.spell.target === "area") {
          target = "Area";
        }
        this.addLabel("Target: " + target, "#FFF", x, y);
        y += 8;
      }
    }

    return SpellInfoView;

  })(InfoView);

  Combatant = (function() {

    Combatant.EFFECT_COLORS = {
      "Berserk": {
        type: "glow",
        color: Util.rgb(108, 255, 108)
      },
      "Strong": {
        type: "glow",
        color: Util.rgb(255, 108, 108)
      },
      "Protected": {
        type: "glow",
        color: Util.rgb(108, 108, 255)
      },
      "Blessed": {
        type: "glow",
        color: Util.rgb(255, 255, 255)
      },
      "Quick": {
        type: "glow",
        color: Util.rgb(255, 192, 64)
      },
      "Eagle-eyed": {
        type: "glow",
        color: Util.rgb(255, 108, 255)
      },
      "Resistant": {
        type: "glow",
        color: Util.rgb(108, 255, 255)
      },
      "Paralyzed": {
        type: "shade",
        color: Util.rgb(-64, -64, 96)
      },
      "Rooted": {
        type: "shade",
        color: Util.rgb(32, 32, -96)
      },
      "Poisoned": {
        type: "shade",
        color: Util.rgb(-64, 96, -64)
      },
      "Weakened": {
        type: "shade",
        color: Util.rgb(72, 72, -64)
      },
      "Blinded": {
        type: "shade",
        color: Util.rgb(-64, -64, -64)
      },
      "Sluggish": {
        type: "shade",
        color: Util.rgb(-64, 72, 72)
      }
    };

    Combatant.prototype.hitPoints = 0;

    Combatant.prototype.lastTarget = null;

    Combatant.prototype.customImage = null;

    Combatant.prototype.numMoves = 1;

    Combatant.prototype.numAttacks = 1;

    Combatant.prototype.movesLeft = 0;

    Combatant.prototype.attacksLeft = 0;

    Combatant.prototype.effects = null;

    Combatant.prototype.usedCombatSpells = null;

    Combatant.prototype.halfAttack = false;

    Combatant.prototype.didAttack = false;

    Combatant.prototype.invisible = false;

    function Combatant(entity, isPlayer, good, x, y) {
      this.entity = entity;
      this.isPlayer = isPlayer;
      this.good = good;
      this.x = x != null ? x : -1;
      this.y = y != null ? y : -1;
      this.drawIcon = __bind(this.drawIcon, this);

      this.incrementEffects = __bind(this.incrementEffects, this);

      this.clearAllAfflictions = __bind(this.clearAllAfflictions, this);

      this.getEffect = __bind(this.getEffect, this);

      this.hasEffect = __bind(this.hasEffect, this);

      this.removeEffect = __bind(this.removeEffect, this);

      this.addEffect = __bind(this.addEffect, this);

      this.canSummon = __bind(this.canSummon, this);

      this.getRangeAnimation = __bind(this.getRangeAnimation, this);

      this.computeDamageBounds = __bind(this.computeDamageBounds, this);

      this.isPoisoned = __bind(this.isPoisoned, this);

      this.isRooted = __bind(this.isRooted, this);

      this.isParalyzed = __bind(this.isParalyzed, this);

      this.getHitSpell = __bind(this.getHitSpell, this);

      this.getRangeDamageBounds = __bind(this.getRangeDamageBounds, this);

      this.getMeleeDamageBounds = __bind(this.getMeleeDamageBounds, this);

      this.getArmorClass = __bind(this.getArmorClass, this);

      this.getToHitBonus = __bind(this.getToHitBonus, this);

      this.canAttackArea = __bind(this.canAttackArea, this);

      this.canAttackRange = __bind(this.canAttackRange, this);

      this.isFullyHealed = __bind(this.isFullyHealed, this);

      this.getPotency = __bind(this.getPotency, this);

      this.getResistance = __bind(this.getResistance, this);

      this.getMaxHitPoints = __bind(this.getMaxHitPoints, this);

      this.getIcon = __bind(this.getIcon, this);

      this.getBanner = __bind(this.getBanner, this);

      this.getName = __bind(this.getName, this);

      this.doHeal = __bind(this.doHeal, this);

      this.doDamage = __bind(this.doDamage, this);

      this.isCombatSpellUsed = __bind(this.isCombatSpellUsed, this);

      this.useCombatSpell = __bind(this.useCombatSpell, this);

      this.notDone = __bind(this.notDone, this);

      this.startTurn = __bind(this.startTurn, this);

      this.hitPoints = this.entity.hitPoints;
      this.effects = {};
      this.usedCombatSpells = {};
    }

    Combatant.prototype.startTurn = function() {
      var _ref, _ref1;
      if (this.isPlayer) {
        this.numMoves = 1 + this.entity.getExtraMoves();
        this.numAttacks = 1 + this.entity.getExtraAttacks();
      } else {
        this.numMoves = (_ref = this.entity.template.numMoves) != null ? _ref : 1;
        this.numAttacks = (_ref1 = this.entity.template.numAttacks) != null ? _ref1 : 1;
      }
      if (this.hasEffect("Berserk")) {
        this.numAttacks++;
      }
      if (this.hasEffect("Quick")) {
        this.numMoves += this.getEffect("Quick").value;
      }
      this.movesLeft = this.numMoves;
      this.attacksLeft = this.numAttacks;
      this.halfAttack = false;
      this.didAttack = false;
      this.drainAmount = 0;
      return this.usingItem = null;
    };

    Combatant.prototype.notDone = function() {
      return this.movesLeft > 0 || this.attacksLeft > 0;
    };

    Combatant.prototype.useCombatSpell = function(item) {
      return this.usedCombatSpells[item.id] = true;
    };

    Combatant.prototype.isCombatSpellUsed = function(item) {
      var _ref;
      return (_ref = this.usedCombatSpells[item.id]) != null ? _ref : false;
    };

    Combatant.prototype.doDamage = function(damage) {
      if (this.hasEffect("Blessed")) {
        damage = Math.round(damage / this.getEffect("Blessed").value);
        if (damage < 1) {
          damage = 1;
        }
      }
      this.hitPoints = Math.max(0, this.hitPoints - damage);
      if (this.isPlayer) {
        this.entity.hitPoints = this.hitPoints;
      }
      if (this.hitPoints === 0) {
        return true;
      } else {
        return false;
      }
    };

    Combatant.prototype.doHeal = function(amount, healType, imageProcessor, callback) {
      if (healType === "remove") {
        return this.clearAllAfflictions(imageProcessor, callback);
      } else if (healType === "restore") {
        return this.entity.spellPoints = Math.min(this.entity.maxSpellPoints, this.entity.spellPoints + amount);
      } else {
        this.hitPoints = Math.min(this.getMaxHitPoints(), this.hitPoints + amount);
        if (this.isPlayer) {
          return this.entity.hitPoints = this.hitPoints;
        }
      }
    };

    Combatant.prototype.getName = function() {
      return this.entity.getName();
    };

    Combatant.prototype.getBanner = function() {
      var k, name, v, _ref;
      name = this.getName();
      _ref = this.effects;
      for (k in _ref) {
        v = _ref[k];
        if (v) {
          name = "[" + k + "]";
        }
      }
      return name;
    };

    Combatant.prototype.getIcon = function() {
      if (this.isPlayer) {
        return this.entity.character.icon;
      } else {
        return this.entity.template.icon;
      }
    };

    Combatant.prototype.getMaxHitPoints = function() {
      return this.entity.maxHitPoints;
    };

    Combatant.prototype.getResistance = function() {
      var r;
      r = this.entity.getResistance();
      if (this.hasEffect("Resistant")) {
        r += this.getEffect("Resistant").value;
      }
      return r;
    };

    Combatant.prototype.getPotency = function() {
      return this.entity.getPotency();
    };

    Combatant.prototype.isFullyHealed = function() {
      return this.hitPoints === this.getMaxHitPoints();
    };

    Combatant.prototype.canAttackRange = function() {
      return this.entity.canAttackRange();
    };

    Combatant.prototype.canAttackArea = function() {
      return this.entity.canAttackArea();
    };

    Combatant.prototype.getToHitBonus = function() {
      var toHit;
      toHit = this.entity.getToHitBonus();
      if (this.hasEffect("Eagle-eyed")) {
        toHit += this.getEffect("Eagle-eyed").value;
      }
      if (this.hasEffect("Blinded")) {
        toHit -= this.getEffect("Blinded").value;
      }
      return toHit;
    };

    Combatant.prototype.getArmorClass = function() {
      var ac;
      ac = this.entity.getArmorClass();
      if (this.hasEffect("Protected")) {
        ac += this.getEffect("Protected").value;
      }
      if (this.hasEffect("Sluggish")) {
        ac -= this.getEffect("Sluggish").value;
      }
      return ac;
    };

    Combatant.prototype.getMeleeDamageBounds = function() {
      var bounds;
      bounds = this.entity.getMeleeDamageBounds();
      return this.computeDamageBounds(bounds);
    };

    Combatant.prototype.getRangeDamageBounds = function() {
      var bounds;
      bounds = this.entity.getRangeDamageBounds();
      return this.computeDamageBounds(bounds);
    };

    Combatant.prototype.getHitSpell = function() {
      return this.entity.getHitSpell();
    };

    Combatant.prototype.isParalyzed = function() {
      return this.hasEffect("Paralyzed");
    };

    Combatant.prototype.isRooted = function() {
      return this.hasEffect("Rooted");
    };

    Combatant.prototype.isPoisoned = function() {
      return this.hasEffect("Poisoned");
    };

    Combatant.prototype.computeDamageBounds = function(bounds) {
      var value;
      if (this.hasEffect("Strong")) {
        value = this.getEffect("Strong").value;
        bounds.min = Math.round(bounds.min * value);
        bounds.max = Math.round(bounds.max * value);
      }
      if (this.hasEffect("Weakened")) {
        value = this.getEffect("Weakened").value;
        bounds.min = Math.round(bounds.min / value);
        bounds.max = Math.round(bounds.max / value);
        if (bounds.min < 1) {
          bounds.min = 1;
        }
        if (bounds.max < 1) {
          bounds.max = 1;
        }
      }
      return bounds;
    };

    Combatant.prototype.getRangeAnimation = function() {
      if (this.isPlayer) {
        return this.entity.getWeapon().template.rangeAnimation;
      } else {
        return this.entity.template.rangeAnimation;
      }
    };

    Combatant.prototype.canSummon = function() {
      if (this.isPlayer) {
        return false;
      } else {
        if (this.entity.template.summons) {
          return true;
        } else {
          return false;
        }
      }
    };

    Combatant.prototype.addEffect = function(effect, value, duration, caster) {
      var already;
      already = this.hasEffect(effect);
      this.effects[effect] = {
        "value": value,
        "duration": duration
      };
      if (caster === this && !already) {
        if (effect === "Berserk") {
          return this.attacksLeft += value;
        } else if (effect === "Quick") {
          return this.movesLeft += value;
        }
      }
    };

    Combatant.prototype.removeEffect = function(effect) {
      return this.effects[effect] = null;
    };

    Combatant.prototype.hasEffect = function(effect) {
      return !!this.effects[effect];
    };

    Combatant.prototype.getEffect = function(effect) {
      return this.effects[effect];
    };

    Combatant.prototype.clearAllAfflictions = function(imageProcessor, callback) {
      var effect, value, _ref;
      _ref = this.effects;
      for (effect in _ref) {
        value = _ref[effect];
        if (Combatant.EFFECT_COLORS[effect].type === "shade") {
          this.removeEffect(effect);
        }
      }
      return this.drawIcon(imageProcessor, callback);
    };

    Combatant.prototype.incrementEffects = function(imageProcessor, callback) {
      var effect, info, removeList, _i, _len, _ref;
      removeList = [];
      _ref = this.effects;
      for (effect in _ref) {
        info = _ref[effect];
        if (effect === "Berserk") {
          if (!this.didAttack) {
            removeList.push(effect);
          }
        } else if (info) {
          info.duration--;
          if (info.duration <= 0) {
            removeList.push(effect);
          }
        }
      }
      if (removeList.length > 0) {
        for (_i = 0, _len = removeList.length; _i < _len; _i++) {
          effect = removeList[_i];
          this.removeEffect(effect);
        }
        return this.drawIcon(imageProcessor, callback);
      }
    };

    Combatant.prototype.drawIcon = function(imageProcessor, callback) {
      var effect, haloColors, info, shadeColors, value, _ref;
      if (!doCustomDraws()) {
        this.customImage = null;
        callback();
        return;
      }
      shadeColors = [];
      haloColors = [];
      _ref = this.effects;
      for (effect in _ref) {
        value = _ref[effect];
        if (value) {
          info = Combatant.EFFECT_COLORS[effect];
          if (info.type === "shade") {
            shadeColors.push(info.color);
          } else {
            haloColors.push(info.color);
          }
        }
      }
      if (shadeColors.length === 0 && haloColors.length === 0) {
        this.customImage = null;
        return callback();
      } else {
        this.customImage = imageProcessor.process(this.getIcon(), shadeColors, haloColors);
        return this.customImage.onload = callback;
      }
    };

    return Combatant;

  })();

  CombatantView = (function(_super) {

    __extends(CombatantView, _super);

    function CombatantView(gurk, combatant) {
      var effect, effectsList, text, value, _ref;
      this.combatant = combatant;
      this.command = __bind(this.command, this);

      CombatantView.__super__.constructor.call(this, gurk, this.combatant.getIcon(), this.combatant.getName(), null);
      this.addParagraph("Hit Points: " + this.combatant.hitPoints + "/" + (this.combatant.getMaxHitPoints()), "#FFF");
      if (this.combatant.isPlayer) {
        if (this.combatant.entity.maxSpellPoints > 0) {
          this.addParagraph("Spell Points: " + this.combatant.entity.spellPoints + "/" + this.combatant.entity.maxSpellPoints, "#FFF");
        }
      }
      this.addGap();
      effectsList = [];
      _ref = this.combatant.effects;
      for (effect in _ref) {
        value = _ref[effect];
        if (value) {
          effectsList.push(effect);
        }
      }
      if (effectsList.length > 0) {
        text = Util.arrayToString(effectsList);
        this.addParagraph("Effects: " + text, "#FFF");
        this.setButton(1, "EFFECTS");
      }
      if (!this.combatant.isPlayer) {
        this.addParagraph(this.combatant.entity.template.description, "#A0A0A0");
      }
    }

    CombatantView.prototype.command = function(text) {
      var effect, flow, value, _ref;
      switch (text) {
        case "EFFECTS":
          flow = new FlowView(this.gurk, this.combatant.getIcon(), "Combat Effects", null);
          _ref = this.combatant.effects;
          for (effect in _ref) {
            value = _ref[effect];
            if (value) {
              flow.addParagraph(effect, "#FFF");
              flow.addParagraph(Data.effects[effect], "#A0A0A0");
              flow.addGap();
            }
          }
          return this.gurk.pushView(flow);
        default:
          return CombatantView.__super__.command.call(this, text);
      }
    };

    return CombatantView;

  })(FlowView);

  CombatView = (function(_super) {

    __extends(CombatView, _super);

    CombatView.FORMATION = [
      {
        "x": 3,
        "y": 5
      }, {
        "x": 2,
        "y": 6
      }, {
        "x": 4,
        "y": 6
      }
    ];

    CombatView.SELECT_OFF = 0;

    CombatView.SELECT_VIEW = 1;

    CombatView.SELECT_ACTIVE = 2;

    CombatView.SELECT_TARGET = 3;

    CombatView.SELECT_TARGETED = 4;

    CombatView.SPELL_NONE = 0;

    CombatView.SPELL_HEAL = 1;

    CombatView.SPELL_DAMAGE = 2;

    CombatView.SPELL_SUMMON = 3;

    CombatView.SPELL_TELEPORT = 4;

    CombatView.SPELL_TARGET_MELEE = 0;

    CombatView.SPELL_TARGET_RANGE = 1;

    CombatView.LEFT_EDGE = 0;

    CombatView.RIGHT_EDGE = 6;

    CombatView.TOP_EDGE = 0;

    CombatView.BOTTOM_EDGE = 6;

    CombatView.BASE_SPEED = 175;

    CombatView.BASE_PAUSE = 625;

    CombatView.FAST_SPEED = 120;

    CombatView.FAST_PAUSE = 450;

    CombatView.prototype.combatants = null;

    CombatView.prototype.combatMap = null;

    CombatView.prototype.selectMode = CombatView.SELECT_OFF;

    CombatView.prototype.selectX = 0;

    CombatView.prototype.selectY = 0;

    CombatView.prototype.targetX = 0;

    CombatView.prototype.targetY = 0;

    CombatView.prototype.current = 0;

    CombatView.prototype.castingSpell = null;

    CombatView.prototype.teleportTarget = null;

    CombatView.prototype.usingItem = null;

    CombatView.prototype.spellType = 0;

    CombatView.prototype.spellTarget = 0;

    CombatView.prototype.areaSpell = false;

    CombatView.prototype.areaAttack = false;

    CombatView.prototype.drainAmount = 0;

    CombatView.prototype.selectingItemForUse = false;

    CombatView.prototype.queue = null;

    CombatView.prototype.stack = null;

    CombatView.prototype.combatSpeed = CombatView.BASE_SPEED;

    CombatView.prototype.pauseTime = CombatView.BASE_PAUSE;

    CombatView.prototype.isFiring = false;

    CombatView.prototype.isParalyzed = false;

    CombatView.prototype.strategy = null;

    function CombatView(gurk, mapName, imageProcessor, creatures, ambushed) {
      this.imageProcessor = imageProcessor;
      this.processResult = __bind(this.processResult, this);

      this.canUse = __bind(this.canUse, this);

      this.canCast = __bind(this.canCast, this);

      this.isClear = __bind(this.isClear, this);

      this.setTarget = __bind(this.setTarget, this);

      this.isStillAlive = __bind(this.isStillAlive, this);

      this.removeCombatant = __bind(this.removeCombatant, this);

      this.getBestAreaTarget = __bind(this.getBestAreaTarget, this);

      this.getRandomEnemy = __bind(this.getRandomEnemy, this);

      this.getNearestEnemy = __bind(this.getNearestEnemy, this);

      this.getNearestAttackTarget = __bind(this.getNearestAttackTarget, this);

      this.getNearestTarget = __bind(this.getNearestTarget, this);

      this.getRangeACBonus = __bind(this.getRangeACBonus, this);

      this.canAttack = __bind(this.canAttack, this);

      this.isInMeleeRangeXY = __bind(this.isInMeleeRangeXY, this);

      this.isInMeleeRange = __bind(this.isInMeleeRange, this);

      this.canSummon = __bind(this.canSummon, this);

      this.getSuggestedSummonSquare = __bind(this.getSuggestedSummonSquare, this);

      this.getRandomSquare = __bind(this.getRandomSquare, this);

      this.hasAllies = __bind(this.hasAllies, this);

      this.getSpellTargets = __bind(this.getSpellTargets, this);

      this.canTargetWithSpell = __bind(this.canTargetWithSpell, this);

      this.canTouchAlly = __bind(this.canTouchAlly, this);

      this.canAttackMelee = __bind(this.canAttackMelee, this);

      this.resistDamage = __bind(this.resistDamage, this);

      this.doSavingThrow = __bind(this.doSavingThrow, this);

      this.areEnemies = __bind(this.areEnemies, this);

      this.getSurroundingSquares = __bind(this.getSurroundingSquares, this);

      this.moveCombatant = __bind(this.moveCombatant, this);

      this.getCombatant = __bind(this.getCombatant, this);

      this.select = __bind(this.select, this);

      this.clearSelection = __bind(this.clearSelection, this);

      this.summonCreature = __bind(this.summonCreature, this);

      this.addCombatant = __bind(this.addCombatant, this);

      this.addPlayers = __bind(this.addPlayers, this);

      this.addCreatures = __bind(this.addCreatures, this);

      this.doDamage = __bind(this.doDamage, this);

      this.doResist = __bind(this.doResist, this);

      this.showAreaDamage = __bind(this.showAreaDamage, this);

      this.showResist = __bind(this.showResist, this);

      this.showAreaHealing = __bind(this.showAreaHealing, this);

      this.doAreaDamage = __bind(this.doAreaDamage, this);

      this.doAreaAttack = __bind(this.doAreaAttack, this);

      this.doAreaHealing = __bind(this.doAreaHealing, this);

      this.doAreaEffect = __bind(this.doAreaEffect, this);

      this.processAttack = __bind(this.processAttack, this);

      this.runAttack = __bind(this.runAttack, this);

      this.doPlayerAttack = __bind(this.doPlayerAttack, this);

      this.doSpellResult = __bind(this.doSpellResult, this);

      this.doSpellCast = __bind(this.doSpellCast, this);

      this.computeSpellTiming = __bind(this.computeSpellTiming, this);

      this.doPlayerCast = __bind(this.doPlayerCast, this);

      this.startPlayerWield = __bind(this.startPlayerWield, this);

      this.startPlayerUse = __bind(this.startPlayerUse, this);

      this.startPlayerCast = __bind(this.startPlayerCast, this);

      this.getSuggestedEnemyTarget = __bind(this.getSuggestedEnemyTarget, this);

      this.startPlayerAttack = __bind(this.startPlayerAttack, this);

      this.endTurn = __bind(this.endTurn, this);

      this.passTurn = __bind(this.passTurn, this);

      this.updateBanner = __bind(this.updateBanner, this);

      this.move = __bind(this.move, this);

      this.startPlayerTurn = __bind(this.startPlayerTurn, this);

      this.startTurn = __bind(this.startTurn, this);

      this.checkForWin = __bind(this.checkForWin, this);

      this.checkForLoss = __bind(this.checkForLoss, this);

      this.clearActions = __bind(this.clearActions, this);

      this.drawSelection = __bind(this.drawSelection, this);

      this.isSelected = __bind(this.isSelected, this);

      this.doDraw = __bind(this.doDraw, this);

      this.drawCombatant = __bind(this.drawCombatant, this);

      this.queueBlockAnimation = __bind(this.queueBlockAnimation, this);

      this.queueAnimation = __bind(this.queueAnimation, this);

      this.queueFly = __bind(this.queueFly, this);

      this.getCustomAnimation = __bind(this.getCustomAnimation, this);

      this.doPause = __bind(this.doPause, this);

      this.addSound = __bind(this.addSound, this);

      this.addPause = __bind(this.addPause, this);

      this.addAnimation = __bind(this.addAnimation, this);

      this.addAction = __bind(this.addAction, this);

      this.nextAction = __bind(this.nextAction, this);

      this.log = __bind(this.log, this);

      this.command = __bind(this.command, this);

      this.processIcon = __bind(this.processIcon, this);

      CombatView.__super__.constructor.call(this, gurk, mapName);
      if (this.gurk.getFastSetting()) {
        this.combatSpeed = CombatView.FAST_SPEED;
        this.pauseTime = CombatView.FAST_PAUSE;
      }
      this.strategy = new BasicStrategy(this);
      this.offsetX = -Screen.HALF_UNIT;
      this.combatants = [];
      this.combatMap = {};
      this.queue = [];
      this.stack = [];
      if (ambushed) {
        this.addCreatures(creatures);
        this.addPlayers();
      } else {
        this.addPlayers();
        this.addCreatures(creatures);
      }
      this.setButton(5, "OK");
      this.current = 0;
      this.startTurn();
      this.nextAction();
    }

    CombatView.prototype.processIcon = function(combatant) {
      return combatant.drawIcon(this.imageProcessor, this.draw);
    };

    CombatView.prototype.command = function(text) {
      var combatant;
      switch (text) {
        case View.LEFT:
          return this.move(-1, 0);
        case View.UP:
          return this.move(0, -1);
        case View.RIGHT:
          return this.move(1, 0);
        case View.DOWN:
          return this.move(0, 1);
        case "OK":
          return this.gurk.popView(null);
        case "ATT/FIRE":
        case "ATTACK":
        case "FIRE":
          this.isFiring = text === "FIRE";
          return this.startPlayerAttack();
        case "TARGET":
        case "HEAL":
        case "RESTORE":
        case "CURE":
        case "SUMMON":
        case "TELEPORT":
          if (this.spellType === CombatView.SPELL_NONE) {
            return this.doPlayerAttack();
          } else {
            return this.doSpellCast();
          }
          break;
        case "CAST":
        case "CAST/USE":
          return this.startPlayerCast();
        case "USE":
          return this.startPlayerUse();
        case "WIELD":
          return this.startPlayerWield();
        case "PASS":
          return this.passTurn();
        case "CANCEL":
          return this.startPlayerTurn();
        case "VIEW":
          this.clearActions();
          this.setButton(5, "INFO");
          this.setButton(7, "DONE");
          this.enableMovement();
          return this.select(this.selectX, this.selectY, CombatView.SELECT_VIEW);
        case "DONE":
          return this.startPlayerTurn();
        case "INFO":
          if (this.selectMode === CombatView.SELECT_TARGET) {
            combatant = this.getCombatant(this.targetX, this.targetY);
          } else {
            combatant = this.getCombatant(this.selectX, this.selectY);
          }
          if (combatant) {
            return this.gurk.pushView(new CombatantView(this.gurk, combatant));
          }
      }
    };

    CombatView.prototype.log = function(text) {};

    CombatView.prototype.nextAction = function() {
      var action, animation, info, next, _ref;
      next = true;
      while ((this.queue.length > 0 || this.stack.length > 0) && next) {
        if (this.queue.length === 0 && this.stack.length > 0) {
          this.queue = this.stack.pop();
        }
        while (this.queue.length > 0 && next) {
          _ref = this.queue.shift(), action = _ref.action, animation = _ref.animation, info = _ref.info;
          this.log("Action: " + info);
          if (action) {
            this.stack.push(this.queue);
            this.queue = [];
            action();
            next = !animation;
          }
        }
      }
      if (this.queue.length === 0 && this.stack.length > 0) {
        this.queue = this.stack.pop();
      }
      return this.queue.length > 0;
    };

    CombatView.prototype.addAction = function(action, info) {
      return this.queue.push({
        "action": action,
        animation: false,
        "info": info
      });
    };

    CombatView.prototype.addAnimation = function(action, info) {
      return this.queue.push({
        "action": action,
        animation: true,
        "info": info
      });
    };

    CombatView.prototype.addPause = function(info) {
      return this.queue.push({
        "action": this.doPause,
        animation: true,
        "info": info
      });
    };

    CombatView.prototype.addSound = function(sound, info) {
      var action,
        _this = this;
      action = function() {
        return _this.gurk.playSound(sound);
      };
      return this.queue.push({
        "action": action,
        animation: false,
        "info": info
      });
    };

    CombatView.prototype.doPause = function() {
      return setTimeout(this.nextAction, this.pauseTime);
    };

    CombatView.prototype.getCustomAnimation = function(sx, sy, tx, ty, animation) {
      var angle, dx, dy;
      if (Icons[animation].frames) {
        return null;
      } else {
        dx = tx - sx;
        dy = ty - sy;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0) {
            angle = ImageProcessor.RIGHT;
          } else {
            angle = ImageProcessor.LEFT;
          }
        } else {
          if (dy > 0) {
            angle = ImageProcessor.DOWN;
          } else {
            angle = ImageProcessor.UP;
          }
        }
        return this.gurk.imageProcessor.rotate(animation, angle);
      }
    };

    CombatView.prototype.queueFly = function(sx, sy, tx, ty, animation, info) {
      var action, custom,
        _this = this;
      custom = doCustomDraws() ? this.getCustomAnimation(sx, sy, tx, ty, animation) : null;
      action = function() {
        return _this.fly(animation, sx + 1, tx + 1, sy, ty, _this.combatSpeed / 2, _this.nextAction, custom);
      };
      return this.addAnimation(action, info);
    };

    CombatView.prototype.queueAnimation = function(x, y, animation, info) {
      var action,
        _this = this;
      action = function() {
        return _this.animate(animation, x + 1, y, _this.combatSpeed, _this.nextAction);
      };
      return this.addAnimation(action, info);
    };

    CombatView.prototype.queueBlockAnimation = function(x, y, radius, animation, info) {
      var action,
        _this = this;
      action = function() {
        return _this.animateBlock(animation, x + 1, y, radius, _this.combatSpeed, _this.nextAction);
      };
      return this.addAnimation(action, info);
    };

    CombatView.prototype.drawCombatant = function(combatant) {
      if (combatant.customImage) {
        return this.drawCustom(combatant.customImage, combatant.x + 1, combatant.y);
      } else {
        return this.drawTile(combatant.getIcon(), combatant.x + 1, combatant.y);
      }
    };

    CombatView.prototype.doDraw = function() {
      var combatant, tile, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
      for (y = _i = 0, _ref = this.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          tile = this.getTerrainIcon(x, y);
          this.drawTile(tile, x, y);
        }
      }
      this.drawSelection();
      _ref2 = this.combatants;
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        combatant = _ref2[_k];
        if (!combatant.invisible) {
          this.drawCombatant(combatant);
        }
      }
      this.drawBanner();
      return this.drawTopBanner();
    };

    CombatView.prototype.isSelected = function(x, y) {
      switch (this.selectMode) {
        case CombatView.SELECT_ACTIVE:
        case CombatView.SELECT_VIEW:
          return x === this.selectX && y === this.selectY;
        case CombatView.SELECT_TARGET:
          return x === this.selectX && y === this.selectY || x === this.targetX && y === this.targetY;
      }
      return false;
    };

    CombatView.prototype.drawSelection = function() {
      var maxX, maxY, minX, minY, selectIcon, targetIcon, x, y, _i, _j, _k;
      if (this.selectMode !== CombatView.SELECT_OFF && this.selectMode !== CombatView.SELECT_TARGETED) {
        switch (this.selectMode) {
          case CombatView.SELECT_ACTIVE:
            selectIcon = Data.icons.selectActive;
            break;
          case CombatView.SELECT_TARGET:
            targetIcon = Data.icons.selectTarget;
            if (this.areaSpell || this.areaAttack) {
              minY = Math.max(CombatView.TOP_EDGE, this.targetY - 1);
              maxY = Math.min(CombatView.BOTTOM_EDGE, this.targetY + 1);
              minX = Math.max(CombatView.LEFT_EDGE, this.targetX - 1) + 1;
              maxX = Math.min(CombatView.RIGHT_EDGE, this.targetX + 1) + 1;
              for (x = _i = minX; minX <= maxX ? _i <= maxX : _i >= maxX; x = minX <= maxX ? ++_i : --_i) {
                this.drawTile(targetIcon.top, x, minY - 1);
                this.drawTile(targetIcon.bottom, x, maxY + 1);
              }
              for (y = _j = minY; minY <= maxY ? _j <= maxY : _j >= maxY; y = minY <= maxY ? ++_j : --_j) {
                this.drawTile(targetIcon.left, minX - 1, y);
                this.drawTile(targetIcon.right, maxX + 1, y);
                for (x = _k = minX; minX <= maxX ? _k <= maxX : _k >= maxX; x = minX <= maxX ? ++_k : --_k) {
                  this.drawTile(targetIcon.center, x, y);
                }
              }
              this.drawTile(targetIcon.center, this.targetX + 1, this.targetY);
            } else {
              this.drawTile(targetIcon.center, this.targetX + 1, this.targetY);
              this.drawTile(targetIcon.left, this.targetX, this.targetY);
              this.drawTile(targetIcon.top, this.targetX + 1, this.targetY - 1);
              this.drawTile(targetIcon.right, this.targetX + 2, this.targetY);
              this.drawTile(targetIcon.bottom, this.targetX + 1, this.targetY + 1);
            }
            selectIcon = Data.icons.selectActive;
            break;
          case CombatView.SELECT_VIEW:
            selectIcon = Data.icons.selectView;
        }
        if (this.selectMode !== CombatView.SELECT_TARGET || this.targetX !== this.selectX || this.targetY !== this.selectY) {
          this.drawTile(selectIcon.center, this.selectX + 1, this.selectY);
          this.drawTile(selectIcon.left, this.selectX, this.selectY);
          this.drawTile(selectIcon.top, this.selectX + 1, this.selectY - 1);
          this.drawTile(selectIcon.right, this.selectX + 2, this.selectY);
          return this.drawTile(selectIcon.bottom, this.selectX + 1, this.selectY + 1);
        }
      }
    };

    CombatView.prototype.clearActions = function() {
      return this.clearAllButtons();
    };

    CombatView.prototype.checkForLoss = function() {
      var combatant, _i, _len, _ref;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        combatant = _ref[_i];
        if (combatant.isPlayer) {
          return false;
        }
      }
      return true;
    };

    CombatView.prototype.checkForWin = function() {
      var combatant, _i, _len, _ref;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        combatant = _ref[_i];
        if (!combatant.good) {
          return false;
        }
      }
      return true;
    };

    CombatView.prototype.startTurn = function() {
      var combatant, f, numMoves,
        _this = this;
      if (this.checkForLoss()) {
        return this.gurk.popView("defeat");
      } else if (this.checkForWin()) {
        return this.gurk.popView("victory");
      } else {
        combatant = this.combatants[this.current];
        combatant.startTurn();
        this.select(combatant.x, combatant.y, CombatView.SELECT_ACTIVE);
        if (combatant.isParalyzed()) {
          this.clearActions();
          this.isParalyzed = true;
          this.addPause("Paralyzed Pause 1");
          this.addPause("Paralyzed Pause 2");
          return this.addAction(this.passTurn, "Paralyzed Pass Turn");
        } else if (combatant.good) {
          return this.startPlayerTurn();
        } else {
          this.clearActions();
          this.addPause("AI Start Pause");
          numMoves = combatant.isRooted() ? 0 : combatant.numMoves;
          f = function() {
            return _this.strategy.doTurn(combatant, numMoves, combatant.numAttacks);
          };
          return this.addAction(f, "AI Do Turn");
        }
      }
    };

    CombatView.prototype.startPlayerTurn = function() {
      var canCast, canUse, player;
      this.castingSpell = null;
      this.spellType = null;
      this.areaSpell = false;
      this.areaAttack = false;
      if (this.checkForLoss()) {
        this.gurk.popView("defeat");
        return;
      } else if (this.checkForWin()) {
        this.gurk.popView("victory");
        return;
      }
      player = this.combatants[this.current];
      this.select(player.x, player.y, CombatView.SELECT_ACTIVE);
      this.spellType = CombatView.SPELL_NONE;
      this.clearActions();
      if (player.isRooted()) {
        player.movesLeft = 0;
      }
      if (player.movesLeft > 0) {
        this.enableMovement();
      }
      this.setButton(5, "VIEW");
      this.setButton(7, "PASS");
      if (player.isPlayer) {
        if (player.entity.getEquipableItemsByType(Item.TYPE_WEAPON).length > 1 || player.entity.getEquipableItemsByType(Item.TYPE_WEAPON).length === 1 && player.entity.getWeapon() === null) {
          this.setButton(3, "WIELD");
        }
      }
      if (this.canAttackMelee(player) || player.canAttackRange()) {
        if (player.canAttackRange()) {
          if (this.canAttackMelee(player) && player.entity.canAttackMelee()) {
            this.setButton(1, "ATT/FIRE");
          } else {
            this.setButton(1, "FIRE");
          }
        } else {
          if (this.canAttackMelee(player)) {
            this.setButton(1, "ATTACK");
          }
        }
      }
      canCast = this.canCast(player);
      canUse = this.canUse(player, this.canAttackMelee(player), this.canSummon(player));
      if (canCast && canUse) {
        this.setButton(9, "CAST/USE");
      } else if (canCast) {
        this.setButton(9, "CAST");
      } else if (canUse) {
        this.setButton(9, "USE");
      }
      return this.draw();
    };

    CombatView.prototype.move = function(dx, dy) {
      var casting, combatant, key, target, x, y;
      if (this.selectMode === CombatView.SELECT_TARGET) {
        combatant = this.combatants[this.current];
        casting = this.spellType !== CombatView.SPELL_NONE;
        x = this.targetX + dx;
        y = this.targetY + dy;
        if (this.isInMeleeRangeXY(combatant, x, y) || (!casting && (combatant.canAttackRange())) || (casting && (this.spellTarget === CombatView.SPELL_TARGET_RANGE || this.spellType === CombatView.SPELL_TELEPORT))) {
          if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
            this.targetX = x;
            this.targetY = y;
            target = this.getCombatant(x, y);
            this.clearButton(5);
            this.clearButton(1);
            if (target) {
              this.setButton(1, "INFO");
              if (!casting) {
                if (this.areEnemies(combatant, target)) {
                  this.setButton(5, "TARGET");
                }
              } else if (this.castingSpell.target === "area") {
                this.setButton(5, "TARGET");
              } else {
                switch (this.spellType) {
                  case CombatView.SPELL_HEAL:
                    if (!this.areEnemies(combatant, target) || this.castingSpell.type === "teleport") {
                      if (this.castingSpell.type === "heal") {
                        if (this.castingSpell.healType === "restore") {
                          this.setButton(5, "RESTORE");
                        } else if (this.castingSpell.healType === "remove") {
                          this.setButton(5, "CURE");
                        } else {
                          this.setButton(5, "HEAL");
                        }
                      } else {
                        this.setButton(5, "TARGET");
                      }
                    }
                    break;
                  case CombatView.SPELL_DAMAGE:
                    if (this.areEnemies(combatant, target)) {
                      this.setButton(5, "TARGET");
                    }
                }
              }
            } else {
              if (casting) {
                if (this.spellType === CombatView.SPELL_SUMMON) {
                  this.setButton(5, "SUMMON");
                } else if (this.spellType === CombatView.SPELL_TELEPORT) {
                  this.setButton(5, "TELEPORT");
                } else if (this.castingSpell.target === "area") {
                  this.setButton(5, "TARGET");
                }
              } else if (this.areaAttack) {
                this.setButton(5, "TARGET");
              }
            }
            return this.updateBanner();
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else if (this.selectMode === CombatView.SELECT_VIEW) {
        x = this.selectX + dx;
        y = this.selectY + dy;
        if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
          this.selectX = x;
          this.selectY = y;
          if (this.getCombatant(x, y)) {
            this.setButton(5, "INFO");
          } else {
            this.clearButton(5);
          }
          return this.updateBanner();
        } else {
          return false;
        }
      } else {
        combatant = this.combatants[this.current];
        if (combatant.movesLeft > 0) {
          x = combatant.x + dx;
          y = combatant.y + dy;
          if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
            key = Game.getKey(x, y);
            if (!this.combatMap[key]) {
              this.addSound("move", "Move Sound");
              this.moveCombatant(combatant.x, combatant.y, x, y);
              combatant.movesLeft--;
              if (combatant.movesLeft === 0) {
                combatant.attacksLeft = 0;
              }
              this.draw();
              this.endTurn();
            }
          }
        }
        return false;
      }
    };

    CombatView.prototype.updateBanner = function() {
      var banner, combatant, x, y;
      if (this.selectMode === CombatView.SELECT_TARGET || this.selectMode === CombatView.SELECT_TARGETED) {
        x = this.targetX;
        y = this.targetY;
      } else if (this.selectMode === CombatView.SELECT_VIEW) {
        x = this.selectX;
        y = this.selectY;
      } else {
        combatant = this.combatants[this.current];
        x = combatant.x;
        y = combatant.y;
      }
      combatant = this.getCombatant(x, y);
      if (combatant && this.selectMode !== CombatView.SELECT_OFF) {
        banner = "" + (combatant.getBanner()) + " (HP: " + combatant.hitPoints;
        if (combatant.good && combatant.entity.maxSpellPoints > 0) {
          banner += ", SP: " + combatant.entity.spellPoints + ")";
        } else {
          banner += ")";
        }
        this.setBanner(banner);
        if (this.selectMode === CombatView.SELECT_ACTIVE && combatant.good) {
          if (!combatant.isParalyzed() && (combatant.numMoves > 1 || combatant.numAttacks > 1)) {
            this.setTopBanner(combatant.movesLeft, combatant.attacksLeft, combatant.halfAttack);
          } else {
            this.clearTopBanner();
          }
          this.topBannerLeft = this.selectX > 3;
        } else {
          this.clearTopBanner();
        }
      } else {
        this.clearBanner();
        this.clearTopBanner();
      }
      return this.draw();
    };

    CombatView.prototype.passTurn = function() {
      var combatant;
      combatant = this.combatants[this.current];
      combatant.movesLeft = 0;
      combatant.attacksLeft = 0;
      return this.endTurn();
    };

    CombatView.prototype.endTurn = function() {
      var action, combatant, damage, f, fx, wasPlayer,
        _this = this;
      combatant = this.combatants[this.current];
      wasPlayer = combatant.good;
      if (wasPlayer && combatant.notDone()) {
        action = function() {
          return _this.startPlayerTurn();
        };
      } else {
        if (combatant.isPoisoned()) {
          damage = combatant.getEffect("Poisoned").value;
          if (combatant.hitPoints - damage < 1) {
            damage = combatant.hitPoints - 1;
          }
          if (damage > 0) {
            f = function() {
              _this.targetX = combatant.x;
              _this.targetY = combatant.y;
              _this.selectMode = CombatView.SELECT_TARGETED;
              _this.updateBanner();
              return _this.doDamage(combatant, damage, Data.icons.animPoison);
            };
            this.addAction(f, "Do Poison Damage");
            this.addPause("Pause After Poison Damage");
          }
        }
        fx = function() {
          return combatant.incrementEffects(_this.imageProcessor, _this.draw);
        };
        this.addAction(fx, "Increment FX");
        action = function() {
          _this.current++;
          if (_this.current >= _this.combatants.length) {
            _this.current = 0;
          }
          return _this.startTurn();
        };
      }
      this.addAction(action, "End Turn");
      if (wasPlayer && !this.isParalyzed) {
        return this.nextAction();
      } else {
        return this.isParalyzed = false;
      }
    };

    CombatView.prototype.startPlayerAttack = function() {
      var player, target;
      player = this.combatants[this.current];
      target = this.getSuggestedEnemyTarget(player);
      this.areaAttack = player.canAttackArea();
      if (target) {
        this.select(target.x, target.y, CombatView.SELECT_TARGET);
        this.clearActions();
        this.enableMovement();
        this.setButton(1, "INFO");
        this.setButton(5, "TARGET");
        this.setButton(7, "CANCEL");
      }
      return this.draw();
    };

    CombatView.prototype.getSuggestedEnemyTarget = function(player, forceRange) {
      var target;
      if (forceRange == null) {
        forceRange = false;
      }
      target = null;
      if (player.lastTarget && this.isStillAlive(player.lastTarget) && this.canAttack(player, player.lastTarget)) {
        target = player.lastTarget;
      }
      if (!target) {
        target = this.getNearestAttackTarget(player, forceRange);
      }
      return target;
    };

    CombatView.prototype.startPlayerCast = function() {
      var melee, player, summon;
      this.areaSpell = false;
      this.drainAmount = 0;
      player = this.combatants[this.current];
      melee = this.canAttackMelee(player);
      summon = this.canSummon(player);
      this.selectingItemForUse = true;
      return this.gurk.pushView(new SpellView(this.gurk, player.entity, true, melee, summon, player));
    };

    CombatView.prototype.startPlayerUse = function() {
      var melee, player, summon;
      this.areaSpell = false;
      player = this.combatants[this.current];
      melee = this.canAttackMelee(player);
      summon = this.canSummon(player);
      this.selectingItemForUse = true;
      return this.gurk.pushView(new ItemView(this.gurk, player.entity, ItemView.ACTION_USE, true, melee, summon, player));
    };

    CombatView.prototype.startPlayerWield = function() {
      var player;
      player = this.combatants[this.current].entity;
      this.selectingItemForUse = false;
      return this.gurk.pushView(new ItemView(this.gurk, player, ItemView.ACTION_EQUIP, 0, true));
    };

    CombatView.prototype.doPlayerCast = function() {
      var player, square, target;
      player = this.combatants[this.current];
      this.clearActions();
      this.enableMovement();
      switch (this.castingSpell.type) {
        case "teleport":
          this.spellType = CombatView.SPELL_TELEPORT;
          this.select(player.x, player.y, CombatView.SELECT_TARGET);
          if (this.castingSpell.target === "self") {
            this.doSpellCast();
            return;
          } else {
            this.setButton(5, "TARGET");
          }
          break;
        case "heal":
        case "enhance":
          this.spellType = CombatView.SPELL_HEAL;
          this.select(player.x, player.y, CombatView.SELECT_TARGET);
          if (this.castingSpell.target === "self") {
            this.doSpellCast();
            return;
          } else if (this.castingSpell.type === "heal") {
            this.setButton(5, "HEAL");
          } else {
            this.setButton(5, "TARGET");
          }
          break;
        case "damage":
        case "afflict":
        case "drain":
          this.spellType = CombatView.SPELL_DAMAGE;
          target = this.getSuggestedEnemyTarget(player, true);
          this.select(target.x, target.y, CombatView.SELECT_TARGET);
          this.setButton(5, "TARGET");
          break;
        case "summon":
          this.spellType = CombatView.SPELL_SUMMON;
          square = this.getSuggestedSummonSquare(player);
          if (square !== null) {
            this.select(square.x, square.y, CombatView.SELECT_TARGET);
            this.setButton(5, "SUMMON");
          }
      }
      if (this.castingSpell.target === "touch") {
        this.spellTarget = CombatView.SPELL_TARGET_MELEE;
      } else {
        this.spellTarget = CombatView.SPELL_TARGET_RANGE;
      }
      if (this.castingSpell.target === "area") {
        this.areaSpell = true;
      }
      return this.setButton(7, "CANCEL");
    };

    CombatView.prototype.computeSpellTiming = function(combatant, spell) {
      if (spell.fast) {
        if (combatant.halfAttack) {
          combatant.attacksLeft--;
          combatant.movesLeft = 0;
          return combatant.halfAttack = false;
        } else {
          return combatant.halfAttack = true;
        }
      } else {
        combatant.attacksLeft--;
        return combatant.movesLeft = 0;
      }
    };

    CombatView.prototype.doSpellCast = function() {
      var player, square;
      this.clearActions();
      player = this.combatants[this.current];
      if (this.castingSpell.type === "teleport") {
        if (this.teleportTarget) {
          this.selectMode = CombatView.SELECT_TARGETED;
          this.addSound("spell", "Cast Sound");
          this.addAction(this.doSpellResult, "Spell Result Action");
          this.computeSpellTiming(player, this.castingSpell);
          return this.endTurn();
        } else {
          if (this.castingSpell.target === "self") {
            this.teleportTarget = this.combatants[this.current];
          } else {
            this.teleportTarget = this.getCombatant(this.targetX, this.targetY);
          }
          this.spellType = CombatView.SPELL_TELEPORT;
          this.spellTarget = CombatView.SPELL_TARGET_RANGE;
          square = this.getSuggestedSummonSquare(this.teleportTarget);
          if (square === null) {
            square = this.getRandomSquare();
          }
          if (square !== null) {
            this.select(square.x, square.y, CombatView.SELECT_TARGET);
            this.enableMovement();
            this.setButton(5, "TELEPORT");
            return this.setButton(7, "CANCEL");
          }
        }
      } else {
        this.selectMode = CombatView.SELECT_TARGETED;
        this.addSound("spell", "Cast Sound");
        this.queueAnimation(player.x, player.y, Data.icons.animSpellCast, "Spell Cast Animation");
        if (this.castingSpell.target === "range" || this.castingSpell.target === "area") {
          this.queueFly(player.x, player.y, this.targetX, this.targetY, this.castingSpell.animation, "Spell Range Animation");
        }
        this.addAction(this.doSpellResult, "Spell Result Action");
        this.computeSpellTiming(player, this.castingSpell);
        return this.endTurn();
      }
    };

    CombatView.prototype.doSpellResult = function() {
      var amount, bonus, bounds, caster, damage, f, fromItem, isPlayer, spell, target, value, _ref,
        _this = this;
      caster = this.combatants[this.current];
      isPlayer = caster.isPlayer;
      spell = this.castingSpell;
      fromItem = this.usingItem !== null;
      target = this.getCombatant(this.targetX, this.targetY);
      if (fromItem && isPlayer) {
        if (this.usingItem.getCombatSpell() === spell) {
          caster.useCombatSpell(this.usingItem);
        } else if (this.usingItem.isUseable()) {
          this.usingItem.charges--;
          if (this.usingItem.charges === 0) {
            caster.entity.dropItem(this.usingItem);
          }
        }
      } else if (caster.good) {
        caster.entity.spellPoints -= spell.spellPoints;
      }
      switch (spell.type) {
        case "heal":
          if (fromItem) {
            bounds = this.usingItem.getSpellRange();
          } else {
            bounds = caster.entity.getSpellRange(spell);
          }
          if (spell.target === "area") {
            this.doAreaHealing(bounds, spell.healType);
          } else {
            this.addSound("heal", "Heal Sound");
            this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Heal Animation");
            amount = Util.random(bounds.min, bounds.max);
            target.doHeal(amount, spell.healType, this.imageProcessor, this.draw);
            this.updateBanner();
          }
          break;
        case "drain":
          if (fromItem) {
            bounds = this.usingItem.getSpellRange();
          } else {
            bounds = caster.entity.getSpellRange(spell);
          }
          if (this.drainAmount > 0) {
            amount = Math.round(spell.value * this.drainAmount / 100);
            if (amount < 1) {
              amount = 1;
            }
          } else {
            damage = this.resistDamage(caster, target, bounds);
            if (damage === 0) {
              this.doResist(target);
              amount = 0;
            } else {
              this.doDamage(target, damage, Data.icons.animHitSpell);
              amount = Math.round(spell.value * damage / 100);
              if (amount < 1) {
                amount = 1;
              }
            }
          }
          if (amount > 0 && !caster.isFullyHealed()) {
            f = function() {
              _this.addSound("heal", "Drain Sound");
              _this.queueAnimation(caster.x, caster.y, Data.icons.animHeal, "Drain Animation");
              caster.doHeal(amount, "heal", _this.imageProcessor, _this.draw);
              _this.setTarget(caster);
              return _this.updateBanner();
            };
            this.addAction(f, "Drain Heal");
          }
          break;
        case "damage":
          if (fromItem) {
            bounds = this.usingItem.getSpellRange();
          } else {
            bounds = caster.entity.getSpellRange(spell);
          }
          if (spell.target === "area") {
            this.doAreaDamage(bounds);
          } else {
            amount = this.resistDamage(caster, target, bounds);
            if (amount === 0) {
              this.doResist(target);
            } else {
              this.doDamage(target, amount, Data.icons.animHitSpell);
            }
          }
          break;
        case "summon":
          this.addSound("summon", "Summon Sound");
          this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Summon Animation");
          if (fromItem) {
            bonus = this.usingItem.bonus;
          } else {
            if (isPlayer) {
              bonus = Math.ceil(caster.entity.getAttributeBonus(caster.entity.getAwareness()) / 2);
            } else {
              bonus = (_ref = caster.entity.bonus) != null ? _ref : 0;
            }
          }
          this.summonCreature(spell.creature, bonus, caster.good, this.targetX, this.targetY);
          break;
        case "teleport":
          if (!this.areEnemies(caster, this.teleportTarget) || !this.doSavingThrow(caster, this.teleportTarget)) {
            this.teleportTarget.invisible = true;
            this.addSound("tele", "Start Teleport Sound");
            this.queueAnimation(this.teleportTarget.x, this.teleportTarget.y, Data.icons.animHeal, "Teleport Start Animation");
            f = function() {
              _this.moveCombatant(_this.teleportTarget.x, _this.teleportTarget.y, _this.targetX, _this.targetY);
              _this.teleportTarget.invisible = false;
              _this.teleportTarget = null;
              _this.addSound("port", "End Teleport Sound");
              return _this.queueAnimation(_this.targetX, _this.targetY, Data.icons.animHeal, "Teleport Animation");
            };
            this.addAction(f, "Complete Teleportation");
          } else {
            this.showResist(this.teleportTarget);
            this.teleportTarget = null;
          }
          break;
        case "enhance":
        case "afflict":
          if (fromItem) {
            bonus = this.usingItem.bonus;
          } else {
            if (isPlayer) {
              bonus = caster.entity.getAttributeBonus(caster.entity.getAwareness());
            } else {
              bonus = caster.entity.bonus;
            }
          }
          if (spell.target === "area") {
            this.doAreaEffect(spell, 0);
          } else {
            if (!this.areEnemies(caster, target) || !this.doSavingThrow(caster, target)) {
              if (this.areEnemies(caster, target)) {
                this.addSound("afflicted", "Afflict Sound");
              } else {
                this.addSound("enhanced", "Enhance Sound");
              }
              this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Effect Animation");
              value = spell.value;
              target.addEffect(spell.effect, value, Util.random(spell.minAmount, spell.maxAmount), caster);
              f = function() {
                return _this.processIcon(target);
              };
              this.addAction(f, "Show Effect");
            } else {
              this.showResist(target);
            }
          }
      }
      this.castingSpell = null;
      return this.usingItem = null;
    };

    CombatView.prototype.doPlayerAttack = function() {
      var player, target;
      player = this.combatants[this.current];
      if (this.areaAttack) {
        this.addSound("fire", "Area Fire Sound");
        this.queueFly(player.x, player.y, this.targetX, this.targetY, player.getRangeAnimation(), "Area projectile fly");
        this.addAction(this.doAreaAttack, "Run Area Attack");
        this.clearActions();
        this.selectMode = CombatView.SELECT_TARGETED;
        player.didAttack = true;
        player.attacksLeft--;
        player.movesLeft = 0;
        return this.endTurn();
      } else {
        target = this.getCombatant(this.targetX, this.targetY);
        if (target && this.areEnemies(player, target) && this.canAttack(player, target)) {
          player.lastTarget = target;
          this.clearActions();
          this.selectMode = CombatView.SELECT_TARGETED;
          if (!this.isInMeleeRange(player, target) || this.isFiring) {
            this.addSound("fire", "Fire Sound");
            this.queueFly(player.x, player.y, target.x, target.y, player.getRangeAnimation(), "Range projectile fly");
            this.addAction(this.runAttack, "Run Range Attack");
          } else {
            this.addAction(this.runAttack, "Run Melee Attack");
          }
          player.didAttack = true;
          player.attacksLeft--;
          player.movesLeft = 0;
          return this.endTurn();
        }
      }
    };

    CombatView.prototype.runAttack = function() {
      var attacker, target;
      attacker = this.combatants[this.current];
      target = this.getCombatant(this.targetX, this.targetY);
      return this.processAttack(attacker, target);
    };

    CombatView.prototype.processAttack = function(attacker, target, rangeOverride) {
      var ac, bounds, damage, dead, dice, fail, hitRoll, melee, square;
      if (rangeOverride == null) {
        rangeOverride = false;
      }
      melee = this.isInMeleeRange(attacker, target) && !rangeOverride;
      ac = target.getArmorClass();
      if (!melee) {
        ac += this.getRangeACBonus(attacker, target);
      }
      dice = Util.random(1, 20);
      hitRoll = dice + attacker.getToHitBonus();
      if (dice === 20 || (dice !== 1 && hitRoll > target.getArmorClass())) {
        if (melee) {
          bounds = attacker.getMeleeDamageBounds();
        } else {
          bounds = attacker.getRangeDamageBounds();
        }
        damage = Util.random(bounds.min, bounds.max);
        this.drainAmount = Math.min(damage, target.hitPoints);
        dead = this.doDamage(target, damage);
        if (attacker.getHitSpell()) {
          this.castingSpell = attacker.getHitSpell();
          if (attacker.isPlayer) {
            this.usingItem = attacker.entity.getWeapon();
          }
          if (!dead || this.castingSpell.type === "drain") {
            fail = false;
            if (this.castingSpell.type === "teleport") {
              this.teleportTarget = target;
              if (!attacker.good) {
                square = this.getRandomSquare();
                if (!square) {
                  fail = true;
                } else {
                  this.targetX = square.x;
                  this.targetY = square.y;
                }
              }
            }
            if (!fail) {
              return this.addAction(this.doSpellResult, "Do Hit Spell");
            }
          }
        }
      } else {
        this.addSound("miss", "Miss Sound");
        return this.queueAnimation(target.x, target.y, Data.icons.animMiss, "Miss Animation");
      }
    };

    CombatView.prototype.doAreaEffect = function(spell, bonus) {
      var caster, f, value,
        _this = this;
      this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
      caster = this.combatants[this.current];
      value = Math.max(spell.value + bonus, 1);
      f = function() {
        var j, target, x, y, _i, _ref, _ref1, _results;
        _results = [];
        for (y = _i = _ref = _this.targetY - 1, _ref1 = _this.targetY + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
          if (y >= 0 && y < _this.height) {
            _results.push((function() {
              var _j, _ref2, _ref3, _results1,
                _this = this;
              _results1 = [];
              for (x = _j = _ref2 = this.targetX - 1, _ref3 = this.targetX + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
                if (x >= 0 && x < this.width) {
                  target = this.getCombatant(x, y);
                  if (target && (spell.type === "enhance" || target !== caster)) {
                    j = function() {
                      var g, showTarget;
                      showTarget = target;
                      if (!_this.areEnemies(caster, showTarget) || !_this.doSavingThrow(caster, showTarget)) {
                        g = function() {
                          var h;
                          if (_this.areEnemies(caster, showTarget)) {
                            _this.addSound("afflicted", "Area Afflict Sound");
                          } else {
                            _this.addSound("enhanced", "Area Enhance Sound");
                          }
                          _this.queueAnimation(showTarget.x, showTarget.y, Data.icons.animHeal, "Area Effect Animation");
                          showTarget.addEffect(spell.effect, value, Util.random(spell.minAmount, spell.maxAmount), caster);
                          h = function() {
                            _this.processIcon(showTarget);
                            return _this.draw();
                          };
                          return _this.addAction(h, "Do Area Effect Processing");
                        };
                        return _this.addAction(g, "Show Area Target Effect");
                      } else {
                        g = function() {
                          return _this.showResist(showTarget);
                        };
                        return _this.addAction(g, "Show Area Target Resist");
                      }
                    };
                    _results1.push(j());
                  } else {
                    _results1.push(void 0);
                  }
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(_this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      return this.addAction(f, "Show Effect");
    };

    CombatView.prototype.doAreaHealing = function(bounds, healType) {
      var amount, caster, g, target, x, y, _i, _ref, _ref1, _results;
      this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
      caster = this.combatants[this.current];
      _results = [];
      for (y = _i = _ref = this.targetY - 1, _ref1 = this.targetY + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        if (y >= 0 && y < this.height) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1,
              _this = this;
            _results1 = [];
            for (x = _j = _ref2 = this.targetX - 1, _ref3 = this.targetX + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
              if (x >= 0 && x < this.width) {
                target = this.getCombatant(x, y);
                if (target) {
                  amount = Util.random(bounds.min, bounds.max);
                  g = function() {
                    var f, heal, showTarget;
                    showTarget = target;
                    heal = amount;
                    f = function() {
                      return _this.showAreaHealing(showTarget, heal, healType);
                    };
                    return _this.addAction(f, "Do Area Heal");
                  };
                  _results1.push(g());
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CombatView.prototype.doAreaAttack = function() {
      var combatant, g, target, x, y, _i, _ref, _ref1, _results;
      combatant = this.combatants[this.current];
      this.queueBlockAnimation(this.targetX, this.targetY, 1, combatant.getRangeAnimation(), "Area Attack Animation");
      _results = [];
      for (y = _i = _ref = this.targetY - 1, _ref1 = this.targetY + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        if (y >= 0 && y < this.height) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1,
              _this = this;
            _results1 = [];
            for (x = _j = _ref2 = this.targetX - 1, _ref3 = this.targetX + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
              if (x >= 0 && x < this.width) {
                target = this.getCombatant(x, y);
                if (target && target !== combatant) {
                  g = function() {
                    var f, theTarget;
                    theTarget = target;
                    f = function() {
                      _this.targetX = theTarget.x;
                      _this.targetY = theTarget.y;
                      _this.updateBanner();
                      return _this.processAttack(combatant, theTarget, true);
                    };
                    return _this.addAction(f);
                  };
                  _results1.push(g());
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CombatView.prototype.doAreaDamage = function(bounds) {
      var amount, caster, g, target, x, y, _i, _ref, _ref1, _results;
      this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
      caster = this.combatants[this.current];
      _results = [];
      for (y = _i = _ref = this.targetY - 1, _ref1 = this.targetY + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        if (y >= 0 && y < this.height) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1,
              _this = this;
            _results1 = [];
            for (x = _j = _ref2 = this.targetX - 1, _ref3 = this.targetX + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
              if (x >= 0 && x < this.width) {
                target = this.getCombatant(x, y);
                if (target && target !== caster) {
                  amount = this.resistDamage(caster, target, bounds);
                  g = function() {
                    var damage, f, showTarget;
                    showTarget = target;
                    damage = amount;
                    if (damage === 0) {
                      f = function() {
                        return _this.showResist(showTarget);
                      };
                    } else {
                      f = function() {
                        return _this.showAreaDamage(showTarget, damage);
                      };
                    }
                    return _this.addAction(f, "Do Area Damage");
                  };
                  _results1.push(g());
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CombatView.prototype.showAreaHealing = function(target, heal, healType) {
      target.doHeal(heal, healType, this.imageProcessor, this.draw);
      this.targetX = target.x;
      this.targetY = target.y;
      this.updateBanner();
      this.addSound("heal", "Heal Sound");
      return this.queueAnimation(target.x, target.y, Data.icons.animHeal, "Heal Animation");
    };

    CombatView.prototype.showResist = function(target) {
      this.targetX = target.x;
      this.targetY = target.y;
      this.updateBanner();
      this.addSound("resist", "Resist Sound");
      return this.queueAnimation(target.x, target.y, Data.icons.animResist, "Resist Animation");
    };

    CombatView.prototype.showAreaDamage = function(target, damage) {
      var dead;
      dead = target.doDamage(damage);
      this.targetX = target.x;
      this.targetY = target.y;
      this.updateBanner();
      if (dead) {
        if (target.good) {
          this.addSound("dead", "Died Sound");
        } else {
          this.addSound("killed", "Killed Sound");
        }
        this.removeCombatant(target);
      } else {
        this.addSound("hit", "Hit Sound");
      }
      return this.queueAnimation(target.x, target.y, Data.icons.animHitSpell, "Hit Animation");
    };

    CombatView.prototype.doResist = function(target) {
      return this.showResist(target);
    };

    CombatView.prototype.doDamage = function(target, damage, anim) {
      var dead;
      if (anim == null) {
        anim = null;
      }
      dead = target.doDamage(damage);
      this.updateBanner();
      if (dead) {
        if (target.good) {
          this.addSound("died", "Died Sound");
        } else {
          this.addSound("killed", "Killed Sound");
        }
        this.removeCombatant(target);
      } else {
        this.addSound("hit", "Hit Sound");
      }
      if (anim === null) {
        anim = Data.icons.animHit;
      }
      this.queueAnimation(target.x, target.y, anim, "Hit Animation");
      return dead;
    };

    CombatView.prototype.addCreatures = function(creatures) {
      var combatant, creature, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = creatures.length; _i < _len; _i++) {
        creature = creatures[_i];
        combatant = new Combatant(creature, false, false);
        _results.push(this.addCombatant(combatant));
      }
      return _results;
    };

    CombatView.prototype.addPlayers = function() {
      var combatant, index, player, _i, _len, _ref, _results;
      index = 0;
      _ref = this.gurk.game.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.isAlive()) {
          combatant = new Combatant(player, true, true, CombatView.FORMATION[index].x, CombatView.FORMATION[index].y);
          this.addCombatant(combatant);
        }
        _results.push(index++);
      }
      return _results;
    };

    CombatView.prototype.addCombatant = function(combatant) {
      var key, x, y;
      x = combatant.x;
      y = combatant.y;
      key = Game.getKey(x, y);
      while (x === -1 || this.combatMap[key]) {
        x = Util.random(0, 6);
        y = Util.random(0, 3);
        key = Game.getKey(x, y);
      }
      combatant.x = x;
      combatant.y = y;
      this.combatMap[key] = combatant;
      return this.combatants.push(combatant);
    };

    CombatView.prototype.summonCreature = function(name, bonus, good, x, y) {
      var combatant, creature, key, template;
      template = Library.getCreatureByName(name);
      creature = new Creature(template, bonus);
      combatant = new Combatant(creature, false, good, x, y);
      this.combatants.splice(this.current, 0, combatant);
      this.current++;
      key = Game.getKey(x, y);
      return this.combatMap[key] = combatant;
    };

    CombatView.prototype.clearSelection = function() {
      this.selectMode = CombatView.SELECT_OFF;
      this.updateBanner();
      return this.draw();
    };

    CombatView.prototype.select = function(x, y, mode) {
      if (mode === CombatView.SELECT_TARGET) {
        this.targetX = x;
        this.targetY = y;
      } else {
        this.selectX = x;
        this.selectY = y;
      }
      this.selectMode = mode;
      return this.updateBanner();
    };

    CombatView.prototype.getCombatant = function(x, y) {
      var key;
      key = Game.getKey(x, y);
      return this.combatMap[key];
    };

    CombatView.prototype.moveCombatant = function(sx, sy, tx, ty) {
      var combatant, key;
      key = Game.getKey(sx, sy);
      combatant = this.combatMap[key];
      delete this.combatMap[key];
      combatant.x = tx;
      combatant.y = ty;
      key = Game.getKey(tx, ty);
      return this.combatMap[key] = combatant;
    };

    CombatView.prototype.getSurroundingSquares = function(x, y, forEnemy) {
      var squares, xx, yList, yy, _i, _j, _len, _ref, _ref1;
      if (forEnemy == null) {
        forEnemy = false;
      }
      squares = [];
      if (forEnemy) {
        yList = [y + 1, y, y - 1];
      } else {
        yList = [y - 1, y, y + 1];
      }
      for (_i = 0, _len = yList.length; _i < _len; _i++) {
        yy = yList[_i];
        if (yy >= CombatView.TOP_EDGE && yy <= CombatView.BOTTOM_EDGE) {
          for (xx = _j = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; xx = _ref <= _ref1 ? ++_j : --_j) {
            if (xx >= CombatView.LEFT_EDGE && xx <= CombatView.RIGHT_EDGE) {
              if (xx !== x || yy !== y) {
                squares.push({
                  "x": xx,
                  "y": yy
                });
              }
            }
          }
        }
      }
      return squares;
    };

    CombatView.prototype.areEnemies = function(combatantA, combatantB) {
      return combatantA.good !== combatantB.good;
    };

    CombatView.prototype.doSavingThrow = function(caster, defender) {
      var mod, result;
      mod = (defender.getResistance() - caster.getPotency()) * 5 + 5;
      if (mod < 0) {
        mod = 0;
      }
      if (mod > 100) {
        mod = 100;
      }
      result = Util.random(0, 99);
      if (result < 3) {
        return true;
      } else if (result > 96) {
        return false;
      } else {
        return result < mod;
      }
    };

    CombatView.prototype.resistDamage = function(caster, defender, bounds) {
      var mod;
      mod = 100 - (defender.getResistance() - caster.getPotency() - 3) * 5;
      if (mod < 0) {
        mod = 0;
      }
      if (mod > 100) {
        mod = 100;
      }
      bounds.min = Math.round(bounds.min * mod / 100);
      bounds.max = Math.round(bounds.max * mod / 100);
      if (bounds.min < 0) {
        bounds.min = 0;
      }
      if (bounds.max < 0) {
        bounds.max = 0;
      }
      return Util.random(bounds.min, bounds.max);
    };

    CombatView.prototype.canAttackMelee = function(combatant) {
      var other, square, squares, _i, _len;
      squares = this.getSurroundingSquares(combatant.x, combatant.y);
      for (_i = 0, _len = squares.length; _i < _len; _i++) {
        square = squares[_i];
        other = this.getCombatant(square.x, square.y);
        if (other && this.areEnemies(combatant, other)) {
          return true;
        }
      }
      return false;
    };

    CombatView.prototype.canTouchAlly = function(combatant) {
      var other, square, squares, _i, _len;
      squares = this.getSurroundingSquares(combatant.x, combatant.y);
      for (_i = 0, _len = squares.length; _i < _len; _i++) {
        square = squares[_i];
        other = this.getCombatant(square.x, square.y);
        if (other && !this.areEnemies(combatant, other)) {
          return true;
        }
      }
      return false;
    };

    CombatView.prototype.canTargetWithSpell = function(caster, target, isFriendly, isHeal, effect) {
      if (effect == null) {
        effect = null;
      }
      if (isHeal && target.hitPoints === target.getMaxHitPoints()) {
        return false;
      }
      if (isFriendly === this.areEnemies(caster, target)) {
        return false;
      }
      if (effect && target.hasEffect(effect)) {
        return false;
      }
      return true;
    };

    CombatView.prototype.getSpellTargets = function(caster, isRange, isFriendly, isHeal, includeSelf) {
      var square, squares, target, targets, _i, _j, _len, _len1, _ref;
      targets = [];
      if (isRange) {
        _ref = this.combatants;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          target = _ref[_i];
          if (this.canTargetWithSpell(caster, target, isFriendly, isHeal)) {
            targets.push(target);
          }
        }
      } else {
        squares = this.getSurroundingSquares(caster.x, caster.y);
        for (_j = 0, _len1 = squares.length; _j < _len1; _j++) {
          square = squares[_j];
          target = this.getCombatant(square.x, square.y);
          if (target && this.canTargetWithSpell(caster, target, isFriendly, isHeal)) {
            targets.push(target);
          }
        }
      }
      if (includeSelf) {
        if (this.canTargetWithSpell(caster, caster, isFriendly, isHeal)) {
          targets.push(caster);
        }
      }
      return targets;
    };

    CombatView.prototype.hasAllies = function(combatant) {
      var other, _i, _len, _ref;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        other = _ref[_i];
        if (other !== combatant && this.areEnemies(combatant, other)) {
          return true;
        }
      }
      return false;
    };

    CombatView.prototype.getRandomSquare = function() {
      var clear, tries, x, y;
      clear = false;
      tries = 0;
      while (!clear && tries < 10) {
        x = Util.random(CombatView.LEFT_EDGE, CombatView.RIGHT_EDGE);
        y = Util.random(CombatView.TOP_EDGE, CombatView.BOTTOM_EDGE);
        clear = !this.getCombatant(x, y);
        tries++;
      }
      if (clear) {
        return {
          "x": x,
          "y": y
        };
      } else {
        return null;
      }
    };

    CombatView.prototype.getSuggestedSummonSquare = function(combatant) {
      var square, squares, _i, _len;
      squares = this.getSurroundingSquares(combatant.x, combatant.y, !combatant.good);
      for (_i = 0, _len = squares.length; _i < _len; _i++) {
        square = squares[_i];
        if (this.isClear(square.x, square.y)) {
          return square;
        }
      }
      return null;
    };

    CombatView.prototype.canSummon = function(combatant) {
      var square, squares, _i, _len;
      squares = this.getSurroundingSquares(combatant.x, combatant.y);
      for (_i = 0, _len = squares.length; _i < _len; _i++) {
        square = squares[_i];
        if (this.isClear(square.x, square.y)) {
          return true;
        }
      }
      return false;
    };

    CombatView.prototype.isInMeleeRange = function(combatant, target) {
      var dx, dy;
      dx = Math.abs(combatant.x - target.x);
      dy = Math.abs(combatant.y - target.y);
      return dx <= 1 && dy <= 1;
    };

    CombatView.prototype.isInMeleeRangeXY = function(combatant, x, y) {
      var dx, dy;
      dx = Math.abs(combatant.x - x);
      dy = Math.abs(combatant.y - y);
      return dx <= 1 && dy <= 1;
    };

    CombatView.prototype.canAttack = function(combatant, target) {
      if (combatant.canAttackRange()) {
        return true;
      } else {
        return this.isInMeleeRange(combatant, target);
      }
    };

    CombatView.prototype.getRangeACBonus = function(attacker, target) {
      var d;
      d = Math.abs(target.x - attacker.x) + Math.abs(target.y - attacker.y);
      return Math.floor(d / 3);
    };

    CombatView.prototype.getNearestTarget = function(combatant, forceRange) {
      var count, d, distance, nearest, target, _i, _len, _ref;
      if (forceRange == null) {
        forceRange = false;
      }
      nearest = null;
      distance = 100;
      count = 0;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        target = _ref[_i];
        if (target !== combatant && this.areEnemies(combatant, target) && (this.canAttack(combatant, target) || forceRange)) {
          d = Math.abs(target.x - combatant.x) + Math.abs(target.y - combatant.y);
          if (d === distance) {
            count++;
            if (Util.random(1, count) === 1) {
              nearest = target;
            }
          }
          if (d < distance) {
            distance = d;
            nearest = target;
            count = 1;
          }
        }
      }
      return nearest;
    };

    CombatView.prototype.getNearestAttackTarget = function(combatant, forceRange) {
      var count, d, distance, dx, dy, nearest, target, _i, _len, _ref;
      if (forceRange == null) {
        forceRange = false;
      }
      nearest = null;
      distance = 100;
      count = 0;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        target = _ref[_i];
        if (target !== combatant && this.areEnemies(combatant, target) && (this.canAttack(combatant, target) || forceRange)) {
          dx = Math.abs(target.x - combatant.x);
          dy = Math.abs(target.y - combatant.y);
          if (dx <= 1 && dy <= 1) {
            d = 1;
          } else {
            d = dx + dy;
          }
          if (d === distance) {
            count++;
            if (Util.random(1, count) === 1) {
              nearest = target;
            }
          }
          if (d < distance) {
            distance = d;
            nearest = target;
            count = 1;
          }
        }
      }
      return nearest;
    };

    CombatView.prototype.getNearestEnemy = function(combatant) {
      var count, d, distance, nearest, target, _i, _len, _ref;
      nearest = null;
      distance = 100;
      count = 0;
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        target = _ref[_i];
        if (target !== combatant && this.areEnemies(combatant, target)) {
          d = Math.abs(target.x - combatant.x) + Math.abs(target.y - combatant.y);
          if (d === distance) {
            count++;
            if (Util.random(1, count) === 1) {
              nearest = target;
            }
          }
          if (d < distance) {
            distance = d;
            nearest = target;
            count = 1;
          }
        }
      }
      return nearest;
    };

    CombatView.prototype.getRandomEnemy = function(combatant) {
      var enemies, target, _i, _len, _ref;
      enemies = [];
      _ref = this.combatants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        target = _ref[_i];
        if (target !== combatant && this.areEnemies(combatant, target)) {
          enemies.push(target);
        }
      }
      return Util.randomElement(enemies);
    };

    CombatView.prototype.getBestAreaTarget = function(caster, isAttack) {
      var best, bestScore, combatant, score, x, xx, y, yy, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      bestScore = 0;
      best = null;
      for (yy = _i = _ref = CombatView.TOP_EDGE, _ref1 = CombatView.BOTTOM_EDGE; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; yy = _ref <= _ref1 ? ++_i : --_i) {
        for (xx = _j = _ref2 = CombatView.LEFT_EDGE, _ref3 = CombatView.RIGHT_EDGE; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; xx = _ref2 <= _ref3 ? ++_j : --_j) {
          score = 0;
          for (y = _k = _ref4 = yy - 1, _ref5 = yy + 1; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; y = _ref4 <= _ref5 ? ++_k : --_k) {
            for (x = _l = _ref6 = xx - 1, _ref7 = xx + 1; _ref6 <= _ref7 ? _l <= _ref7 : _l >= _ref7; x = _ref6 <= _ref7 ? ++_l : --_l) {
              if (y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE && x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE) {
                combatant = this.getCombatant(x, y);
                if (combatant && (!isAttack || combatant !== caster)) {
                  if (this.areEnemies(caster, combatant) === isAttack) {
                    score += 3;
                  } else {
                    score -= 2;
                  }
                  if (caster === combatant && isAttack) {
                    score = -10000;
                  }
                }
              }
            }
          }
          if (score > bestScore) {
            bestScore = score;
            best = {
              "x": xx,
              "y": yy
            };
          }
        }
      }
      return best;
    };

    CombatView.prototype.removeCombatant = function(combatant) {
      var index, key;
      key = Game.getKey(combatant.x, combatant.y);
      delete this.combatMap[key];
      index = Util.indexOfElement(this.combatants, combatant);
      Util.removeElement(this.combatants, combatant);
      if (index < this.current) {
        return this.current--;
      }
    };

    CombatView.prototype.isStillAlive = function(combatant) {
      return Util.hasElement(this.combatants, combatant);
    };

    CombatView.prototype.setTarget = function(combatant) {
      this.selectMode = CombatView.SELECT_TARGETED;
      this.targetX = combatant.x;
      return this.targetY = combatant.y;
    };

    CombatView.prototype.isClear = function(x, y) {
      if (y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
        if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE) {
          if (!this.getCombatant(x, y)) {
            return true;
          }
        }
      }
      return false;
    };

    CombatView.prototype.canCast = function(combatant) {
      var spell, spells, _i, _len;
      spells = combatant.entity.getSpells();
      for (_i = 0, _len = spells.length; _i < _len; _i++) {
        spell = spells[_i];
        if (spell.spellPoints <= combatant.entity.spellPoints) {
          return true;
        }
      }
      return false;
    };

    CombatView.prototype.canUse = function(combatant, melee, summon) {
      if (combatant.isPlayer) {
        return combatant.entity.hasUsableItem(true, melee, summon, combatant);
      }
    };

    CombatView.prototype.processResult = function(result) {
      var item, player;
      if (result === "debug1") {
        return this.gurk.popView("victory");
      } else if (result === "debug2") {
        this.queueBlockAnimation(4, 4, 1, Data.icons.animHit, "Test Block Animation");
        return this.nextAction();
      } else if (result.spellPoints) {
        this.usingItem = null;
        this.castingSpell = result;
        return this.doPlayerCast();
      } else if ((result === ItemView.NONE || result.template) && !this.selectingItemForUse) {
        item = result;
        player = this.combatants[this.current];
        if (item === ItemView.NONE) {
          player.entity.unequipItemByType(Item.TYPE_WEAPON);
        } else {
          player.entity.equipItem(item);
        }
        player.attacksLeft--;
        player.movesLeft = 0;
        return this.endTurn();
      } else {
        this.usingItem = result;
        this.castingSpell = this.usingItem.getSpell();
        if (!this.castingSpell) {
          this.castingSpell = this.usingItem.getCombatSpell();
        }
        return this.doPlayerCast();
      }
    };

    return CombatView;

  })(TileView);

  BasicStrategy = (function() {

    function BasicStrategy(combat) {
      this.combat = combat;
      this.moveTowards = __bind(this.moveTowards, this);

      this.reselect = __bind(this.reselect, this);

      this.doTurn = __bind(this.doTurn, this);

      this.getCastableSpells = __bind(this.getCastableSpells, this);

    }

    BasicStrategy.prototype.getCastableSpells = function(me) {
      var casts, includeSelf, isFriendly, isHeal, isRange, result, spell, spellInfo, spells, target, targets, _i, _len;
      spells = me.entity.template.spells;
      casts = [];
      if (spells) {
        for (_i = 0, _len = spells.length; _i < _len; _i++) {
          spellInfo = spells[_i];
          spell = Library.getSpellByName(spellInfo.name);
          if (spell.type === "summon") {
            if (this.combat.canSummon(me)) {
              result = {
                "spell": spell,
                "weight": spellInfo.weight,
                "targets": null
              };
              casts.push(result);
            }
          } else {
            isHeal = spell.type === "heal";
            isFriendly = spell.type === "heal" || spell.type === "enhance" || spell.type === "teleport";
            isRange = spell.target === "area" || spell.target === "range";
            includeSelf = spell.type === "heal" || spell.type === "teleport";
            if (spell.target === "self") {
              if (this.combat.canTargetWithSpell(me, me, isFriendly, isHeal, spell.effect)) {
                targets = [me];
              } else {
                targets = [];
              }
            } else if (spell.target === "area") {
              target = this.combat.getBestAreaTarget(me, !isFriendly);
              if (target) {
                targets = [target];
              }
            } else {
              targets = this.combat.getSpellTargets(me, isRange, isFriendly, isHeal);
            }
            if (targets.length > 0) {
              result = {
                "spell": spell,
                "weight": spellInfo.weight,
                "targets": targets
              };
              casts.push(result);
            }
          }
        }
      }
      return casts;
    };

    BasicStrategy.prototype.doTurn = function(me, numMoves, numAttacks) {
      var attackWeight, canAttackArea, canAttackMelee, canAttackRange, cast, casts, couldCast, destination, didAction, enemy, f, g, k, moveWeight, nearest, spell, target, totalWeight, _i, _j, _len, _len1, _ref, _ref1, _ref2,
        _this = this;
      this.combat.clearSelection();
      this.combat.usingItem = null;
      casts = this.getCastableSpells(me);
      canAttackMelee = this.combat.canAttackMelee(me);
      canAttackRange = me.canAttackRange();
      canAttackArea = me.canAttackArea();
      if (canAttackMelee) {
        moveWeight = 0;
        attackWeight = (_ref = me.entity.template.attackWeight) != null ? _ref : 75;
      } else {
        moveWeight = (_ref1 = me.entity.template.moveWeight) != null ? _ref1 : 25;
        if (canAttackRange) {
          attackWeight = (_ref2 = me.entity.template.attackWeight) != null ? _ref2 : 75;
        } else {
          attackWeight = 0;
        }
      }
      if (numAttacks === 0) {
        attackWeight = 0;
      }
      if (numMoves === 0) {
        moveWeight = 0;
      }
      totalWeight = attackWeight + moveWeight;
      for (_i = 0, _len = casts.length; _i < _len; _i++) {
        cast = casts[_i];
        totalWeight += cast.weight;
      }
      k = Util.random(0, totalWeight - 1);
      didAction = false;
      if (k < attackWeight) {
        if (canAttackArea) {
          target = this.combat.getBestAreaTarget(me, true);
          if (target) {
            numMoves = 0;
            numAttacks--;
            me.didAttack = true;
            this.combat.setTarget(target);
            this.combat.queueFly(me.x, me.y, target.x, target.y, me.getRangeAnimation(), "AI Area Projectile Fly");
            this.combat.addAction(this.combat.doAreaAttack, "Run AI Area Attack");
            didAction = true;
          }
        } else {
          nearest = this.combat.getNearestAttackTarget(me);
          if (me.lastTarget && this.combat.isStillAlive(me.lastTarget) && this.combat.canAttack(me, me.lastTarget)) {
            target = me.lastTarget;
          } else {
            if (canAttackRange) {
              target = this.combat.getRandomEnemy(me);
            } else {
              target = this.combat.getNearestAttackTarget(me);
            }
          }
          if (this.combat.isInMeleeRange(me, nearest) && !this.combat.isInMeleeRange(me, target)) {
            target = nearest;
          }
          me.lastTarget = target;
          numMoves = 0;
          numAttacks--;
          me.didAttack = true;
          this.combat.setTarget(target);
          if (canAttackMelee) {
            this.combat.addAction(this.combat.runAttack, "Run AI Melee Attack");
          } else if (canAttackRange) {
            this.combat.queueFly(me.x, me.y, target.x, target.y, me.getRangeAnimation(), "AI Projectile Fly");
            this.combat.addAction(this.combat.runAttack, "Run AI Range Attack");
          }
          didAction = true;
        }
      } else {
        k -= attackWeight;
      }
      if (!didAction && k < moveWeight) {
        target = this.combat.getNearestEnemy(me);
        numMoves--;
        if (numMoves === 0) {
          numAttacks = 0;
        }
        f = function() {
          return _this.moveTowards(me, target);
        };
        this.combat.addAction(f, "Do Move");
        didAction = true;
      } else {
        k -= moveWeight;
      }
      if (!didAction) {
        for (_j = 0, _len1 = casts.length; _j < _len1; _j++) {
          cast = casts[_j];
          if (!didAction && k < cast.weight) {
            couldCast = true;
            spell = cast.spell;
            this.combat.castingSpell = spell;
            if (spell.type === "summon") {
              target = this.combat.getSuggestedSummonSquare(me);
              if (target !== null) {
                this.combat.targetX = target.x;
                this.combat.targetY = target.y;
              }
            } else {
              target = Util.randomElement(cast.targets);
              if (spell.type === "teleport") {
                enemy = this.combat.getRandomEnemy(me);
                destination = this.combat.getSuggestedSummonSquare(enemy);
                if (destination === null) {
                  destination = this.combat.getRandomSquare();
                  if (destination === null) {
                    couldCast = false;
                  }
                }
                if (destination !== null) {
                  this.combat.teleportTarget = target;
                  this.combat.targetX = destination.x;
                  this.combat.targetY = destination.y;
                }
              } else {
                this.combat.targetX = target.x;
                this.combat.targetY = target.y;
              }
            }
            if (couldCast) {
              this.combat.addSound("spell", "AI Cast Sound");
              this.combat.queueAnimation(me.x, me.y, Data.icons.animSpellCast, "Enemy Cast Animation");
              if (spell.target === "range" || spell.target === "area") {
                this.combat.queueFly(me.x, me.y, target.x, target.y, spell.animation, "Enemy Spell Range Animation");
              }
              if (spell.fast) {
                if (me.halfAttack) {
                  numMoves = 0;
                  numAttacks--;
                  me.halfAttack = false;
                } else {
                  me.halfAttack = true;
                }
              } else {
                numMoves = 0;
                numAttacks--;
              }
              this.combat.selectMode = CombatView.SELECT_TARGETED;
              f = function() {
                return _this.combat.doSpellResult();
              };
              this.combat.addAction(f, "Do Enemy Spell Result");
              didAction = true;
            }
          } else {
            k -= cast.weight;
          }
        }
      }
      if (!didAction) {
        numMoves = 0;
        numAttacks = 0;
      }
      if (numMoves === 0 && numAttacks === 0) {
        this.combat.endTurn();
      } else {
        g = function() {
          return _this.reselect(me);
        };
        this.combat.addAction(g, "AI Reselect");
        this.combat.addPause("AI Action Pause");
        f = function() {
          return _this.doTurn(me, numMoves, numAttacks);
        };
        this.combat.addAction(f, "AI Turn Continuation");
      }
    };

    BasicStrategy.prototype.reselect = function(me) {
      return this.combat.select(me.x, me.y, CombatView.SELECT_ACTIVE);
    };

    BasicStrategy.prototype.moveTowards = function(me, target) {
      var dx, dy, moved, sx, sy;
      dx = target.x - me.x;
      dy = target.y - me.y;
      sx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
      sy = dy > 0 ? 1 : dy < 0 ? -1 : 0;
      moved = false;
      if (Math.abs(dy) >= Math.abs(dx)) {
        if (this.combat.isClear(me.x, me.y + sy)) {
          this.combat.moveCombatant(me.x, me.y, me.x, me.y + sy);
          moved = true;
        } else if (this.combat.isClear(me.x + sx, me.y)) {
          this.combat.moveCombatant(me.x, me.y, me.x + sx, me.y);
          moved = true;
        }
      } else {
        if (this.combat.isClear(me.x + sx, me.y)) {
          this.combat.moveCombatant(me.x, me.y, me.x + sx, me.y);
          moved = true;
        } else if (this.combat.isClear(me.x, me.y + sy)) {
          this.combat.moveCombatant(me.x, me.y, me.x, me.y + sy);
          moved = true;
        }
      }
      if (moved) {
        this.combat.addSound("move", "AI Move Sound");
      }
      return this.combat.draw();
    };

    return BasicStrategy;

  })();

  Test = (function() {

    function Test() {}

    Test.assert = function(condition, failDescription) {
      if (!condition) {
        return console.log("ASSERTION FAILED: " + failDescription);
      }
    };

    Test.run = function() {
      var damage, leatherArmor, rugnar, shortSword, shortSwordTemplate;
      console.log("--- TESTING START ---");
      shortSwordTemplate = Library.getItemTemplateByName("Short Sword");
      Test.assert(shortSwordTemplate, "Short sword template not found by name");
      shortSword = new Item(shortSwordTemplate, 100, 2);
      Test.assert(shortSword.name === "Short Sword +2", "Short Sword name is wrong.");
      Test.assert(shortSword.getMeleeMinDamage() === 3, "Short Sword melee min damage is wrong.");
      Test.assert(shortSword.getMeleeMaxDamage() === 7, "Short Sword melee max damage is wrong.");
      Test.assert(shortSword.getToHitBonus() === 2, "Short Sword to hit bonus is wrong.");
      Test.assert(shortSword.getArmorClass() === 0, "Short Sword should have 0 AC.");
      leatherArmor = new Item(Library.getItemTemplateByName("Leather Armor"), 101, -1);
      Test.assert(leatherArmor.getArmorClass() === 1, "Leather Armor -1 should have 1 AC");
      rugnar = new Player(Data.characters[0]);
      Test.assert(rugnar.strength >= rugnar.accuracy, "Strength is not greatest attribute.");
      Test.assert(rugnar.strength >= rugnar.awareness, "Strength is not greatest attribute.");
      Test.assert(rugnar.strength >= rugnar.constitution, "Strength is not greatest attribute.");
      Test.assert(rugnar.maxHitPoints > 0, "Max hit points not positive.");
      Test.assert(rugnar.hitPoints === rugnar.maxHitPoints, "Hit points not equal to max hit points.");
      rugnar.strength = 18;
      Test.assert(rugnar.getAttributeBonus(rugnar.strength) === 3, "Strength bonus incorrect.");
      damage = rugnar.getMeleeDamageBounds();
      Test.assert(damage.min === 1 + 3, "Min damage is wrong");
      Test.assert(damage.max === 1 + 3, "Max damage is wrong");
      rugnar.addItem(shortSword);
      rugnar.equipItem(shortSword);
      damage = rugnar.getMeleeDamageBounds();
      Test.assert(damage.min === 1 + 2 + 3, "Min damage is wrong");
      Test.assert(damage.max === 5 + 2 + 3, "Max damage is wrong");
      rugnar.addItem(leatherArmor);
      rugnar.equipItem(leatherArmor);
      rugnar.awareness = 14;
      Test.assert(rugnar.getArmorClass() === 1 + 1, "Rugnar armor class is wrong.");
      rugnar.unequipItem(leatherArmor);
      Test.assert(rugnar.getArmorClass() === 0 + 1, "Rugnar armor class is wrong after unequip.");
      rugnar.dropItem(leatherArmor);
      Test.assert(rugnar.items.length === 1, "Rugnar should have 1 item.");
      return console.log("--- TESTING COMPLETED ---");
    };

    return Test;

  }).call(this);

  Validate = (function() {

    function Validate() {}

    Validate.require = function(object, item, name) {
      if (!object.hasOwnProperty(item)) {
        return console.log("" + name + " is missing '" + item + "'.");
      }
    };

    Validate.run = function() {
      var creature, feature, idSet, item, location, locationSet, map, name, spell, spellSet, target, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      console.log("--- VALIDATING ...");
      console.log("-- SPELLS");
      _ref = Data.spells;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spell = _ref[_i];
        if (spell.type === "summon") {
          if (!spell.creature) {
            console.log(" No creature for summon spell " + spell.name + ".");
          } else if (!Library.getCreatureByName(spell.creature)) {
            console.log(" Creature for summon spell " + spell.name + " not found: '" + spell.creature + "'.");
          }
        }
        if ((spell.target === "range" || spell.target === "area") && !spell.animation) {
          console.log(" Animation missing for spell " + spell.name);
        }
      }
      console.log("-- CREATURES");
      spellSet = {};
      _ref1 = Data.creatures;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        creature = _ref1[_j];
        Validate.require(creature, "icon", creature.name);
        Validate.require(creature, "groups", creature.name);
        Validate.require(creature, "meleeMinDamage", creature.name);
        Validate.require(creature, "meleeMaxDamage", creature.name);
        Validate.require(creature, "level", creature.name);
        Validate.require(creature, "minHitPoints", creature.name);
        Validate.require(creature, "maxHitPoints", creature.name);
        Validate.require(creature, "experienceValue", creature.name);
        Validate.require(creature, "numAttacks", creature.name);
        Validate.require(creature, "numMoves", creature.name);
        Validate.require(creature, "armorClass", creature.name);
        Validate.require(creature, "description", creature.name);
        if (creature.rangeMinDamage && !creature.rangeAnimation) {
          console.log(" No range animation for " + creature.name + ".");
        }
        if (creature.hitSpell && !Library.getSpellByName(creature.hitSpell)) {
          console.log(" Missing hit spell " + creature.hitSpell + " for " + creature.name + ".");
        }
        if (creature.hitSpell) {
          spellSet[creature.hitSpell] = true;
        }
        if (creature.spells) {
          _ref2 = creature.spells;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            spell = _ref2[_k];
            if (!Library.getSpellByName(spell.name)) {
              console.log(" Missing spell " + spell.name + " for " + creature.name + ".");
            } else {
              spellSet[spell.name] = true;
            }
          }
        }
      }
      console.log("-- ITEMS");
      _ref3 = Data.items;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        item = _ref3[_l];
        Validate.require(item, "icon", item.name);
        Validate.require(item, "type", item.name);
        Validate.require(item, "groups", item.name);
        Validate.require(item, "rarity", item.name);
        Validate.require(item, "baseValue", item.name);
        Validate.require(item, "level", item.name);
        Validate.require(item, "usedBy", item.name);
        if (item.rangeMinDamage && !item.rangeAnimation) {
          console.log(" No range animation for " + item.name + ".");
        }
        if (item.spell && !Library.getSpellByName(item.spell)) {
          console.log(" Missing spell " + item.spell + " for " + item.name + ".");
        }
        if (item.hitSpell && !Library.getSpellByName(item.hitSpell)) {
          console.log(" Missing hit spell " + item.hitSpell + " for " + item.name + ".");
        }
        if (item.combatSpell && !Library.getSpellByName(item.combatSpell)) {
          console.log(" Missing combat spell " + item.combatSpell + " for " + item.name + ".");
        }
        if (item.spell) {
          spellSet[item.spell] = true;
        }
        if (item.hitSpell) {
          spellSet[item.hitSpell] = true;
        }
        if (item.combatSpell) {
          spellSet[item.combatSpell] = true;
        }
      }
      console.log("-- MAPS");
      idSet = {};
      locationSet = {};
      _ref4 = Data.maps;
      for (name in _ref4) {
        map = _ref4[name];
        if (map.encounterChance && map.encounterChance > 0 && !map.combatMap) {
          console.log(" Missing combat map for " + name + ".");
        }
        if (map.features) {
          _ref5 = map.features;
          for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
            feature = _ref5[_m];
            if (feature.type === "transition") {
              if (!feature.target) {
                console.log(" Missing transition target in " + name + ".");
              } else if (!Data.maps[feature.target]) {
                console.log(" Transition target " + feature.target + " not found in " + name + ".");
              } else {
                target = Data.maps[feature.target];
                if (feature.targetX >= target.width || feature.targetY >= target.height) {
                  console.log(" Transition target location is not valid in " + feature.target + " for " + name + ".");
                }
              }
            } else if (feature.type === "encounter") {
              location = name + "-" + feature.x + "-" + feature.y;
              if (locationSet[location]) {
                console.log(" More than one encounter at '" + name + " : " + feature.x + ", " + feature.y + "'.");
              } else {
                locationSet[location] = true;
              }
              if (idSet[feature.id]) {
                console.log(" More than one encounter with id '" + feature.id + "'.");
              } else {
                idSet[feature.id] = true;
              }
              if (feature.creatures) {
                _ref6 = feature.creatures;
                for (_n = 0, _len5 = _ref6.length; _n < _len5; _n++) {
                  creature = _ref6[_n];
                  if (!Library.getCreatureByName(creature.name)) {
                    console.log(" Creature " + creature.name + " not found in " + name + ".");
                  }
                }
              }
              if (feature.items) {
                _ref7 = feature.items;
                for (_o = 0, _len6 = _ref7.length; _o < _len6; _o++) {
                  item = _ref7[_o];
                  if (!Library.getItemTemplateByName(item.name)) {
                    console.log(" Item " + item.name + " not found in " + name + ".");
                  }
                }
              }
            }
          }
        }
      }
      _ref8 = Data.spells;
      for (_p = 0, _len7 = _ref8.length; _p < _len7; _p++) {
        spell = _ref8[_p];
        if (!spellSet[spell.name] && !spell.who) {
          console.log(" Unused spell: " + spell.name);
        }
      }
      return console.log("--- VALIDATION COMPLETE.");
    };

    return Validate;

  })();

  SettingsView = (function(_super) {

    __extends(SettingsView, _super);

    function SettingsView(gurk) {
      this.itemSelected = __bind(this.itemSelected, this);

      this.doLayout = __bind(this.doLayout, this);
      SettingsView.__super__.constructor.call(this, gurk, "TOGGLE", "DONE");
    }

    SettingsView.prototype.doLayout = function() {
      var combatMusic, fast, music, sound, y;
      this.clear();
      y = 3;
      this.addLabelCentered("Settings", "#FFF", 0, y, 128, Screen.FONT.fontHeight);
      y += 12;
      music = this.gurk.getMusicSetting() ? "ON" : "OFF";
      combatMusic = this.gurk.getCombatMusicSetting() ? "ON" : "OFF";
      sound = this.gurk.getSoundSetting() ? "ON" : "OFF";
      fast = this.gurk.getFastSetting() ? "ON" : "OFF";
      this.addOption("Music is " + music, "#FFF", 8, y);
      y += 8;
      this.addOption("Combat music is " + combatMusic, "#FFF", 8, y);
      y += 8;
      this.addOption("Sound FX are " + sound, "#FFF", 8, y);
      y += 8;
      this.addOption("Fast combat is " + fast, "#FFF", 8, y);
      return this.start();
    };

    SettingsView.prototype.itemSelected = function(index, item) {
      if (index === 0) {
        this.gurk.setMusicSetting(!this.gurk.getMusicSetting());
      } else if (index === 1) {
        this.gurk.setCombatMusicSetting(!this.gurk.getCombatMusicSetting());
      } else if (index === 2) {
        this.gurk.setSoundSetting(!this.gurk.getSoundSetting());
      } else if (index === 3) {
        this.gurk.setFastSetting(!this.gurk.getFastSetting());
      }
      this.doLayout();
      return this.draw();
    };

    return SettingsView;

  })(SelectView);

  Gurk = (function() {

    Gurk.prototype.stack = null;

    Gurk.prototype.view = null;

    Gurk.prototype.screen = null;

    Gurk.prototype.buttonGrid = null;

    Gurk.prototype.game = null;

    Gurk.prototype.imageProcessor = null;

    Gurk.prototype.music = null;

    Gurk.prototype.startSavedGame = function() {
      var mapView;
      this.game = new Game();
      this.game.loadGame(Device.loadGame());
      mapView = new MapView(this);
      return this.setView(mapView);
    };

    Gurk.prototype.getSoundSetting = function() {
      return Device.getSetting("sound", true);
    };

    Gurk.prototype.setSoundSetting = function(value) {
      return Device.setSetting("sound", value);
    };

    Gurk.prototype.getMusicSetting = function() {
      return Device.getSetting("music", true);
    };

    Gurk.prototype.setMusicSetting = function(value) {
      Device.setSetting("music", value);
      if (value) {
        return this.resumeMusic();
      } else {
        return this.stopMusic();
      }
    };

    Gurk.prototype.getCombatMusicSetting = function() {
      return Device.getSetting("combatMusic", true);
    };

    Gurk.prototype.setCombatMusicSetting = function(value) {
      return Device.setSetting("combatMusic", value);
    };

    Gurk.prototype.getFastSetting = function() {
      return Device.getSetting("fast", false);
    };

    Gurk.prototype.setFastSetting = function(value) {
      return Device.setSetting("fast", value);
    };

    Gurk.prototype.startNewGame = function(game) {
      var club, mapView, shortStaff, sling;
      this.game = game;
      club = this.game.createItem(Library.getItemTemplateByName("Crude Club"));
      sling = this.game.createItem(Library.getItemTemplateByName("Sling"));
      shortStaff = this.game.createItem(Library.getItemTemplateByName("Short Staff"));
      this.game.players[0].addItem(club);
      this.game.players[0].equipItem(club);
      this.game.players[1].addItem(sling);
      this.game.players[1].equipItem(sling);
      this.game.players[2].addItem(shortStaff);
      this.game.players[2].equipItem(shortStaff);
      /*
          bloodSword = @game.createItem(Library.getItemTemplateByName("Bloodsword"))
          @game.players[0].addItem(bloodSword)
          @game.players[0].equipItem(bloodSword)
          @game.gold = 20000
          @game.players[2].maxSpellPoints = 50;
          wandOfFire = @game.createItem(Library.getItemTemplateByName("Hydrosword"))
          @game.players[0].addItem(wandOfFire)
      
          for i in [0 ... 3]
            @game.players[i].maxHitPoints = 100;
            @game.players[i].maxSpellPoints = 100;
            @game.players[i].level = 10;
            @game.players[i].strength += 10;
            @game.players[i].accuracy += 10;
            @game.players[i].awareness += 10;
            @game.players[i].constitution += 10;
            @game.players[i].experience = 30000;
      
          @game.transitionTo("shuunia", 13, 7)
      */

      mapView = new MapView(this);
      return this.setView(mapView);
    };

    Gurk.prototype.startTestGame = function() {
      var bowOfFortune, healingSalve, heavyAxe, leatherArmor, leatherBoots, leatherBoots2, mapView, ranger, serpentSword, shortBow, shortSword, shortSword2, shortSword3, speedBoots, wandOfBlessing, wandOfBlessing2, wandOfStriking, warrior, wizard;
      this.game = new Game();
      warrior = new Player(Data.characters[0]);
      shortSword = this.game.createItem(Library.getItemTemplateByName("Short Sword"), 1);
      serpentSword = this.game.createItem(Library.getItemTemplateByName("Serpentongue"));
      shortSword2 = this.game.createItem(Library.getItemTemplateByName("Short Sword"), 2);
      shortSword3 = this.game.createItem(Library.getItemTemplateByName("Short Sword"), -1);
      heavyAxe = this.game.createItem(Library.getItemTemplateByName("Heavy Axe"));
      leatherArmor = this.game.createItem(Library.getItemTemplateByName("Leather Armor"), 1);
      leatherBoots = this.game.createItem(Library.getItemTemplateByName("Leather Boots"), 0);
      healingSalve = this.game.createItem(Library.getItemTemplateByName("Healing Salve"), 1, 3);
      wandOfBlessing = this.game.createItem(Library.getItemTemplateByName("Wand of Blessing"), 0, 2);
      wandOfBlessing2 = this.game.createItem(Library.getItemTemplateByName("Wand of Blessing"), 0, 2);
      wandOfStriking = this.game.createItem(Library.getItemTemplateByName("Wand of Striking"), 1, 2);
      warrior.addItem(serpentSword);
      warrior.addItem(shortSword);
      warrior.addItem(shortSword2);
      warrior.addItem(shortSword3);
      warrior.addItem(leatherArmor);
      warrior.addItem(heavyAxe);
      warrior.addItem(leatherBoots);
      warrior.addItem(wandOfBlessing);
      warrior.addItem(healingSalve);
      warrior.addItem(wandOfStriking);
      warrior.equipItem(serpentSword);
      warrior.equipItem(leatherArmor);
      warrior.equipItem(leatherBoots);
      warrior.hitPoints = 1;
      warrior.experience = 49;
      ranger = new Player(Data.characters[1]);
      shortBow = this.game.createItem(Library.getItemTemplateByName("Short Bow"), 1);
      bowOfFortune = this.game.createItem(Library.getItemTemplateByName("Bow of Fortune"));
      speedBoots = this.game.createItem(Library.getItemTemplateByName("Speed Boots"), 0);
      leatherBoots2 = this.game.createItem(Library.getItemTemplateByName("Leather Boots"), 0);
      ranger.addItem(shortBow);
      ranger.addItem(bowOfFortune);
      ranger.equipItem(bowOfFortune);
      ranger.addItem(leatherBoots2);
      ranger.addItem(speedBoots);
      ranger.equipItem(speedBoots);
      wizard = new Player(Data.characters[2]);
      wizard.level = 2;
      wizard.maxSpellPoints = 20;
      wizard.spellPoints = 20;
      wizard.experience = 119;
      wizard.addItem(wandOfBlessing2);
      this.game.addPlayer(warrior);
      this.game.addPlayer(ranger);
      this.game.addPlayer(wizard);
      this.game.buildFeatures();
      mapView = new MapView(this);
      return this.setView(mapView);
    };

    Gurk.prototype.playSound = function(sound) {
      if (this.getSoundSetting()) {
        return playAudio(sound);
      }
    };

    Gurk.prototype.playMusic = function(track) {
      this.music = track;
      console.log("Music setting: '" + this.getMusicSetting() + "'.");
      if (this.getMusicSetting()) {
        console.log("Play track '" + track + "'.");
        return playTrack(track);
      }
    };

    Gurk.prototype.playCombatMusic = function() {
      if (this.getCombatMusicSetting()) {
        return playTrack(Data.combatMusic);
      }
    };

    Gurk.prototype.stopMusic = function() {
      return stopTrack();
    };

    Gurk.prototype.resumeMusic = function() {
      if (this.music) {
        return this.playMusic(this.music);
      }
    };

    Gurk.prototype.start = function() {
      var canvasWork, clickHandler, ctx, ctxControl, ctxWork, splashView,
        _this = this;
      console.log("Get contexts");
      ctx = document.getElementById("screenID").getContext("2d");
      ctxControl = document.getElementById("controlID").getContext("2d");
      canvasWork = document.getElementById("workID");
      ctxWork = canvasWork.getContext("2d");
      this.stack = new Array();
      this.screen = new Screen(ctx);
      this.buttonGrid = new ButtonGrid(ctxControl, this);
      this.imageProcessor = new ImageProcessor(canvasWork, ctxWork, this.screen.icons);
      splashView = new SplashView(this);
      this.setView(splashView);
      console.log("Set splash view");
      this.playMusic(Data.splashMusic);
      clickHandler = function(e) {
        switch (e.keyCode) {
          case 37:
            return _this.buttonGrid.forceClick(4);
          case 38:
            return _this.buttonGrid.forceClick(2);
          case 39:
            return _this.buttonGrid.forceClick(6);
          case 40:
            return _this.buttonGrid.forceClick(8);
          case 13:
            return _this.buttonGrid.forceClick(5);
          case 81:
            return _this.buttonGrid.forceClick(1);
          case 87:
            return _this.buttonGrid.forceClick(2);
          case 69:
            return _this.buttonGrid.forceClick(3);
          case 65:
            return _this.buttonGrid.forceClick(4);
          case 83:
            return _this.buttonGrid.forceClick(5);
          case 68:
            return _this.buttonGrid.forceClick(6);
          case 90:
            return _this.buttonGrid.forceClick(7);
          case 88:
            return _this.buttonGrid.forceClick(8);
          case 67:
            return _this.buttonGrid.forceClick(9);
          case 96:
            return _this.buttonGrid.forceClick(5);
          case 97:
            return _this.buttonGrid.forceClick(7);
          case 98:
            return _this.buttonGrid.forceClick(8);
          case 99:
            return _this.buttonGrid.forceClick(9);
          case 100:
            return _this.buttonGrid.forceClick(4);
          case 101:
            return _this.buttonGrid.forceClick(5);
          case 102:
            return _this.buttonGrid.forceClick(6);
          case 103:
            return _this.buttonGrid.forceClick(1);
          case 104:
            return _this.buttonGrid.forceClick(2);
          case 105:
            return _this.buttonGrid.forceClick(3);
          case 71:
            return _this.view.processResult("debug1");
          case 72:
            return _this.view.processResult("debug2");
        }
      };
      window.addEventListener('keydown', clickHandler);
      return this.buttonGrid.draw();
    };

    Gurk.prototype.phoneClick = function(e, offsetX, offsetY) {
      var point;
      if (offsetX == null) {
        offsetX = 0;
      }
      if (offsetY == null) {
        offsetY = 0;
      }
      point = document.getElementById("controlID").relMouseCoords(e);
      point.x -= offsetX;
      point.y -= offsetY;
      return this.buttonGrid.clicked(point);
    };

    function Gurk() {
      this.isCurrentView = __bind(this.isCurrentView, this);

      this.showConfirm = __bind(this.showConfirm, this);

      this.showAlert = __bind(this.showAlert, this);

      this.buttonPressed = __bind(this.buttonPressed, this);

      this.popToTopView = __bind(this.popToTopView, this);

      this.swapView = __bind(this.swapView, this);

      this.popView = __bind(this.popView, this);

      this.pushView = __bind(this.pushView, this);

      this.showView = __bind(this.showView, this);

      this.showSettings = __bind(this.showSettings, this);

      this.setView = __bind(this.setView, this);

      this.getScreen = __bind(this.getScreen, this);

      this.phoneClick = __bind(this.phoneClick, this);

      this.start = __bind(this.start, this);

      this.resumeMusic = __bind(this.resumeMusic, this);

      this.stopMusic = __bind(this.stopMusic, this);

      this.playCombatMusic = __bind(this.playCombatMusic, this);

      this.playMusic = __bind(this.playMusic, this);

      this.playSound = __bind(this.playSound, this);

      this.startTestGame = __bind(this.startTestGame, this);

      this.startNewGame = __bind(this.startNewGame, this);

      this.setFastSetting = __bind(this.setFastSetting, this);

      this.getFastSetting = __bind(this.getFastSetting, this);

      this.setCombatMusicSetting = __bind(this.setCombatMusicSetting, this);

      this.getCombatMusicSetting = __bind(this.getCombatMusicSetting, this);

      this.setMusicSetting = __bind(this.setMusicSetting, this);

      this.getMusicSetting = __bind(this.getMusicSetting, this);

      this.setSoundSetting = __bind(this.setSoundSetting, this);

      this.getSoundSetting = __bind(this.getSoundSetting, this);

      this.startSavedGame = __bind(this.startSavedGame, this);
      console.log("Preloading..., scale is " + Screen.SCALE);
      Preloader.load("icons0-" + Screen.SCALE + ".png");
      Preloader.load("icons1-" + Screen.SCALE + ".png");
      Preloader.load("screen" + Screen.SCALE + ".png");
      Preloader.load("font_micro" + Screen.SCALE + ".png");
      Preloader.load("font_gurkoid" + Screen.SCALE + ".png");
      Preloader.load("button" + Screen.SCALE + ".png");
      Preloader.load("buttonoff" + Screen.SCALE + ".png");
      Preloader.load("buttontop" + Screen.SCALE + ".png");
      Preloader.load("shadow" + Screen.SCALE + ".png");
      console.log("Preloading started...");
      Preloader.setCallback(this.start);
    }

    Gurk.prototype.getScreen = function() {
      return this.screen;
    };

    Gurk.prototype.setView = function(view) {
      console.log("Set View: " + view);
      this.stack = new Array();
      this.view = view;
      return this.showView();
    };

    Gurk.prototype.showSettings = function() {
      return this.pushView(new SettingsView(this));
    };

    Gurk.prototype.showView = function() {
      console.log("View: " + this.view.name);
      this.view.doLayout();
      this.view.setButtons(this.buttonGrid);
      return this.view.draw();
    };

    Gurk.prototype.pushView = function(view) {
      this.stack.unshift(this.view);
      this.view = view;
      return this.showView();
    };

    Gurk.prototype.popView = function(result) {
      var parent;
      parent = this.stack.shift();
      if (parent !== null) {
        this.view = parent;
        if (result !== null) {
          this.view.processResult(result);
        }
        return this.showView();
      }
    };

    Gurk.prototype.swapView = function(result) {
      this.view = view;
      if (result !== null) {
        this.view.processResult(result);
      }
      return this.showView();
    };

    Gurk.prototype.popToTopView = function(result) {
      if (this.stack.length > 0) {
        this.view = this.stack.shift();
        while (this.stack.length > 0) {
          this.view = this.stack.shift();
        }
        if (result !== null) {
          this.view.processResult(result);
        }
        return this.showView();
      }
    };

    Gurk.prototype.buttonPressed = function(text) {
      return this.view.command(text);
    };

    Gurk.prototype.showAlert = function(icon, title, text, result) {
      var alert;
      alert = new AlertView(this, icon, title, text, result);
      return this.pushView(alert);
    };

    Gurk.prototype.showConfirm = function(icon, title, text, yesResult, noResult) {
      var confirm;
      confirm = new ConfirmView(this, icon, title, text, yesResult, noResult);
      return this.pushView(confirm);
    };

    Gurk.prototype.isCurrentView = function(view) {
      return this.view === view;
    };

    return Gurk;

  })();

  App = {};

  window.App = App;

  App.init = function(platform) {
    console.log('App init...');
    
  /*
  function relMouseCoords(event){
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var currentElement = this;

    do{
        totalOffsetX += currentElement.offsetLeft;
        totalOffsetY += currentElement.offsetTop;
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    return {x:canvasX, y:canvasY}
  }
  */
  function relMouseCoords(event) {
    //console.log("event.pageY: " + event.pageY + ", this.offsetTop: " + this.offsetTop);
    var x;
    var y;
    if ("ios" == platform) {
      x = event.pageX * 2 - this.offsetLeft;
      y = event.pageY * 2 - this.offsetTop;
    } else {
      x = event.pageX - this.offsetLeft;
      y = event.pageY - this.offsetTop;
    }
    return {"x":x, "y":y};
  }
  HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;;

    console.log('Starting E.B.U.R.P...');
    return App.gurk = new Gurk();
  };

}).call(this);
